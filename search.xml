<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0读书笔记：系统框架]]></title>
      <url>%2F2017%2F02%2F09%2FEffective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[Effective Objective-C 2.0读书笔记：系统框架关于遍历collection元素的方法（共有四种，效率依次提高）： 简单的for循环使用OC1.0中的NSEnumerator，该类的使用方法：（其优点在于有l两种类型的遍历枚举器） [collection objectEnumerator/keyEnumerator]：获取一个NSEnumerator对象。有些collection，如数组中有 reverseObjectEnumerator方法。[NSEnumerator nextObject]：获取下一个object对象，直至nil。[NSEnumerator allObjects]: 获取所有对象的数组for-in循环，只要是实现了 NSFastEnumeration协议的类即可使用。（非并发模式下最快）基于块的遍历方式：基本模式是 -(void)enumrateXXXXXUsingBlock:( xxxx block )；其优点在于： 由于block的模式基本为 ^( id object … )，我们可以修改块的方法签名，将id类型替换为我们想要的类型。这主要是基于id类型方法参数可以被任何类型覆写。这样做的优点在于，如果我们明确某个collection中元素的类型必须是某种类型，那么覆写后编译器将帮我们完成对于该对象方法调用上的正确与否。我们可以使用复杂的带有 NSEnumerationOptions 的方法调用，该参数可以指定 是否并发遍历（NSEnumerationConcurrent，其采用GCD并发队列实现并发），以及是否 反向遍历（NSEnumerationReverse）。采用 位或操作符连接，默认传入0即可。使用无缝桥接技术（仅在ARC下需要使用，MRC不需要），可以在定义于Foundation框架的OC对象与定义在CoreFoundation框架中的C数据结构之间相互转换，具体可以参考无缝桥接技术详解使用NSCache构建缓存：NSCache使用指南NSTimer使用指南：NSTimer使用指南&nbsp;&nbsp;&nbsp;&nbsp;类的初始化方法（ load + initialize ）使用指南：类的初始化方法使用指南]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0读书笔记：块与GCD]]></title>
      <url>%2F2017%2F02%2F09%2FEffective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9D%97%E4%B8%8EGCD%2F</url>
      <content type="text"><![CDATA[Effective Objective-C 2.0读书笔记：块与GCDIOS有监视进程，如果一个app的主线程阻塞太久，那么将会被系统杀死。Clang是xcode的编译器block相关知识：block使用方法使用block相较于delegate的形式：可以有效的降低代码分散程度。关于使用多个回调还是一个块回调，建议使用一个块来回调：（以网络回调举例）：调用的代码可以根据自己的需要来处理问题，而不是简单的划分为两类。通用代码可以最大程度上实现复用。关于代码同步块的写法：使用锁对象： NSLock对象（同线程不可重入，否则将死锁）；NSRecursiveLock递归锁，同一线程能多次持有该锁。使用 @synchronized（xxx）方法：同步语法。使用 ”串行同步队列“：新建一个串行队列，然后想需要互斥操作的代码放入这个串行队列中执行。代码详细参见P167. GCD相对于锁机制而言，由于其是相当底层的C语言代码，因此效率上会有所优化，且可以明确GCD内任务的执行顺序，完成更多复杂的操作等。对于GCD而言，我们需要明确两个特质：同步（sync）还是异步( async )：同步或者是异步，是针对于调用者而言，指其是否需要等待 block执行完成才能继续往下执行代码。串行还是并行：这个取决于queue是 串行队列还是并行队列。（即便是并行队列，也要考虑其是否有设置Target，其有可能不是真正的并行队列）关于同步和异步的效率问题：异步派发有一个隐藏的block copy操作（因为要异步执行），而同步派发是没有的。因此，并不是异步派发效率上一定优于同步派发（更何况有时我们是不能使用异步派发的，比如下面的代码依赖于block执行结果时），如果 block内代码不复杂，那么copy操作的额外消耗可能大于异步带来的好处，引发效率降低。在并发queue的代码块中，为了达到串行执行某些任务的功能，需要使用 dispatch_barrier_async( dispatch_queue_t queue, dispatch_block_t block ) 和&nbsp;&nbsp;dispatch_barrier_sync( dispatch_queue_t queue, dispatch_block_t block )。performSelector的方法缺点：（可以考虑使用GCD代替）如果传入的 SEL 是动态变化的，那么ARC无法判定返回值的类型，也不知道是否需要将返回值release。鉴于此，ARC采用较为谨慎的方式，统一不释放返回值，由此可能引发内存泄露问题。performSelector的返回值默认是id类型，需要转化为其他类型则需要进过转化步骤。且如果执行函数的返回值为C语言结构体，则不可以使用performSelector方法。performSelector的选择子是id类型，如果方法接受基本类型那么将不能使用performSelector。performSelector存在参数个数限制，如果超过3个参数以上，就需要另外想办法执行。OC中有对GCD的高层封装，即NSOperationQueue. GCD是纯C的API，而NSOperationQueue则是OC的对象，其优势如下：（但效率和易用性上不如GCD）可以取消某个操作。在任务加入queue后，我们可以对该 operation执行cancel，如果任务还未被调度，那么它不会被调度。而如果任务已经开始，无法自动取消，但是我们可以在任务的main内定期检测cancel标志位，以达到此效果。可以指定 operation之间的依赖关系，这对于并发队列特别有效。可以参考：http://www.2cto.com/kf/201504/390735.html 。只需要对&nbsp;&nbsp;[blockOp2 addDependency:blockOp1]; 即可。可以指定操作的优先级。比如 [o3 setQueuePriority:NSOperationQueuePriorityHigh]; 可以参考：http://blog.csdn.net/kiki1985/article/details/8734999NSOperation对象可以定制化，且易于在代码中重用GCD并发队列中，执行任务实际所需的并发线程数量，取决于各种因素，而GCD主要是根据系统资源状况来判定这些因素的。（即你无法确定实际有多少个线程）单例的最佳实现方案：建议采用 dispatch_once 来执行只需运行一次的线程安全代码。此方式效率最高，几乎是 @synchronized的两倍。GCD队列可以设置层级关系 &nbsp;&nbsp;dispatch_set_target_queue( queueB, queueA )，一旦设置了层级关系，那么 queueB 上的block 实际将在 queueA 的线程中执行。但我们无法为 系统的GCD 设置依赖关系，它们只能作为 层级的顶端。因为可以设置 target关系，GCD可以呈现一种树状层级结构。因为 sync在同一个 串行GCD上执行时将导致死锁，而 可以设置Target使这种问题变得越发复杂。要检测Target的设置关系：我们需要为每个queue添加标记，然后在使用时检测标记，来判断Target关系。详情可以参见：P183。dispatch_get_current_queue 可以获取当前队列，用于避免一些简单的死锁，但是一旦设置了Target，则无法有效的使用这种机制避免。建议采用上一条的方式来避免死锁。&nbsp;&nbsp;GCD总结： GCD使用方式与效果总结GCD上的死锁出现条件：只有采用sync方式，并最终在 串行队列中执行时，才会引发block。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0读书笔记：接口与API设计]]></title>
      <url>%2F2017%2F02%2F09%2FEffective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1%2F</url>
      <content type="text"><![CDATA[Effective Objective-C 2.0读书笔记：接口与API设计 在编写自己的代码时，主要是类、C函数和全局变量（非static）这类全局可见的符号表，一定要注意加上前缀（苹果默认保留两个字的类名前缀，所以我们要从三个字开始使用）避免命名空间冲突。 在编写自己的第三方framework和静态库时，除了需要遵守第一条守则外，还需要注意，如果在库的内部额外引入了第三方库，那么需要对第三方库的所有类名进行修改，同样的是以添加上自己的类前缀为好。这样就避免了，如果别人同时引入了我们的库和这个第三方库，会造成编译冲突的问题。 属性的读取特质限制，仅能限制通过属性方法对属性变量的操作，但直接对属性变量的操作，是无法通过读取特质来限制的。比如在类内部直接访问属性的实例变量，以及通过KVC直接对属性变量进行赋值等。 针对每个类，我们应该至少提供一个全能初始化方法，编写多个全能初始化方法的依据是，这些方法的初始化过程完成不一致则可以这么做。比如 initWithParam 和 initWithCoder 。在这些全能初始化方法中，应该根据super的情况来调用它的函数（可能不一定是和当前初始化函数名字相同的方法，甚至是相差甚远的方法）。 对于 super的所有初始化方法，理论上我们都应该进行覆盖。对于一些不能使用的，直接 @throw NSException 即可，或者直接返回nil。（建议使用前者，这样程序更加清晰） 在 NSLog %@ 时，会调用相应对象的 description 方法。其默认实现是返回类名 和 指针地址。我们可以覆盖它返回更加详细的数据。（%p 是指针的意思）。在使用 po 对象时，调用的是 debugDescription方法，此时我们根据自己的需要可以返回更加详细的数据。 我们对外暴露的属性，应该尽量是readonly的，而且只在确有必要时才将属性对外公布。为了在类的内部完全打开读写权限，可以在 类的分类中将该属性重新设置为 readwrite。 建议对私有方法加上前缀，这样可以在调试和阅读时一目了然。建议使用“p_”作为前缀。同时不要使用“_”作为前缀，因为这是苹果对自己私有方法的前缀。 理解OC错误模型：IOS异常处理机制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0读书笔记：熟悉OC]]></title>
      <url>%2F2017%2F02%2F09%2FEffective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%86%9F%E6%82%89OC%2F</url>
      <content type="text"><![CDATA[Effective Objective-C 2.0读书笔记：熟悉OC消息与函数调用的区别：关键区别在于，使用消息结构的语言，使用了其运行时所应执行的代码是由运行环境决定的。而使用了函数调用的语言，则由编译器决定。如果范例代码中调用的函数是多态的。那么在运行时就需要按照“虚函数表”来查出到底应该执行哪个函数实现。而采用消息结构的语言，无论是否多态，总是在运行时才会查找所要执行的方法。对象总是分配在堆上，而不是栈上。因此与创建结构体相比，创建对象还需要额外的开销，例如分配和释放堆内存等。由于头文件的展开是依次进行的，那么在OC中使用 #import 指令，在 循环引用 发生时，也不会导致死循环，但会其中一个文件将无法被正确的编译。使用字面量创建的字符串、数组和字典对象都是不可变的。使用字面量时，如果想要放入nil，那么可以用[NSNull null] 对象代替，切不可直接使用，否则将会引起crash。宏指令是在预编译阶段替换的，且替换的有效范围是以编译单元为单位的。即只有引入这个宏的头文件中的内容，才会被替换。由此可以引出编译原理的三大阶段：以.m文件为一个编译单元，展开各自编译单元内的头文件。对每个编译单元进行预编译处理、编译等操作，输出obj文件。对所有的obj文件进行链接，形成程序文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 宏定义展开正是在第二步中完成的。 使用常量定义代替宏定义，在使用上会更加安全。定义的格式请参照 ：只在当前编译单元内可以见的： static 类型 const 变量名 = .......；在外部编译单元可见： （定义） 类型 const 变量名 = .....; &nbsp;&nbsp;&nbsp;&nbsp;（外部引用） extern 类型 const 变量名 &nbsp;&nbsp;= .....； 注意，我们需要将声明放在.h中，将定义放在.h中。这才是良好的编程习惯。如果是 static ，那么放在.h 和 .m 中都无所谓，但建议还是按照规范来。使用系统宏定义来定义枚举，需要进行位操作组合的枚举使用NS_OPTION宏，只是简单列举的宏，使用NS_ENUM宏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0读书笔记：协议与分类]]></title>
      <url>%2F2017%2F02%2F09%2FEffective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[Effective Objective-C 2.0读书笔记：协议与分类 delegate方法和datasource方法最大的区别在于信息流的流向，delegate是从委托人流向被委托人，因此回调方法的返回值为void；而datasource则是从被委托人流向委托人，因此返回值不会void。 在设计 委托协议 时，通常回调方法的第一个参数 都是委托对象自身，因为被委托对象可能同时兼任多个委托对象的delegate/datasource，我们需要传入委托对象，才能正确的区分处理。 如果在委托对象上调用协议的可选方法时，一定要使用 -(BOOL)respondsToSelector:(SEL) 判断是否存在，(注意该方法是 NSObject协议中声明的方法，因此如果希望我们的协议应该都继承于NSObject协议)。因为，如果频繁的多次判断是做无用功，因此我们可以建立一个位域变量，然后重载setDelegate方法，在其设置值时对其能否响应做好判断。具体可以参照 P99页。位域变量示例：typedef struct AA{ unsigned int b1:1; unsigned int b2:1; unsigned int b3:1; unsigned int b4:1; unsigned int b5:1;}AA; 类的分类有两种： class-continuations ： 这是一个特殊的分类，它只能声明在主类的实现文件中。而且扩展名为()。它的三大功能： 这个分类可以生成实例变量，因此可以直接声明属性变量和实例变量，其效果等同于直接在@implement中声明。私有属性和变量可以放在此处。 私有协议也可以放在此处。 如果一个属性在.h中为readonly，那么在此处它可以再次被扩展为readwrite。（注意任何分类出现的属性都应该与同类接口中的属性保持相同的特质，但是仅有readonly可以被扩展为readwrite） 普通分类：有单独的头文件和实现文件，文件名通常为 className+扩展名 ,且@interface 需要指明扩展名。在这些分类中不能生成实例变量。（可以声明属性，但我们需要添加@dynamic，然后自己实现它的属性方法，并使用 关联对象为其设置实例变量） 使用普通分类时，我们需要引入头文件才能使用里面的方法。 分类在编译时，是按照载入顺序依次编译的（载入顺序没有规律）。因此，如果两个分类中存在同名的扩展方法，那么后载入的方法将覆盖前面载入的方法的具体实现。因此，在编写分类时，最好在方法名前面加上分类的扩展名，比如 -（void)abc_urlEncoding; . .mm表示将文件按照objective-C++来编译，如果我们引入的头文件或者是自身代码中包含了C++的语法，比如#include”” 或者是 class 等，我们就需要将实现文件改为.mm。且所有包含了此类头文件的实现文件都需要改为.mm。因此，我们建议在.h中最好不要有任何关于C++的写法。将其写在 class-continuations中，这样，我们就可以暴露一个完全OC的头文件，也不用强迫别人因为使用了我们的头文件而需要将实现文件的后缀改为.mm。 使用匿名对象 id&lt;protocolName&gt;，可以是值的类型多样化。匿名类型不仅可以用在返回参数上，还可以用在调用参数上。如果不符合协议要求，那么将在编译阶段给出警告。 id类型的指针可以指向任何类型的对象，而且像id类型的对象发送一则编译器已知的消息（可以是任何类的，只要是已知的即可），都不会引起编译警告，但可能引起crash，建议先使用 -(BOOL)respondsToSelector:(SEL) 判断是否存在。 在NSDictionary中，键的标准内存管理语意是 设置时copy，而值的内存管理语义是 设置时保留。因此，key的对象必须遵循NSCopying协议。因此，我们可以看到函数： -(void)setObject:(id)object forKey(id&lt;NSCopying&gt;)key;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0读书笔记：对象、消息、运行期]]></title>
      <url>%2F2017%2F02%2F09%2FEffective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E3%80%81%E6%B6%88%E6%81%AF%E3%80%81%E8%BF%90%E8%A1%8C%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[Effective Objective-C 2.0读书笔记：对象、消息、运行期属性有4大特质：原子特质、读写权限、内存管理特质、方法名定制化开发IOS时一般使用 nonatomic ，因为IOS基本都是单线程操作的。在开发MAC OSX时使用 atomic 基本不会遇到瓶颈问题。我们可以直接定义变量，或者是使用属性生成变量。对于属性生成的变量来说，是生成在.m文件中，即外部完全不可见（包括子类）。对于直接定义的变量，默认是 @protected，即外部类型不可直接访问，但子类可以。可以使用@public来改变.h中变量的访问权限。在初始化方法中(init等)，应该直接使用 实例变量来赋值，因为属性方法可能在子类中被改写，从而与预期不一致。对于类内部的其他时候，合理的访问方式应该是：在写入实例变量时，总是采用属性方法。而访问则采用直接访问实例变量的方式获取。关于 [xxx class] 的返回值，这个方法是每个具体类的类方法，其返回的是自身。那么就分为两种情况：对于实例对象调用class方法：其返回自己所属的类。对于类对象调用class方法：其返回自身。 &nbsp;&nbsp;&nbsp;&nbsp; 因此， 循环调用的结果就是，每次返回值都是一致的。ios中有很多类型其都具有类族的概念，比如 UIButton，我们通过 buttonWithType: 返回的是其基类下某一个具体子类的实例变量。而基类通常 包含了对下面具体子类的接口抽象。这个概念很重要，这意味这我们平时使用的大多数控件都是一个类族形式，而指针均是基类的指针。判断对象的类和类族的方法：isKindOfClass: 可以比较前者是否属于后者的类族。其比较范围是 ： 以后者开始为根类，展开的类族树中，是否包含前者的类型。isMemberOfClass: 严格比较前者和后者的类型是否一致。&nbsp;&nbsp;== ： 其实和第二种是一样的。关于对象等同性判断：通过 hash 和 isEqualTo: （在这里面，我们首先需要实现的就是对其类型判断是否一致）这两个函数一致，那么就表示这两个对象是等同的（不一定是同一个对象）。因此，若想判断某个类型的对象是否相等，请提供这两个函数。关于 hash 函数，在NSObject 的默认实现中，其是直接返回指针地址。对于其他系统类，系统会根据其内容的不同，返回不同的hash值。（这是很好的可以利用的一点）。关于我们的自定义类，要实现高效且正确的hash函数必须满足以下要求：在 isEqualTo： 返回YES时，其hash值必须相等。（这是一种约定，也是NSSet高效插入的一种机制）提取出类中的不可变系统类型，获取他们的hash值。（不可变是因为，防止其在插入NSSet后，hash值又发生变化，最终会导致NSSet中出现重复对象）组合第二步中的所有hash值，得到一个最终的hash值。（可通过加减运算或者位运算得到）当我们想要编写系统类型的子类时，我们需要覆写超类文档中指明的需要覆写的方法。这个一般在文档中会写明。使用关联对象的方式，可以把两个对象连接起来。详情参见P41。注意，在链接时，其键值是个指针值，我们通过这个键值设入对象，也需要通过这个键值获取对象。因此，这个键值我们通常采用 常量字符串变量 来表示： static NSString* const xxxxx = @"xasdasda"; . &nbsp;&nbsp;我们可以用这个方法来伪造属性，即把 get/set 方法放在 属性的获取和设置函数中。关于 &nbsp;&nbsp;IOS方法转发机制P46&nbsp;&nbsp;和 &nbsp;&nbsp;IOS方法调配技术P53&nbsp;&nbsp;将单独开辟文章来详述。isa表示了一种的对象的从属关系（包括类对象），表示新建这个对象的类型是哪一个/这个对象属于哪个类型。而superclass则指明了类的继承关系。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0读书笔记：内存管理]]></title>
      <url>%2F2017%2F02%2F09%2FEffective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[Effective Objective-C 2.0读书笔记：内存管理关于自动释放池 @autoreleasepool ，其会在稍后将对象的引用计数减1（池子释放时），而不会立即减1。如果不是自己添加的释放池，那么释放的时机通常是在下一次“事件循环”时发生。在使用ARC简化引用计数写法，不仅可以提升开发效率，还可以提升运行效率。因此以下原因：ARC添加的内存管理语句都是C函数，避开了消息调用流程，加快了执行速度。（还要注意，这意味着我们对release等消息的覆盖是无效的）ARC包含运行期组件，能自动检测成对的互斥语句，比如函数返回时autorelease 和 外部变量对其执行的retain操作，它在识别到这些操作时，将通过一个标志位对这些操作进行标记，而避免调用 autorelease 和retain语句，从而加快了速度。（当然，这对我们来说是透明的）ARC内存管理规则：ARC下，内存管理语义成为硬性规定。以 alloc &nbsp;&nbsp; new &nbsp;&nbsp; copy &nbsp;&nbsp; mutableCopy 返回的对象，其持有权归调用者所有。而其他函数返回的对象会自动执行一次 autorelease ，（当然外部接收的变量会自动做一次 retain），具体可以参考 P123。在ARC时，默认情况下，每个变量都是指向对象的强引用。其对于生成的属性方法的自动内存管理语句是：先保留新值（tmp），再释放旧值，最后设置实例变量。这是最安全的属性设置方式。ARC只能管理Objective-C对象，但是比如 CoreFoundtion中的对象等C语言对象还是需要自己管理内存的。使用ARC后不可覆盖 release &nbsp;&nbsp;retain &nbsp;&nbsp;autorelease 等语句，否则会干扰ARC分析对象的生命期的工作。dealloc方法只执行一次，也就是引用计数降为0时执行，但具体何时执行，不做保证。且在程序中，会有极个别对象，在应用终止时，仍处于存活状态，这些对象不会收到daalloc消息。如果一定要清理这些对象那么可以在 -(void)applicationWillTerminate:(UIApplication*)application 中完成操作。建议的dealloc方法编写原则：在dealloc中不要调用属性的存取方法。在dealloc中优先完 通知监听的解除，以及 KVO监听的解除。dealloc不应该出现异步线程的操作。关于异常安全代码： IOS异常处理机制在大量产生临时对象的地方，或者大的fou循环内部一定要添加添加上 @autoreleasepool （不要担心频繁执行的效率问题），这样能及时回收临时变量，有效的降低内存峰值。（当时spotlight里就是这么做的，图片格式转换产生了大量的临时对象，需要用这种方法去及时回收）启用僵尸对象调试内存问题，僵尸对象在接收到消息后会抛出异常，并输出打印，其中包含对象类型和消息方法。关于僵尸对象的实现原理，具体来说分为以下几步：运行期系统如果检测到NSZombieEnabled，那么就会将dealloc方法调配（” IOS方法调配技术“）。在修改后的dealloc中执行以下几步：用旧类的名字生成名为 _NSZombie_xxxx 的僵尸类，并注册到runtime中；执行旧类对象的dealloc语句（但不回收内存）；将旧类对象的isa指针指向新类。改写僵尸类的消息转发机制（” IOS方法转发机制“），使其可以响应任何方法并统一传递到一个地方处理。在处理消息的地方，打印输出 旧类名 和 消息名 以及 实例对象指针，然后 abort() 程序。retainCount是不可靠的，主要是由于以下原因：它只反映某个给定时间点上的保留计数值，但这个值不考虑已执行的但还未生效的autorelease调用。系统有时候会优化对象释放行为，在保留技术为1时即回收，那么这个值永远不归0.系统会尽量把 NSString对象实现为单例对象（那么它的保留计数将是MAX）。对于整形的NSNumber，系统也会 ”标签指针“的模式优化（可能），此时也会导致保留计数失效。参考可见P147.基于以上原因，请绝对不要用retainCount。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C#学习笔记]]></title>
      <url>%2F2017%2F02%2F09%2FC%23%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[C#学习笔记 C#基础语法学习： C#中所有变量都是对象，当然按照类型来分，可以分为值类型、引用类型和指针类型。也就是说，C#没有传统意义上的内置类型，int\float\double等都是结构体对象，属于值类型，而引用类型就是class类型对象，当然也可以是new出来的结构体对象。 对于非new出来的结构体对象，其成员变量在首次装载值之前是不能使用的。但对于new出来的对象，其内存块是clear的，所有引用类型的成员变量会被置为null，而所有的值类型数据会被清零。 对于引用类型的局部变量，C#要求必须先赋值，再使用。 对于值类型数据，我们可以通过在&lt;data_type&gt;? var_name = null，的形式，表示其为可空类型，从而为其添加一个nul值。否则正常的值类型数据是不能添加null值的。当然，引用类型是默认可以赋为null。 如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 internal，成员的默认访问标识符是 private。 C#封装修饰符： Public Private Protected Internal：访问说明符允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。换句话说，带有 internal 访问修饰符的任何成员可以被定义在该成员所定义的应用程序内的任何类或方法访问。只要是当前项目内的，不同文件也是可以的。 Protected Internal：访问修饰符允许一个类将其成员变量和成员函数对同一应用程序内的子类以外的其他的类对象和函数进行隐藏。这也被用于实现继承。 C#没有引入头文件的概念，如果需要使用一个类，直接使用就好，处于同一个项目中的所有文件都是相互可见的【与swift一致】。需要注意的是，如果没有 using &lt;namespace&gt; ，那么需要使用 namespace.xxx 来使用这个类。 命名空间可以嵌套，嵌套的命名在使用时也要加上所有嵌套的命名空间名字。 密封类与抽象类： 密封类：通过在类定义前面放置关键字 sealed，可以将类声明为密封类。当一个类被声明为 sealed 时，它不能被继承。抽象类不能被声明为 sealed。 抽象类：使用关键字 abstract 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。抽象类包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。【不能初始化一个抽象类的实例】 抽象类允许存在实例成员变量 和 实例方法【带有实现代码的】，但是被标记为abstract 的方法不允许存在实现代码。在继承类中必须override abstract方法才能被实例化。 抽象类中允许不存在任何abstract方法，但它还是一个抽象类,依然无法被实例化。 函数重载：同一个类中同名方法的重载。重载依据：函数参数个数、函数参数的类型。 动态多态性的实现基础：抽象类和虚函数。【注意，静态函数不参与多态】 抽象类：通过定义抽象类，那么继承类需要实现抽象类中的所有abstract方法。继承的子类中，需要对所有abstract方法进行 override。 虚函数：在基类中将方法声明为virtual，那么在继承的子类中，需要对所有virtual方法进行 override。 关于子类中调用父类方法的方式： 普通函数：需要在函数中显示的调用 base.xxxx() 才可以调用父类的方法。 构造函数：如果需要预先执行父类的构造函数，必须在子类构造函数中 : base( .. ) 才可以正常调用。例如：public Rectangle( int a=0, int b=0) :base(a, b)。 C#支持默认参数的写法。和C++一样，要求从右至左的填写默认参数。 C#运算符重载：C#要求所有运算符重载都必须是public static的。 C#运算符集合： 运算符 描述 +, -, !, ~, ++, -- 这些一元运算符只有一个操作数，且可以被重载。 +, -, *, /, % 这些二元运算符带有两个操作数，且可以被重载。 ==, !=, &lt;, &gt;, &lt;=, &gt;= 这些比较运算符可以被重载。 &amp;&amp;, || 这些条件逻辑运算符不能被直接重载。 +=, -=, *=, /=, %= 这些赋值运算符不能被重载。 =, ., ?:, -&gt;, new, is, sizeof, typeof 这些运算符不能被重载。 C#判断某个对象是否是某个类的实例：is ，示例：( str is string ) 接口使用 interface 关键字声明，它与类的声明类似。接口声明默认是 public 的。 C#预编译指令： 预处理器指令 描述 #define 它用于定义一系列成为符号的字符。 #undef 它用于取消定义符号。 #if 它用于测试符号是否为真。 #else 它用于创建复合条件指令，与 #if 一起使用。 #elif 它用于创建复合条件指令。 #endif 指定一个条件指令的结束。 #line 它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。 #error 它允许从代码的指定位置生成一个错误。 #warning 它允许从代码的指定位置生成一级警告。 #region 它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。 #endregion 它标识着 #region 块的结束。 #line：使您可以修改编译器的行号以及（可选）错误和警告的文件名输出。下面的示例说明如何报告与行号关联的两个警告。#line 200 指令强迫行号为 200（尽管默认值为 #7）。另一行 (#9) 作为默认 #line 指令的结果跟在通常序列后。 #region和#endregion：用于代码块的包裹和折叠/展开。只在VS上生效。 #if：使用规范【 #if symbol [operator symbol]… 】，operator是以下四种之一：== (equality)、!= (inequality)、&amp;&amp; (and)、|| (or)。可以用括号把符号和运算符进行分组。条件指令用于在调试版本或编译指定配置时编译代码。一个以 #if 指令开始的条件指令，必须显示地以一个 #endif 指令终止。 C#中在debug模式下存在预定义宏（DEBUG） C#的异常处理： C# 异常处理时建立在四个关键词之上的：try、catch、finally 和 throw。使用示例如下： try { // 引起异常的语句 } catch( ExceptionName e1 ) { // 错误处理代码 } catch( ExceptionName e2 ) { // 错误处理代码 } catch( ExceptionName eN ) { // 错误处理代码 } finally { // 要执行的语句 } C# 中的异常类主要是直接或间接地派生于 System.Exception 类。主要分成以下两大类： System.ApplicationException：支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。 System.SystemException：是所有预定义的系统异常的基类。以下是预定义的系统Exception分类： 异常类 描述 System.IO.IOException 处理 I/O 错误。 System.IndexOutOfRangeException 处理当方法指向超出范围的数组索引时生成的错误。 System.ArrayTypeMismatchException 处理当数组类型不匹配时生成的错误。 System.NullReferenceException 处理当依从一个空对象时生成的错误。 System.DivideByZeroException 处理当除以零时生成的错误。 System.InvalidCastException 处理在类型转换期间生成的错误。 System.OutOfMemoryException 处理空闲内存不足生成的错误。 System.StackOverflowException 处理栈溢出生成的错误。 被catch住的Exception,可以再次被抛出。那它会向上层继续抛出。 C#的类成员变量（静态或者非静态），均支持声明初始化方式。但是如果同时声明了构造函数的话，以构造函数为准。 C#数组： 内容较多，详情参考文章：http://www.runoob.com/csharp/csharp-array.html 声明： double[] balance; 简单初始化： double[] balance = new double[10]; 直接初始化-1： double[] balance = { 2340.0, 4523.69, 3421.0}; 直接初始化-2： int [] marks = new int[5] { 99, 98, 92, 97, 95}; 直接初始化-3： int [] marks = new int[] { 99, 98, 92, 97, 95}; C#多维数组： 标准多维数组： 二维数组示例：string[,] a = new string[4,5] 三维数组示例：string[ , , ] a = new string[4,5,6] 交叉数组： 二维交叉数组示例：string [][] a = new string[5][] 三维交叉数组示例：string [][][] a = new string[5][][] 解析：对于交叉数组来说，它其实是指针的数组，因此和传统的一维数组没有区别，只是成员全部都换成了指针。也是因为如此，交叉数组的第一维必须是确定的。 C#高级语法学习： C#特性：是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。特性可以在运行时动态的被程序获取到。 基础语法： [attribute(positional_parameters, name_parameter = value, ...)] element 预定义特性：【Conditional、Obsolete、AttributeUsage】 Conditional：条件特性。 语法： [Conditional( conditionalSymbol)] 示例： [Conditional("DEBUG")] public static void Message(string msg) { Console.WriteLine(msg); } 效果：当被编译时，如果 DEBUG 没有被 #define，那么函数 Message 将被替换为空实现。相比于条件编译语句 #if-#elif-#else-#endif ，其在变量未定义时，可以直接使用，只是被替换为空实现，不需要再每个实现的地方都加上条件编译语句。 Obsolete：标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。 语法： [Obsolete( message)][Obsolete( message, iserror)] 参数 message，是一个字符串，描述项目为什么过时的原因以及该替代使用什么。 参数 iserror，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。 示例： [Obsolete("Don't use OldMethod, use NewMethod instead", true)] static void OldMethod() { Console.WriteLine("It is the old method"); } 用法：参与编译器报错/告警，可以对废弃方法产生警告或者报错。 AttributeUsage：最常用的特性，用于生成自定义特性。 语法： [AttributeUsage( validon, AllowMultiple=allowmultiple, Inherited=inherited)] 参数 validon 规定特性可被放置的语言元素。它是枚举器 AttributeTargets 的值的组合。默认值是 AttributeTargets.All。 参数 allowmultiple（可选的）为该特性的 AllowMultiple 属性（property）提供一个布尔值。如果为 true，则该特性是多用的。默认值是 false（单用的）。 参数 inherited（可选的）为该特性的 Inherited 属性（property）提供一个布尔值。如果为 true，则该特性可被派生类继承。默认值是 false（不被继承）。 作用：用于声明和创建自动自定义特性。具体用法参见自定义特性使用。 自定义特性： 创建并使用自定义特性的步骤： 声明自定义特性： // 一个自定义特性 BugFix 被赋给类及其成员[AttributeUsage(AttributeTargets.Class |AttributeTargets.Constructor |AttributeTargets.Field |AttributeTargets.Method |AttributeTargets.Property,AllowMultiple = true)] public class DeBugInfo : System.Attribute 构建自定义特性：对 DebugInfo这个类进行具体实现。 在目标程序元素上应用自定义特性： [DeBugInfo(49, "Nuha Ali", "10/10/2012", Message = "Unused variable")] class Rectangle {…} 通过反射访问特性【参见下面】 步骤示例：参见http://www.runoob.com/csharp/csharp-attribute.html 注意要点： 对于 require 的参数，需要使用构造函数来实现，对于 optional 的参数，我们可以暴露 public 的成员变量 或者是 属性方法来给外界设置。对于上面的例子来说，前三个无key值的参数就是构造函数所需的参数，最后一个Message则是属性方法设置。【其实，使用message = “xx” 也是可以的】 对于自定义的特性，所有数据赋值必须在 【】内完成，基本使用格式为：【自定义特性名（构造函数参数列表，public_property/var = value）】。 C#反射： 定义：反射指程序可以访问、检测和修改它本身状态或行为的一种能力。 作用： 它允许在运行时查看属性（attribute）信息。 它允许审查集合中的各种类型，以及实例化这些类型。 它允许延迟绑定的方法和属性（property）。 它允许在运行时创建新类型，然后使用这些类型执行一些任务。 运行时查看时属性： static void Main(string[] args) { Rectangle r = new Rectangle(4.5, 7.5); r.Display(); Type type = typeof(Rectangle); // 遍历 Rectangle 类的属性 foreach (Object attributes in type.GetCustomAttributes(false)) { DeBugInfo dbi = (DeBugInfo)attributes; if (null != dbi) { Console.WriteLine("Bug no: {0}", dbi.BugNo); Console.WriteLine("Developer: {0}", dbi.Developer); Console.WriteLine("Last Reviewed: {0}", dbi.LastReview); Console.WriteLine("Remarks: {0}", dbi.Message); } } // 遍历方法属性 foreach (MethodInfo m in type.GetMethods()) { foreach (Attribute a in m.GetCustomAttributes(true)) { DeBugInfo dbi = (DeBugInfo)a; if (null != dbi) { Console.WriteLine("Bug no: {0}, for Method: {1}", dbi.BugNo, m.Name); Console.WriteLine("Developer: {0}", dbi.Developer); Console.WriteLine("Last Reviewed: {0}", dbi.LastReview); Console.WriteLine("Remarks: {0}", dbi.Message); } } } Console.ReadLine(); } 其中GetCustomAttributes该方法是返回此成员所有自定义特性数组，inherit参数用于表示是否搜索此成员的继承链以查找这些属性。未包含任何特性时，返回一个空数组。 其他的后续补充 C#属性： 定义：属性（Property） 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 域（Field）。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 访问器（accessors） 让私有域的值可被读写或操作。 特点：属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 访问器（accessors）。 用法示例： // 声明类型为 string 的 Code 属性public string Code{ get { return code; } set { code = value; }} 抽象类可拥有抽象属性，这些属性应在派生类中被实现： public abstract class Person { public abstract string Name { get; set; } public abstract int Age { get; set; } } 属性可以只实现 get/set 方法的某一个，成为只读属性/只写属性。如果父类中的属性为只读或者只写，那么Ovveride的属性不能更改其读写特性。 C#索引器： 一维索引器的定义： element-type this[key-type index] { // get 访问器 get { // 返回 index 指定的值 } // set 访问器 set { // 设置 index 指定的值 }} 多维索引器定义： 示例：public int this[string name, int index1]{ ... } 重载索引器：索引器（Indexer）可被重载。索引器声明的时候也可带有多个参数，且每个参数可以是不同的类型。没有必要让索引器必须是整型的。C# 允许索引器可以是其他类型，例如，字符串类型。 C#委托： 定义:类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类。 语法： delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt; 声明一种类型的委托示例： public delegate int MyDelegate (string s); 实例化委托变量示例：委托对象必须使用 new 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 new 语句的参数就像方法调用一样书写，但是不带有参数。 public delegate void printString(string s);... printString ps1 = new printString(WriteToScreen); printString ps2 = new printString(WriteToFile); 委托的多播： 定义：委托对象可使用 "+" 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。"-" 运算符可用于从合并的委托中移除组件委托。 特点：委托合并后，函数调用的顺序与其添加的顺序一致。采用的是队列的方式。 作用：使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。 注意事项：委托和函数指针其实是完全一样的，只是 委托要求我们一定要 定义一种类型的委托【类似于typedef】，然后再拿着这个委托去声明变量。 C#事件： 重要：细心点我们会发现，其实有event关键字有无的效果是一样。因为event主要的作用是给编译器识别的。event关键字，限定了外界对委托变量只能使用+=或-=操作符，对于其他的比如赋值或者调用都会被视为错误。而其他delegate变量只能先赋值，然后再做 += 或者 -= 操作，否则会出错。语法&amp;示例： public delegate void BoilerLogHandler(string status); public event BoilerLogHandler BoilerEventLog; C#泛型：定义：泛型允许您编写一个可以与任何数据类型一起工作的类或方法。定义语法：类泛型： publicclassMyGenericArray&lt;T&gt; { private T[] array; publicMyGenericArray(int size) {方法泛型：staticvoidSwap&lt;T&gt;(ref T lhs,ref T rhs) { T temp; temp = lhs; lhs = rhs; rhs = temp; }委托泛型：delegate T NumberChanger&lt;T&gt;(T n);使用语法：类泛型：// 声明一个整型数组 MyGenericArray&lt;int&gt; intArray =newMyGenericArray&lt;int&gt;(5);方法泛型：// 调用 swap Swap&lt;int&gt;(ref a,ref b); Swap&lt;char&gt;(ref c,ref d);委托泛型：// 创建委托实例 NumberChanger&lt;int&gt; nc1 =newNumberChanger&lt;int&gt;(AddNum); NumberChanger&lt;int&gt; nc2 =newNumberChanger&lt;int&gt;(MultNum);c#匿名方法：定义：提供了一种传递代码块作为委托参数的技术，类似于block，可以捕获外部变量。要点：由于c#中没有基本数据类型，全是对象，所以将会捕获外部变量匿名方法是没有名称只有主体的方法。在匿名方法中您不需要指定返回类型，它是从方法主体内的 return 语句推断的。匿名方法是通过使用 delegate 关键字创建委托实例来声明的。示例：delegatevoidNumberChanger(int n);// 使用匿名方法创建委托实例 NumberChanger nc =delegate(int x) { Console.WriteLine("Anonymous Method: {0}", x); };C#API集合： 所有Collection都可以使用 foreach语句ArrayList：动态数组 参考文章：http://www.runoob.com/csharp/csharp-arraylist.html 只要是 object 对象，就都可以加入数组，而C#所有对象都是继承于object的。 Hashtable:哈希表【无序字典】，代表了一系列基于键的哈希代码组织起来的键/值对。它使用键来访问集合中的元素。 参考文章：http://www.runoob.com/csharp/csharp-hashtable.html注意，key应该是一个不可变对象。 SortList:【有序字典】，按照key排序。参考文章：http://www.runoob.com/csharp/csharp-sortedlist.html不允许出现两个相同的key值，否则会报错。这里的相等使用的是 equals方法。两个相同内容的string对象，算是相同的key值。Stack：【堆栈】代表了一个后进先出的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为推入元素，当您从列表中移除一项时，称为弹出元素。参考文章：http://www.runoob.com/csharp/csharp-stack.html使用foreach时，依然遵照后进先出原则。使用ToArray()时，依然遵照后进先出原则。Queue：【队列】代表了一个先进先出的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为入队，当您从列表中移除一项时，称为出队。参考文章：http://www.runoob.com/csharp/csharp-queue.html使用foreach时，依然遵照先进先出原则。使用ToArray()时，依然遵照先进先出原则。BitArray：位数组。参考文章：http://www.runoob.com/csharp/csharp-bitarray.htmlAnd( xxx ) 与 Xor( xxx )中，xxx操作必须确保与调用对象的长度是一致的。C#多线程：参考文章：http://www.runoob.com/csharp/csharp-multithreading.html参考要点：主线程需要等待子线程执行结束才能退出。当任一线程抛出异常或者意外终止时，整个程序都会退出。线程可以在外部被终止，只需要对线程对象调用Abort()即可，具体来说就是 xxxThread.Abort()即可，该异常无法被 try-catch捕获，但是 如果有finally语句，依然可以执行。 C#实用技巧： 判断一个对象是否属于某个类型：o is Object ，返回值时 Boolean,对于null的对象值，永远返回false。 强制转换对象： 方法一：在这个方法中，进行了两次类型检查，第一个if判断，第二次强制转换检查。is 等同于 OC中的 isKindOf: ,会查找继承链。 if(o is Employee) { Employee e = (Employee) o; //在if语句中使用e } 方法二：只进行一次类型检查，as是新推出的一个标识符。 Employee e = o as Employee;if(e != null){//在if语句中使用e} foreach 快速循环语句：foreach (MethodInfo m in type.GetMethods()) { … }可以迭代获取数组中的每一个成员。C#输出格式大全：占位多少：{0，6}表示占6位，默认右对齐。{0，-6}表示占6位，但是左对齐。C#中值-结果参数的传递方法：swap( ref string a, ref string b )，需要使用 ref 标识对象，这样a和b取到的是外部指针本身。unsafe：在c#中使用指针，必须为代码块添加上 unsafe 标识。该标识可以添加在方法修饰词位置，也可以单独形成一个代码块 unsafe{ … }.注意：Mono默认是不允许 unsafe 代码的，需要我们在项目设置中手动打开。详情参见Mono打开 unsafe 的方法。用法：指向普通变量指向数组变量：如果您需要使用指针变量访问数组数据，可以像我们通常在 C 或 C++ 中所做的那样，使用 fixed 关键字来固定指针。int[] list ={10,100,200}; fixed(int*ptr = list) /* 显示指针中数组地址 */ for(int i =0; i &lt;3; i++) { Console.WriteLine("Address of list[{0}]={1}",i,(int)(ptr + i)); Console.WriteLine("Value of list[{0}]={1}", i,*(ptr + i)); } Console.ReadKey(); 常见问题：C#不允许使用实例变量去调用它的静态方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Unity引擎学习笔记]]></title>
      <url>%2F2017%2F02%2F09%2FUnity%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Unity引擎学习笔记参考资料：官方手册：file:///Applications/Unity/Unity.app/Contents/Documentation/en/Manual/UnityManual.html,这还是离线手册。引擎基础知识学习：最常见的资源之间的关系介绍：纹理【Texture】应用于材质【Material】材质【Material】应用于游戏对象【GameObject，带有网格渲染组件】动画【Animation】应用于游戏对象【GameObject，带有动画组件】音频文件【Audio】应用于游戏对象【GameObject，带有音源组件】纹理【Texture】：参考：http://www.ceeger.com/Components/class-Texture2D.html纹理尺寸是2的升幂（如32x32，64x64，128x128，256x256等）。材质【Material】：每个材质都需要选择着色器【Shader】，每种着色器都有自己更加适合的渲染场景。着色器分类：主游戏对象着色器：普通 (Normal)：不透明纹理对象。透明 (Transparent)：部分透明的对象。纹理的 alpha 通道定义着透明度。镂空透明 (TransparentCutOut)：含完全不透明和完全透明区域的对象，如：栅栏。自发光 (Self-Illuminated)：有发光部件的对象。反光 (Reflective)：反射环境立方体贴图 (Cubemap) 的不透明纹理对象。FX：光照和水景效果。GUI: 图形用户界面显示。自然 (Nature)：树木和地貌。粒子 (Particles)：粒子系统效果。Render FX：天空盒着色器。卡通 (Toon)：卡通风格的渲染。有些着色器还有移动设备的版本。参考文章：http://docs.manew.com/Manual/index.htm游戏对象是一个容器，组件是容器里的各个功能模块，脚本是各个事件的回调对象。【事件可由系统或者其他组件、对象发出】组件特性介绍：组件的属性分为赋值属性和引用属性。组件类型分类：变换组件【Transform】：默认组件，所有游戏对象都有。决定了物体的位置、旋转、大小和Local坐标系等元素。刚体组件【Rigidbody】：这是为物体赋予物理能力的组件，只有拥有刚体组件的物体会遵循物理规律，比如重力作用，动量守恒/能量守恒等。重力式刚体组件中的一个特性，可以被单独去除。脚本组件【MonoBehaviour】：当为一个gameobject【预制对象/新建对象/编辑器创建对象】添加脚本组件后，该脚本对象的gameObject成员将和实际的控件关联到一起。脚本组件可以在外部被获取，被获取后，使用 scriptObj.enabled = false,可以使脚本组件不再生效。碰撞组件【Collider】：只有接触双方都开启碰撞组件的情况下，才会发生碰撞关系。碰撞组件默认开启。当发生碰撞时，会调用双方的音频组件【Audio】：包括音频、视频等想要在一个gameObject上顺利的播放Audio组件，必须确保其上有一个Audio Listener组件。播放源 (Source) 时，音频侦听器 (Audio Listener) 可"听到"范围内的所有源，将这些源组合起来，声音即可通过扬声器发出。您的场景中只能有一个音频监听器 (Audio Listener)，并且监听器通常附属于主相机 (Main Camera)。光源组件【light】：光源分为 平行光，点光源，聚光灯，渲染消耗资源依次增加。渲染方式分为 顶点渲染【粗糙】和像素渲染。【节省资源】：如果某个场景中的光照是固定的，那么可以使用光照贴图代替场景光照本身。摄像机组件【Camera】：【http://www.ceeger.com/Manual/Cameras.html】你可以创建多个相机并且给每一个分配不同的深度。相机是按深度从低到高来绘制的。你可以调整标准视口矩形（参照前面的属性列表）的属性值来改变其大小和其在屏幕上的位置。这样你就可以创建多个小视窗，如导弹控制器，小地图窗口，后视镜等等。出于性能原因，你可能需要尽早剔除小物体。例如，小石块和碎片相对于大型建筑会在更短距离内不可见。要做到这一点，将小物体放入一个隔离层（separate layer）并使用Camera.layerCullDistances脚本函数设置每一层的剔除距离动画组件【Animation】：网格过滤器组件【Mesh Filter】：Mesh将决定物体的渲染方式和形状。网格是一组顶点和三角形数组。网格渲染器组件【Mesh Render】：引擎进阶知识：引擎默认方向：Y轴竖向朝上为正，Z轴指向屏幕内为正，X轴与屏幕平齐向右为正。引擎事件处理机制：所有的回调函数都编写在script类中，该类继承于MonoBehaviour。很多组件都有他们相应的 Message消息，当产生这些消息时，发送相应的消息即可调用到 script中已编写的回调。gameObject的sendMessage（）函数有三种类型，具体可以参见：http://www.cnblogs.com/sevenmoons/p/3990397.htmlsendMessage方法，目前最多只支持一个参数，且无参和单参数且类型匹配的方法都会被调用到。可以调用 private方法如果一个gameObject下挂有多个脚本，那么会将所有enable脚本的 指定函数名函数都执行一遍。关于sendMessage的详解：http://www.cnblogs.com/kylinxue/p/4473444.html关于sendMessage的效率分析：http://blog.csdn.net/cartzhang/article/details/50686627关于C#动态执行字符串对应函数的实现：https://zhidao.baidu.com/question/570693043.html游戏中有很多的游戏对象，每个对象都会有很多的组件，比如刚体组件，脚本组件等。每一个脚本必定是绑定到某一个具体的gameObject才会生效。此时，脚本类中 this代表的是脚本组件本身，而this.gameObject代表的是游戏对象。获取控件的方式：代码获取：使用 Gameobjet.Find( string name ) 可以获取当该名字的对象，需要注意的是，这种查找是递归遍历查找的方式，即使是非直接元素，也可以被获取到。【因此，我们在设计面板中控件的名字一定要不同】动态绑定【建议】：在脚本中生成一个该类型的成员变量，然后在 属性面板 - Script 中对该变量进行拖放赋值。此处最为赞的一点是，如果我们声明的变量是某一个组件，那么当我们把该组件所属的gameObj拖放到该变量上时，该变量的值 = gameObj.组件 ，而不会傻乎乎的是那个gameObj。获取组件的方式：对象：任一GameObject对象。方式：使用 gameObj.getComponent&lt;Type&gt;() 即可获取到相应组件，Type的名字一般与我们在属性面板看到的名字相同，即组件类名。但需要注意，该方法可能返回为空。获取脚本组件的方式：gameObj.getComponent&lt;脚本类名&gt;()，其实这里的Type指的就是类名。gameObejct可以被动态的启用或者停用，调用gameObject.activeSelf = True/False，即可修改激活状态。注意，修改父对象的activeSelf会影响所有子对象的激活状态，但是子对象的activeSelf不变化。因此，要判断一个对象是否真的激活，需要读取该对象的activeInHierarchy。多重对象编辑：在选择多个对象时，在检视面板上只有那些在所有被选中的对象上出现的组件才会被显示出来。如果组件只存在与某些被选中对象上，那么在检视面板底部出现一个小的提示，指示那些仅仅在部分被选中对象中存在的组件不能被多重编辑细分概念：skin width：指的是两个碰撞物体发生碰撞时可被渗透的范围。Camera - Viewport Rect:作用：每一个camera都可以将自己捕获到的画面渲染到屏幕上，这个可以使视图只在屏幕的部分区域展示，实现多个摄像机画面同时输出。坐标系统：左下角【0，0】 - 右上角【1，1】，超出范围不展示大小系统：【0，0】 - 【1，1】Camera - Depth:展示优先级，优先级越大的摄像机，画面越后渲染，可以覆盖之前的画面。其与Viewport Rect 结合可以生成画中画效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Unity工具学习笔记]]></title>
      <url>%2F2017%2F02%2F09%2FUnity%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Unity工具学习笔记Unity项目面板：Project Browser：项目文件管理界面，http://www.ceeger.com/Manual/ProjectView40.html支持多重条件搜索【and关系，空格分开】支持类型搜索、标签搜索【支持GUI以及特定语法方式，同类型支持多个条件，or关系，使用 ctrl 多选，或者直接使用语法添加】支持搜索条件一键保存支持Asset、选中文件夹、Asset Store三个范围的搜索Hierarchy：包含游戏中所有gameobject，http://www.ceeger.com/Manual/Hierarchy.html父子级：子对象将继承父对象的移动、旋转和缩放，参见变化：http://www.ceeger.com/Components/class-Transform.html#Parenting。Toolbar：工具栏，http://www.ceeger.com/Manual/Toolbar.htmlLayers：控制那一层的对象可以显示在场景中，具体作用：http://www.ceeger.com/Components/Layers.htmlLayout：unity整个页面的各个面板布局是如何的，不要轻易切换。 :切换轴心点，物体本地坐标系/全局坐标系Scene View：场景视图，http://www.ceeger.com/Manual/SceneView40.html操作技巧：http://www.ceeger.com/Manual/SceneView40.html视图模式：http://www.ceeger.com/Manual/ViewModes.html顶点拼接操作：http://www.ceeger.com/Manual/PositioningGameObjects.html可以用于快速拼接墙体，赛道等物体。场景视图工具栏：http://www.ceeger.com/Manual/ViewModes.html帮助提示：属性面板凡是有不懂的地方，可以直接点 【?】可以直接跳转到网页说明，里面有详细解释。视角切换技巧：【先把视角想象成一个人眼摄像机，注意，与游戏中的视觉摄像机是分开的两套系统】使用 alt + 鼠标：可以调整摄像机拍摄的方向使用双指前进/后退：可以调整摄像机的放大倍数，或者说是沿着拍摄方向移动摄像机前进或者后退一段距离。使用方向键：移动摄像机的位置：可以使用鼠标拖拽画面在控件面板中选中一个物体，然后鼠标切换到设计面板并激活，然后按F，即可将视角中心切换到此处。Scene面板tab栏的作用：【】拖拽画面：使用鼠标拖拽画面拖拽物体：选中物体，并拖拽移动物体。当选中轴时，会顺着轴移动，当选中整个物体时，可以任意移动。旋转物体：会出现三个颜色不同的圈，与颜色相同的轴相切。可以选中物体向任意方向拨动。拉伸物体：会出现与坐标轴一样的轴向，任意拖动一轴，可以沿该方向拉伸/缩放物体。拉伸物体【高级】：以顶点方式拉伸变化物体，可以视为4的进阶版。脚本语言的选择：Unity支持C# 和 JS 脚本共存，反正都只起到脚本作用。对同一个物体可以添加多个脚本，一个脚本也可以赋给多个脚本。当一个物体上有多个脚本时，默认之前排名第一的脚本。【即使都勾选的情况下也是如此】输入事件：在 Unity - Edit Projecting - Input 中，可以在属性面板中查看所有的输入事件，每个事件都有自己相应的键位设置/鼠标按钮。Unity中文API教程：http://wiki.ceeger.com/script/unity_api关于人物镜头实现拟人化观察的￼方法：【以下以默认引擎坐标系为例讲解】基础能力：提供沿着Z轴方向移动的能力，即可模拟人物前进/后退的动作。提供沿着X轴方向移动的能力，即可模拟人物水平左移/右移的动作。提供绕Y轴旋转的能力【默认顺时针为正方向】，即可模拟人物水平转动头的动作。提供绕X轴旋转的能力【默认顺时针为正方向】，即可模拟人物抬头/低头的动作。附加能力：提供沿着Y轴方向移动的能力，即可模拟人物跳跃/蹲下、升起/坠落的动作。提供沿着绕Z轴旋转的能力，即可模拟人物脑袋在竖直面上被旋转的动作，比如被倒挂或者是躺下。非UI控件的坐标系：【3D Object、2D Object、Light、Camera】坐标系：3D立体坐标系，所见即所得。游戏运行时的画面，则由摄像头的视角提供。UI控件的坐标系：【这是设计面板上创建时使用的坐标系，使用代码时规则不同】Canvans坐标系：在创建对象后，会默认生成一个 Canvans 对象，所有的UI对象都添加到该Canvans中。Canvans本身在设计面板上看上去会很大，但是再运行时，整个Canvans会变成一个屏幕的大小，且出现在屏幕的最前端，并固定。Canvans坐标系规则：该坐标系本身是个2D坐标系。Canvans的大小为【1250，1098】，默认左下角位置在世界坐标系的原点。其内所有元素的布局， Position的原点在Canvans的中心点，x向右为正，y向上为正。超出Canvans范围的元素将不做展示。可以使用相对布局规则，即iOS中的autoresizingmask方式，可参见横竖屏适配经验Z轴作用不明，目前发现不会影响显示优先级以及投影的大小。Canvans投影到实际屏幕的映射关系：固定像素大小缩放固定物理大小UI控件学习：Text：当该空间内容的大小超过自身的大小时【主要是高度，长度可以自动换行】，内容将不再展示。注意事项：UI控件也可以添加刚体属性。当需要在脚本中操作UI对象时，需要添加头文件 using UnityEngine.UI .预制物体：制作方式：在设计面板生成一个物体，然后新建一个文件夹【一般命名为 Prefab，但其实名字可以随意】，然后将该物体拖放到该文件夹中，即可变成一个可被重复利用的预制物体。优点：物体可被重复利用，且可以随时为其添加脚本，修改属性，所有的该预制物体控件，以及复制的控件，都会产生修改效果。Layer:作用：一种物体分类方式。所有物体新建时默认处于Default层。效果：只有处于同一层的物体才会发生碰撞。坐标系调整技巧：顶点捕捉模式：【用于快捷拼接元素】先把场景视图切换到坐标系模式【十字架】选中一个物体，按住v，激活顶点捕捉模式使用鼠标左键选中该物体的一个顶点拖动网格到紧贴另一个物体的顶点对结果满意时，放开v和鼠标左键可以支持顶点到顶点，顶点到表面和顶点到轴心。格式化移动：当使用移动工具时，顺着某一个轴按住Command键可以按照增量的方式在移动。在菜单Edit-&gt;Snap Settings可以修改增量值Prefab预制任务：预制源和由其产生的实例对象之间存在继承关系实例对象可以覆盖预制源的一些属性，且这些属性以实例对象的修改为优先值。使用Apply可以使自己修改的变量应用到预制源，进而应用到所有的预制实例对象。选择Revert可以将自己的属性恢复到预制状态。实例对象与预制源属性不一致的地方，会采用黑体标粗展示。渲染方式：【http://www.ceeger.com/Manual/RenderingPaths.html】延迟光照【Pro，移动设备不支持】正向渲染：一个基于着色器的渲染路径。它支持逐像素计算光照（包括法线贴图和灯光Cookies）和来自一个平行光的实时阴影。在默认设置中，少数最亮的灯光在逐像素计算光照模式下渲染。其余的灯光计算对象顶点的光照。【http://www.ceeger.com/Components/RenderTech-ForwardRendering.html】顶点光照：是最低保真度的光照、不支持实时阴影的渲染路径。【http://www.ceeger.com/Components/RenderTech-VertexLit.html】Unity工具使用注意事项：资源管理方式：在你的项目视图里面重命名和移动文件的核心内容；什么都不会破坏。永远不要从Finder或其他程序重命名或移动任何东西，一切都会被破坏。总之，Unity为每个资源（如导入设置的东西、压缩纹理缓存版本等）存储了大量的元数据，如果你从外部移动一个文件，Unity将不可以再为移动的文件关联元数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[unity学习常见问题]]></title>
      <url>%2F2017%2F02%2F09%2Funity%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[unity学习常见问题Unity程序使用相关：【偶现，特定场景】当我们在unity面板上修改属性值，或者在mono中修改脚本后，在运行时发现并没有生效【有时甚至会出现修改的属性值在运行时复原的情况】，此时，我们需要保存项目/脚本，即可解决问题。每次推出前记得保存项目和脚本，因为unity和mono不会自动保存。当使用新账号下载数据时，会发生 401 认证失败，这是因为你没有同意下载协议。在一台能在Unity上打开Asset Store的设备，然后同意协议后，该账号即可在任意地方使用。为物体添加刚体组件之后，还可以为刚体组件指定物理物质，里面可以控制弹跳属性、特性等。正确理解父对象坐标系变化：Scale的变化：首先，Unity中物体的锚点都是设置在中心点。那么，当改变某一个方向的scale时，会以锚点为中心，均匀的向两边倍化增长【直接把端点坐标*倍化指数即可得到结果】。还有一个重要的问题就是，锚点两边的拆开来看，也都是分别倍增了这么多的倍数。即不存在倍数变小的情况。实现不均匀增长的方法：用一个空对象作为坐标系节点，并将自己设置为其的子对象在某个方向轴上的比例分配【0，1】之间，决定了了不均匀变化的比例。即Position的设置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MonoDeveloper使用学习]]></title>
      <url>%2F2017%2F02%2F09%2FMonoDeveloper%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[MonoDeveloper使用学习 程序执行路径：Mono Debug程序在执行是在/Users/chengjianfeng/Documents/Mono/TestCJF/TestCJF/bin/Debug Mono Release程序在执行是在/Users/chengjianfeng/Documents/Mono/TestCJF/TestCJF/bin/Release 下的。Mono允许执行unsafe代码的方法：操作步骤：选中项目本身右键 - options - build - general - Allow ‘unsafe’ codeunity代码支持unsafe代码的方法：http://blog.csdn.net/leeeyupeng/article/details/8480342代码补全功能：目前代码支持快速补全功能，可以忽略大小写匹配，且支持模糊匹配。在我们在预先定义的函数/类/枚举中，将鼠标放在名称上，短暂停留1s，即会出现关于该标识符的定义和英文描述。【奇怪的是，当我们jump到定义时，反而是看不到英文提示的】当我们停留在函数名上时，出来的描述符可能有多页，描述页面支持翻页查看描述功能，使用方向键翻页即可。重要点：虽然C#不要求文件名与类名一致，但是unity要求必须一致，才能作为附加脚本。我们可以在单个工程中使用这三种语言【C#、JS、Boo】的任意组合，但是一种脚本采用其他脚本中定义的类时可能存在一些限制。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python常见问题集合]]></title>
      <url>%2F2017%2F02%2F09%2FPython%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88%2F</url>
      <content type="text"><![CDATA[Python常见问题集合 try-catch捕获错误： 当使用try-expect 捕获错误时，最好是使用 expect Exception,e: print str(e)，这样可以知道错误的详细信息，有助于我们定位问题。 IndentationError:except an indented block: 这表示有一个格式不规范问题，一般都是 tab进位不齐，在提示行附近重新格式化一下缩进就可以了。 Python深拷贝与浅拷贝： 对于Python的容器类来说【字典、列表、元组、集合】等，直接赋值都是将自己的指针赋给对方，此时不产生任何copy操作。 当我们希望形成新的容器时，就必须实现copy操作，那么就需要使用 copy 库： 浅拷贝：shadowCopyList = copy.copy( sourceList ) copy完成后，生成的新的对象类型也是 list 类型。其内的元素与 sourceList 中的完全一致。即元素的指针都是一样的，完全是同一个对象。 深拷贝：deepCopyList = copy.deepCopy( sourceList ) 其内的元素也需要实现深度拷贝 字典中删除键值对的方法：del dic[“xxxx”] 即可删除该键值对构造函数个数问题：python中每一个类只能有一个__init__(xx)方法。Python调用栈查看技巧：当使用单线程时，使用Debug模式，然后用点击 暂停，可以查看当前的线程调用堆栈。但在使用多线程模式时，暂停无法提供准确的线程调用堆栈。但可以直接使用结束进程按钮，此时，python会将所有线程调用栈打印出来，此时可以查看。 Python对象相等判断：【不要使用字符串校验，使用list校验最方便】==比较操作符：用来比较两个对象是否相等，value做为判断因素；is同一性运算符：比较判断两个对象是否相同，id做为判断因素。示例代码：apply_async使用问题：函数原型：def apply_async(self, func, args=(), kwds={}, callback=None)对于上述函数，如果我们使用：runPool.apply_async(mutipleProcessMethod, args = (inputFile,))：那么这个函数是会被正常调用的runPool.apply_async(mutipleProcessMethod, args = inputFile )：那么这个函数的调用就会失败，直接被略过。且不会有任何警告出现。全局变量捕获问题：这个函数虽然是在另一个线程中执行，但是对于全局变量，还是可以正确的做捕获的。即global变量依然可以在函数内声明后使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python编程规范指南]]></title>
      <url>%2F2017%2F02%2F09%2FPython%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Python编程规范指南变量捕获问题：最外层的函数被视为全局函数，即mian里的代码。这里面声明的所有变量都可以被任意的函数使用【只要声明 global xxxx 即可】非最外层的函数中声明的变量，只有函数作用域，超出范围就不可见。【编程规范】：因为存在这样的全局可见变量，所以建议main中的变量名应该是独一无二的。不和任何子函数的变量重名。最好都能加上前缀。变量名前缀规范【CJF版本】：全局可见变量：gv_接受外部输入的全局可见变量：gi_不可变的全局常量：gc_全局函数中使用的普通变量：g_脚本变量初始化思维：只要在执行路径上，变量一定会被赋值一次。那就不需要初始化这个变量。建议使用 in 代替以下场景：判断一个元素是否在 list 中判断一个元素是否在 tuple 中【单个字符串元素时会出错，建议使用前者】判断一个元素是否是 dict 的keyin会依次调用被查询容器的 __contains__、__iter__、__getitem__，然后使用对象相等性判定【而不是指针相等性】，示例代码如下：元素的类型可以是：string\number，以及任意定义了相等性的对象。复杂实现尽早切换到局部函数中：当实现复杂功能时，当完成全局初始化后，应该立即将功能放到局部函数中去实现。如果全局代码过多的话，那么全局变量也一定很多，但其实有一部分变量不应该是全局可见的。它可能会对后续局部函数内的变量命名产生同名，从而在某一天导致不可预知的错误。复杂不等式建议写法：target_bg_limit &gt; bgTimeInterval &gt; 0 【等价于】 target_bg_limit &gt; bgTimeInterval and baTimeInterval &gt; 0xx is None 【等价于】 xx == None ; xx is not None 【等价于】 xx != None编译器警告：尽量按照Python的规范编写代码，接受PyCharm的检查。对于一些问题，编译器无法检测我们是否已经做了保护，此时可以选择对这条语句忽略该警告。有一些警告可以直接在编译器警告检查界面关闭检查。有一些警告直接忽略。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python2字符串编码指南]]></title>
      <url>%2F2017%2F02%2F09%2FPython2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Python2字符串编码指南文章笔记:基础概念：Python2有编码问题，而Python3没有编码问题。Python3不存在编码问题的原因：所有字符串对象本质上都是Unicode，而不再是str【字节数组】和Unicode并存。Unicode都是一种字符集，而UTF-8是一种编码格式。Python编解码：Python的encode：表示将Unicode字符串对象，转化为特定字符编码格式的字节数组【对象类型变为str】。Python的decode：表示将特定字符编码格式的字节数组【str对象】，转化为Unicode字符串对象。需要注意的是，str对象就是一个字节数组，它的字符编码格式，完全是由我们控制的，可以为任意值。【系统默认视为ASCII】重点！！：字符在内存中的表现形式，是由代表字符的对象决定的，与字符编码格式和字符集都没有必然关联。但由于str本身就是个字节数组，所以其内容与字符编码内容一致【巧合而已，由具体实现决定】。也由于unicode中的每个字符都是一个对象，而那个对象保存了这个字符的在Unicode字符集中的对应编码。关键点:程序文件存储编码格式：Python 默认脚本文件都是ANSCII编码的，当文件中有非ANSCII编码范围内的字符的时候就要使用"编码指示”来修正。作用：程序文件最开始的注释，表示这个文件的保存格式【对解析器而言】。那么，之后Python解析器会用这个格式去打开程序，然后获取里面的内容。在这个阶段，我们一般使用 utf-8 编码。那么，字符串”测试test”在实际硬盘上就会存储为”'\xe6\xb5\x8b\xe8\xaf\x95test’”，然后，python解释器载入程序代码时，从文档中读入了这个字符串的字节数组，并放到一个str对象中去。Python中的字符串类型：在python中有两种字符串类型，分别是str和unicode，他们都是basestring的派生类：str类型是一个包含Characters represent (at least) 8-bit bytes的序列。unicode的每个unit是一个unicode obj，所以：len(u'中国')的值是2，len('ab')的值也是2。str对象并没有编码格式，它只是简单的字节数组。unicode是一个对象数组，里面的每一个字符都是一个unicode对象。每个对象都直接使用Unicode字符集中的对应编码表示。【并不是实际编码值】程序字符串默认编码格式：作用：当字符串需要从str-&gt;unicode，或者从 unicode-&gt;str时，如果不显示指定参数，那么就会使用默认的转化方式完成转化。默认是 ascii改变方式是 import sys ; reload(sys) ; sys.setdefaultencoding(‘xxx’)一般需要改变为和程序文件存储编码格式一致。Python的字符编码基本规则：外部读取内容：在读取一个文件的内容，或者从网络上读取到内容时，保持的对象为str类型；如果想把一个str转换成特定编码类型，需要把str转为Unicode，然后从unicode转为特定的编码类型。字符串编码转化规则：所有字符串如果希望转化为另一种格式的编码，那么都需要先转化为Unicode字符串，在转化为其他编码的str字符串。str1.encode(‘utf-8’) =&gt; str1.decode(sys.getdefaultencoding()).encode(‘utf-8’)unicode1.encode(‘utf-8’) =&gt; unicode1.encode(‘utf-8’)字符串隐式转化的场景：当把str与unicode一起操作时，str隐式转化为unicode。 转化规则为 str1.decode(sys.getdefaultencoding()) ，如果此时系统默认编码与字符串的实际编码不一致，那么就会出现异常。打印相关内容：python中的print直接把字符串传递给操作系统，所以你需要把str解码成与操作系统一致的格式。【建议mac上转化为utf-8，windows转化为gbk】前提是文档格式和解释器默认编码都被正确设置。Mac上：print str1.encode(‘utf-8’)Windows上：print str1.encode(‘gbk')解决方案：文档中文可识别【必做】：在程序文件的开头出加上 【 # -*- coding: utf-8 -*- 】 。解释器默认编码正确设置【必做】：修改程序解释器默认编码，使其与文档的编码格式一致。代码示例如下: import sys reload(sys) # Python2.5 初始化后会删除sys.setdefaultencoding 这个方法，我们需要重新载入 sys.setdefaultencoding('utf-8’)规范编程的建议【极力推荐，使用此规范可以使程序达到与Python3一样的效果】：所有文本字符串都应该是unicode类型，而不是str类型。如果处理的是文本，而变量类型是str，这就是bug了！若要将字节串解码成字符串，需要使用正确的解码，即var.decode(encoding)（如，var.decode('utf-8')）。将文本字符串编码成字节，使用var.encode(encoding)。永远不要对unicode字符串使用str()，也不要在不指定编码的情况下就对字节串使用unicode()。当应用从外部读取数据时，应将其视为字节串，即str类型的，接着调用.decode()将其解释成文本。同样，在将文本发送到外部时，总是对文本调用.encode()。如果代码中使用字符串字面值来表示文本，总是应该含有’u’前缀。文章正文：正确处理文本，特别是正确处理Unicode。是个老生常谈的问题，有时甚至会难倒经验丰富的开发者。并不是因为这个问题很难，而是因为对软件中的文本，开发者没有正确理解一些关键概念及其表示方法。在StackOverflow上搜索关于UnicodeDecodeError相关的问题，可以看到很多人都有这样的误解。这些错误的概念可以追溯到Unicode出现之前。那时许多现今的开发者还没入职，也包括我自己。如果这些错误的概念没有散布开来，其实不是个问题。现在很多人都有这些错误概念，部分原因是因为有些非常流行的语言传播，甚至固化了这些错误概念，使得纠正起来反而变得很困难。 根据对Unicode的支持情况，编程语言可以划分为4类： 在Unicode出现或流行之前编写的语言。C和C++就属于这一类。这类语言对unicode的支持参差不齐。或没有内置到语言中，或很难正确的使用。因此开发者常常会用错。 对Unicode支持稍好一点。这些语言在Unicode广泛流行后才出现的，但语言中对unicode的操作方式是严重错误的。虽然这些语言诞生较晚，但依然含有第一类语言中的所有缺点。以我的经验，其中代表语言就是PHP。尽管还有其他语言也同样糟糕。 对Unicode支持基本正确，但有少数致命缺点的语言。这一类语言比较“现代”，且能理解Unicode，但依然无法让开发者正确的处理unicode，导致在这些语言中对unicode会出现一些严重不足。让我很沮丧的是，Python 2.x就属于这一类（下文会详细介绍）。 能正确处理Unicode的语言。这些语言完全支持Unicode，可以用Unicode方便快速的完成任务，且不易出错。Java和.NET平台就属于这一类语言。 那么，Unicode到底是什么，我们在Unicode上犯了哪些错误？Joel这篇The absolute minimum every software developer absolutely, positively must know about unicode绝对是每个软件开发者必须阅读的文章。为了为简洁起见，以及照顾那些天生耐心不够的朋友，我会在本文中对其进行总结。 字符和字节 基本事实是，若想正确的处理文本，就必须了解字符的抽象概念。不严谨的定义一下，字符表示的是文本中的单个符号。更重要的是，一个字符不是一个字节。我再强调一遍！一个字符不是一个字节！！！而且，一个字符有许多表示方法，不同的表示方法会使用不同的字节数。就像前面我说的那样，字符就是文本中最小的单元。 Unicode以大家都认可的方式定义了一系列的字符。可以将Unicode理解成一个字符数据库，每个字符都与唯一的数字关联，称为code point。这样，英文大写字母A的codepoint是U+0041。而欧元符号的codepoint是U+20A0，其他类似。一个文本字符串就是这样一系列的codepoint，表示字符串中每个字符元素。 当然，你迟早会需要储存和传输这些理论上的Unicode字符串。如果选择一种其他人可以理解的方式以字节方式进行表示，就可以以大家都理解的方式互相发送文本。这里就需要引入字符编码（encoding）。 字符编码是在理想的字符和实际的字节表示方法之间的映射。这种映射无需面面俱到，即在某种编码中也许无法表示一些特定的字符。同时也无须为每个字符使用相同的内存空间，譬如某些字符使用单字节编码，而其他字符需要多个字节。 由于同一个字符的字节表现形式不止一种。这意味着当遇到了一串字节，如果不知道使用的是什么编码，即使知道这些字节表示的是文本，也不知道是什么意思。所能做的就是猜使用的编码。简而言之，字节不是文本。即使忘了文中介绍的所有内容，也要记住这句话。为了读写文本，归根结底就是要知道其中使用的编码方式，不管是从约定、标识信息、或是其他方法得知。 Python是如何处理Unicode 从这里开始介绍Python的Unicode支持。在Python的类型层次中，有3种不同的字符串类型：“unicode”，表示Unicode字符串（文本字符串）、“str”，表示字节字符串（二进制数据）；“basestring”。表示前两种字符串类型的父类。在我看来，Python在这里犯了一个错误，根据前面的定义，这让Python成为第三类语言，而没有成为第四类。 我用了很长的篇幅苦口婆心的强调字节和字符在本质上是不同的东西，只有通过字符编码才能互相转换。但不幸的是，Python犯了两个互不相关的错误，轻轻松松的就会让你忘掉这些。 第一个错误的严重性值得商榷：即将一串字节视为字符串。是否应该这样做还有争议。Java和,NET认为这样做是不对的，而其他一些语言却持有相反的态度。无论如何，你可能希望对文本进行某些操作，如正则匹配、字符串替代等。将这些操作应用到字节序列上都是没有意义的。而Python将字节序列作为另一种类型的字符串对待，允许在这两者上执行同样的操作。 第二个错误的严重性大一些，Python试图在字节串和字符串之间以不为人所察觉的方式进行转化。在不同的转换中，在条件允许的情况下，Python会试图在字节串和unicode字符串直接进行转换。例如将字节串和unicode字节串连接到一起时。根据前面的介绍，不使用encoding就在不同类型之间进行转换是没有意义的。所以Python依赖一个“默认编码”，该编码由sys.setdefaultencoding()指定。在大多数平台上，默认的是ASCII编码。但对于所有转换，使用这种编码几乎都是错误的。如果不手动指定编码就调用str()或unicode()，或是函数以字符串作为参数，但传递的是其他类型的参数时，都会使用这个默认编码。 走出这个unicode困境的一个解决办法是，调用sys.setdefaultencoding()将默认的编码设置为真正会用到的编码。但这样仅仅是将问题隐藏起来，虽然这样刚开始能解决一些文本处理问题。但缺乏实际可行性，因为许多应用，特别是网络应用，在不同的地方会使用不同的文本编码。 正确的解决方法是修改代码，以正确的方式处理文本。下面是一些应该做到的指导性意见： 所有文本字符串都应该是unicode类型，而不是str类型。如果处理的是文本，而变量类型是str，这就是bug了！ 若要将字节串解码成字符串，需要使用正确的解码，即var.decode(encoding)（如，var.decode('utf-8')）。将文本字符串编码成字节，使用var.encode(encoding)。 永远不要对unicode字符串使用str()，也不要在不指定编码的情况下就对字节串使用unicode()。 当应用从外部读取数据时，应将其视为字节串，即str类型的，接着调用.decode()将其解释成文本。同样，在将文本发送到外部时，总是对文本调用.encode()。 如果代码中使用字符串字面值来表示文本，总是应该含有’u’前缀。但实际上，永远不要在代码中定义原始的字符串字面值。不管怎样，我自己是很讨厌这一条，也许其他人也和我一样吧。 顺便说一句，Python 3修复了这些问题，可以正确的处理unicode和字符串，这样Python就完全位于第四类中了，更多信息参见官方的更新说明中关于Unicode的部分。 希望这些内容能帮到你，如果对unicode到底是什么，如何处理unicode有疑惑的话，现在应该都清楚了。下次遇到UnicodeEncodeError或UnicodeDecodeError错误时，就应该完全知道问题出在哪，也知道如何去修复这些问题！ 打赏支持我翻译更多好文章，谢谢！  打赏译者  1 赞  收藏  评论 关于作者：Daetalus Pyston核心开源开发者。熟悉CPython实现，关注Python科学计算。  个人主页 ·  我的文章 ·  28 ·  ]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多版本python管理工具：pyenv的使用]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%A4%9A%E7%89%88%E6%9C%ACpython%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9Apyenv%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[多版本python管理工具：pyenv的使用简介：由于python2和python3有较大的语法差异，无法向下兼容。因此。需要不同的解释器支持。mac有自带的python解释器，但是是2.x版本的。因为许多系统组件是基于这个解释器运行的，因此，我们不能直接把系统的python升级。因此，诞生了pyenv这样的python环境切换工具，这个工具有以下特点：不影响/usr/local/bin中的python版本，系统组件依然调用系统自带的python版本。通过配置shell配置，以及自己管理python库的方式，将下载的新python版本单独管理，包括第三方库也是单独管理的。参考文章：pyenv安装与配置指南：http://my.oschina.net/aetern/blog/399071?p=%7B%7Bpage%7D%7Dpyenv安装问题汇总：http://www.codeweblog.com/%E8%AE%B0%E5%BD%95mac%E4%B8%8B%E5%AE%89%E8%A3%85pyenv%E6%97%B6%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/修改shell配置指南：http://blog.sina.com.cn/s/blog_439f80c40101g9il.htmlpyenv使用指南：https://seisman.info/python-pyenv.html使用brew安装的软件，可以在/usr/local/bin下找到它的软链接，然后使用查看原件即可找到本体所在。一般是在 /usr/local/Crllar/xxxxx.附加的python安装目录是在pyenv安装目录的的version文件夹下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python常用库]]></title>
      <url>%2F2017%2F02%2F09%2FPython%E5%B8%B8%E7%94%A8%E5%BA%93%2F</url>
      <content type="text"><![CDATA[Python常用库 python库更新问题： 库过旧可能导致的问题：即当使用多个库时，他们之前一般有最低版本要求。如果其中一个版本过低，会导致无法协作开发。 解决方案：（需要注意的是，一旦涉及到文件读写，那么都需要 sudo 权限） 安装pip ：sudo easy_install pip 使用pip更新 python库：http://www.cnblogs.com/luckjun/p/4958338.html 。 excel处理相关内容: excel格式问题：主要分为 xls 和 xlsx xls可以被所有的excel程序打开，而xlsx则只能被office 07以上的excel程序打开。 07版以后的扩展名都是.xlsx ，是用新的基于XML的压缩文件格式取代了其目前专有的默认文件格式，在传统的文件名扩展名后面添加了字母x（即.docx取代.doc、.xlsx取代.xls，等等），使其占用空间更小。 Excel Python 主要有三个库：（前两者不能混用） xlwt是 xls 格式的写入库 xlsxWriter 是 xlsx的写入库 xlrd是excel读入库，可以兼容 xls 和 xlsx（对后者的支持力度有限）。 具体比较可以参考：http://www.gocalf.com/blog/python-read-write-excel.html 读入的表的行数序号是从0开始算起的，而不是按照文件打开显示的列号。 因此，建议使用 xlrd来读取文件内容，使用 xlsxWriter 来创建文件内容。 xlsxWriter的使用方式：https://www.linuxyw.com/464.html JSON数据读取问题： 因为字典key不存在会引发crash问题，数组越界也会引发crash问题，因此建议使用try-catch 捕获异常，来直接获取数据，避免复杂的取值判断操作。 目前建议使用JSON 库作为官方解析工具。 文件操作： API集合：http://www.cnblogs.com/rollenholt/archive/2012/04/23/2466179.html os.removedirs( “xxxx/xxx” ):删除一个空的叶子目录，并向上回溯，如果上级目录也是空的，那么也将其删除，依次类推，直到权限不够或者目录非空为止。 os.makedirs( “xxx/xxx” )：一次性创建多级目录 软链接和硬链接： 软链接实际上是一个文件跳转路径，它本质就是一个文本文件，记录了实际指向文件的地址。但它不影响实际文件的引用计数。 硬链接相比于软链接更为高级，它将增加指向文件的引用计数。只有所有硬链接和源文件都被删除的情况下，那份文件数据才会从硬盘上被删除，否则是不会的。 软链接：os.symlink( src , dst ) 硬链接：os.link( src , dst ),只在unix和windows下有效，对于mac来说，其执行的是简单的copy操作，无法达到指向同一份硬盘数据块的目的。 在填写链接地址时，一定要注意，你写入的src地址，是相对于你dst文件所在的位置的src地址。例如：我们可以看到， -&gt; 指定的地址系统是直接写入了我们传入的src地址，因此，我们src的值一定要是相对于dst所在的位置，src的相对路径。 在Mac的文件操作中，不要出现类似于它不允许出现的字符，这些字符也许通过代码可以生成相应的文件夹，但是在搜索和链接时，都会出现问题。（最近碰到软链接时出错的问题。） Mac在 file.open( “xxx” ) 时，如果xxx是一个软链接文件，那么也是可以正常打开的。最后会打开这个软链接指向的实际文件，并操作相关内容。 多线程与多进程： 多线程使用 threading 库，但是python的多线程是伪多线程，因为其在语言解释器层级还有一个GIL，这个锁会导致语言解释器会串行的解释脚本。 多进程使用 mutilprocess 库，这个库提供了两种并行方式： 进程对象管理方式： process 进程池方式：pool。因为mac电脑可以超线程运行，因此，一旦开启就会导致出错，要手动设置 Pool的大小比较好。 在使用这个库时，可以使用 Manager 来管理共享数据，manager 生成的数据，是共享内存的。对于，全局变量，都是复制捕获类型。 邮件处理代码： 当使用网易邮箱时，我们需要在邮箱设置中打开 stmp设置，打开授权码。在发送邮件时，邮箱密码需要写为授权码，而不是真实的邮箱密码。 使用网易邮箱，当你一个邮件发送给多个收件人时，会被返回错误，错误信息（554，”DT:SPM “）,表示被网易判定为垃圾邮件拒绝发送。因为比较稳妥的办法是，一次一个收件人。 示例代码如下： # 邮件相关头文件import smtplibfrom email.mime.text import MIMEText# 邮箱全局变量配置区域global_mail_host = "smtp.163.com" # 使用的邮箱的smtp服务器地址，这里是163的smtp地址global_mail_user = "673302055" # 用户名global_mail_pass = "280153CJFok" # 密码,网易规定必须使用授权码global_mail_postfix = "163.com" # 邮箱的后缀，网易就是163.comglobal_mail_user_name = "程剑锋"def send_mail(to_list, sub, content): global global_mail_host global global_mail_user global global_mail_pass global global_mail_postfix global global_mail_user_name # 常规项配置内容 mail_host = global_mail_host mail_user = global_mail_user mail_pass = global_mail_pass mail_postfix = global_mail_postfix mail_user_name = global_mail_user_name # 邮件发送代码 # if isinstance(content,unicode): # content = str(content) me = mail_user_name + "&lt;" + mail_user + "@" + mail_postfix + "&gt;" msg = MIMEText(content, _subtype = 'plain',_charset = 'utf-8') if not isinstance(sub,unicode): sub = unicode(sub) msg['Subject'] = sub msg['From'] = me msg['To'] = ";".join(to_list) # 将收件人列表以‘；’分隔 msg["Accept-Language"]="zh-CN" msg["Accept-Charset"]="ISO-8859-1,utf-8" try: server = smtplib.SMTP() server.connect(mail_host) # 连接服务器 server.login(mail_user, mail_pass) # 登录操作 server.sendmail(me, to_list, msg.as_string()) server.close() return True except Exception, e: print "邮件发送失败：%s" % (str(e)) return False 时间处理库： date和time的结合库：datetime，http://www.cnblogs.com/shijingjing07/p/5753175.html 科学计算库： 可支持多维度计算，参考文章：http://www.tuicool.com/articles/RBzyUvHTTP/HTTPS网络库相关：推荐使用requests，语法简单，自动处理重定向。但目前不支持http2.0。github:http://docs.python-requests.org/en/master/user/quickstart/#make-a-request直接使用系统提供的 urllib 也不错。httplib2由Google开发，但是不支持自动重定向，且语法不如requests易用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python 异常处理指南]]></title>
      <url>%2F2017%2F02%2F09%2FPython%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Python 异常处理指南文章笔记：异常处理语句的格式：标准范式：try -[except][0,N] - [else][0,1]&nbsp;&nbsp;- [finally][0,1]except中可以指定Exception类型，捕获到具体类型的错误时，就会进入该语句块。except语句按顺序匹配，一旦匹配到一个后，后续不再匹配。当try中没有抛出异常，那么else语句块执行。无论如何，finally语句块都会被执行。格式示例：try - excepttry - finallytry - except - finallytry - except - excepttry - except - except - finallytry - except - except - else&nbsp;&nbsp;- finallyexcept匹配语句的写法：通配：except：可以通过logging或者sys模块获取当前异常。【详情见下方代码】具体类型匹配：except&nbsp;&nbsp;ZeroDivisionError：可以通过logging或者sys模块获取当前异常。【详情见下方代码】具体类型匹配与错误对象获取：except&nbsp;&nbsp;ZeroDivisionError as e：多个具体变量匹配与错误对象获取：except (ZeroDivisionError,TypeError) as e:编程建议：如果要捕获异常后要重复抛出，请使用raise，后面不要带任何参数或信息。否则会丢失原异常的调用栈信息。不建议捕获并抛出同一个异常，请考虑重构你的代码。尽量使用内置的异常处理语句来 替换try/except语句，比如with语句，getattr()方法只处理你知道的异常，避免捕获所有异常然后吞掉它们，否则可能会隐藏严重的问题。抛出的异常应该说明原因，有时候你知道异常类型也猜不出所以然的。不要使用异常来控制流程，那样你的程序会无比难懂和难维护。如果有需要，切记使用finally来释放资源，以及做清理工作或者回滚操作。关于BaseExeption和Exception的区别：BaseExeption中的前三者崩溃属于高级异常，应该交由Python解释器去捕获。因此不应该在except中捕获BaseExeption异常。抛出异常：【直接抛出已捕获异常】在except代码中，使用raise可以抛出已捕获的异常。可以对异常变量进行修改后，再抛出使用dir(Exception)可以看到所有的异常类型，在http://www.ianbicking.org/blog/2007/09/re-raising-exceptions.html官方文档里更加详细的介绍。使用内置语句代替try-except：with：作为 try/finally 编码范式的一种替代，用于对资源访问进行控制的场合。参考文章：http://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/语法示例:- with context_expression [as target(s)]:- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with-body代码示例：- with open(r'somefileName') as somefile:- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for line in somefile:- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print line- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ...more codegetattr(object,”attrName”,defaultValue)：用于从对象身上获取属性。文章正文：异常处理在任何一门编程语言里都是值得关注的一个话题，良好的异常处理可以让你的程序更加健壮，清晰的错误信息更能帮助你快速修复问题。在Python中，和部分高级语言一样，使用了try/except/finally语句块来处理异常，如果你有其他编程语言的经验，实践起来并不难。异常处理语句 try…excpet…finally实例代码def div(a, b):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(a / b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except ZeroDivisionError:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Error: b should not be 0 !!")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except Exception as e:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Unexpected Error: {}".format(e))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Run into else only when everything goes well')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Always run into finally block.')&nbsp;&nbsp;# testsdiv(2, 0)div(2, 'bad type')div(1, 2)&nbsp;&nbsp;# Mutiple exception in one linetry:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(a / b)except (ZeroDivisionError, TypeError) as e:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(e)&nbsp;&nbsp;# Except block is optional when there is finallytry:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;open(database)finally:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(database)&nbsp;&nbsp;# catch all errors and log ittry:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_work()except:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# get detail from logging module&nbsp;&nbsp;&nbsp;&nbsp; #可以打印错误信息，以及错误调用栈信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logging.exception('Exception caught!')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# get detail from sys.exc_info() method&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_type, error_value&nbsp;&nbsp;= sys.exc_info()[:2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(error_value)&nbsp;&nbsp;&nbsp;&nbsp; # 打印出当前的调用栈 &nbsp;&nbsp;&nbsp;&nbsp;trackback.print_exc() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise总结如下except语句不是必须的，finally语句也不是必须的，但是二者必须要有一个，否则就没有try的意义了。except语句可以有多个，Python会按except语句的顺序依次匹配你指定的异常，如果异常已经处理就不会再进入后面的except语句。except语句可以以元组形式同时指定多个异常，参见实例代码。except语句后面如果不指定异常类型，则默认捕获所有异常，你可以通过logging或者sys模块获取当前异常。如果要捕获异常后要重复抛出，请使用raise，后面不要带任何参数或信息。不建议捕获并抛出同一个异常，请考虑重构你的代码。不建议在不清楚逻辑的情况下捕获所有异常，有可能你隐藏了很严重的问题。尽量使用内置的异常处理语句来 替换try/except语句，比如with语句，getattr()方法。抛出异常 raise如果你需要自主抛出异常一个异常，可以使用raise关键字，等同于C#和Java中的throw语句，其语法规则如下。raise NameError("bad name!")raise关键字后面需要指定你抛出的异常类型，一般来说抛出的异常越详细越好，Python在exceptions模块内建了很多的异常类型，通过使用dir()函数来查看exceptions中的异常类型，如下：import exceptions&nbsp;&nbsp;# ['ArithmeticError', 'AssertionError'.....]print dir(exceptions)当然你也可以查阅Python的文档库进行更详细的了解。https://docs.python.org/2.7/library/exceptions.html#bltin-exceptions自定义异常类型Python中也可以自定义自己的特殊类型的异常，只需要要从Exception类继承(直接或间接)即可：class SomeCustomException(Exception):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass一般你在自定义异常类型时，需要考虑的问题应该是这个异常所应用的场景。如果内置异常已经包括了你需要的异常，建议考虑使用内置 的异常类型。比如你希望在函数参数错误时抛出一个异常，你可能并不需要定义一个InvalidArgumentError，使用内置的ValueError即可。经验案例传递异常 re-raise Exception捕捉到了异常，但是又想重新引发它（传递异常），使用不带参数的raise语句即可：def f1():&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(1/0)&nbsp;&nbsp;def f2():&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f1()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except Exception as e:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;&nbsp;&nbsp;&nbsp;# don't raise e !!!&nbsp;&nbsp;f2()在Python2中，为了保持异常的完整信息，那么你捕获后再次抛出时千万不能在raise后面加上异常对象，否则你的trace信息就会从此处截断。以上是最简单的重新抛出异常的做法。还有一些技巧可以考虑，比如抛出异常前对异常的信息进行更新。def f2():&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f1()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except Exception as e:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.args += ('more info',)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise如果你有兴趣了解更多，建议阅读这篇博客。http://www.ianbicking.org/blog/2007/09/re-raising-exceptions.htmlPython3对重复传递异常有所改进，你可以自己尝试一下，不过建议还是同上。Exception 和 BaseException当我们要捕获一个通用异常时，应该用Exception还是BaseException？我建议你还是看一下 官方文档说明，这两个异常到底有啥区别呢？ 请看它们之间的继承关系。BaseException+-- SystemExit+-- KeyboardInterrupt+-- GeneratorExit+-- Exception&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-- StopIteration...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-- StandardError...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-- Warning...从Exception的层级结构来看，BaseException是最基础的异常类，Exception继承了它。BaseException除了包含所有的Exception外还包含了SystemExit，KeyboardInterrupt和GeneratorExit三个异常。有此看来你的程序在捕获所有异常时更应该使用Exception而不是BaseException，因为另外三个异常属于更高级别的异常，合理的做法应该是交给Python的解释器处理。except Exception as e和 except Exception, e代码示例如下：try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_something()except NameError as e:&nbsp;&nbsp;&nbsp;&nbsp;# should&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;passexcept KeyError, e:&nbsp;&nbsp;&nbsp;&nbsp;# should not&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass在Python2的时代，你可以使用以上两种写法中的任意一种。在Python3中你只能使用第一种写法，第二种写法被废弃掉了。第一个种写法可读性更好，而且为了程序的兼容性和后期移植的成本，请你也抛弃第二种写法。raise “Exception string”把字符串当成异常抛出看上去是一个非常简洁的办法，但其实是一个非常不好的习惯。if is_work_done():&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;passelse:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise "Work is not done!" # not cool上面的语句如果抛出异常，那么会是这样的：Traceback (most recent call last):&nbsp;&nbsp;&nbsp;&nbsp;File "/demo/exception_hanlding.py", line 48, in &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise "Work is not done!"TypeError: exceptions must be old-style classes or derived from BaseException, not str这在Python2.4以前是可以接受的做法，但是没有指定异常类型有可能会让下游没办法正确捕获并处理这个异常，从而导致你的程序挂掉。简单说，这种写法是是封建时代的陋习，应该扔了。使用内置的语法范式代替try/exceptPython 本身提供了很多的语法范式简化了异常的处理，比如for语句就处理的StopIteration异常，让你很流畅地写出一个循环。with语句在打开文件后会自动调用finally中的关闭文件操作。我们在写Python代码时应该尽量避免在遇到这种情况时还使用try/except/finally的思维来处理。# should nottry:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = open(a_file)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_something(f)finally:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.close()&nbsp;&nbsp;# shouldwith open(a_file) as f:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_something(f)再比如，当我们需要访问一个不确定的属性时，有可能你会写出这样的代码：try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test = Test()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = test.name&nbsp;&nbsp;&nbsp;&nbsp;# not sure if we can get its nameexcept AttributeError:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = 'default'其实你可以使用更简单的getattr()来达到你的目的。name = getattr(test, 'name', 'default')最佳实践最佳实践不限于编程语言，只是一些规则和填坑后的收获。只处理你知道的异常，避免捕获所有 异常然后吞掉它们。抛出的异常应该说明原因，有时候你知道异常类型也猜不出所以然的。避免在catch语句块中干一些没意义的事情。不要使用异常来控制流程，那样你的程序会无比难懂和难维护。如果有需要，切记使用finally来释放资源。如果有需要，请不要忘记在处理异常后做清理工作或者回滚操作。觉得本文对你有帮助？请分享给更多人关注「Python开发者」看更多技术干货640.webp]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python shell命令执行笔记]]></title>
      <url>%2F2017%2F02%2F09%2FPython%20shell%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Python shell命令执行笔记文章笔记：执行shell命令的不同方式：名词统一：命令的执行返回值：int值，是命令返回的值。即sys.exit(x)的值。命令的输出信息：str值，是命令执行过程中向标准输出打印的信息。os.exec方法族：【不推荐】与UNIX exec使用方法相同，不推荐使用。os.system：【不推荐】示例：os.system(“ls -l”)返回值：阻塞调用，返回命令的执行的返回值【int对象】，无法在程序中获得输出信息。命令执行过程中的输出信息：直接输出到标准输出，无法返回给调用程序使用。os.popen：【不推荐】示例：fileObj = os.popen(“ls -l”)返回值：阻塞调用，返回命令的输出信息【file对象】。使用 outStr = fileObj.read()可以获取输出信息，需要注意，使用完成后，需要调用fileObj.close()关闭文件句柄。commands：【可以使用】示例：commands.getstatusoutput(cmd)：返回一个元组(status【int】, output【str】)commands.getoutput(cmd)：只返回输出结果【str】阻塞调用，可以直接返回执行结果和输出结果。subprocess：【推荐使用】关于cmd的参数格式：shell命令模式：如果指明 shell = True，则直接按照shell命令的方式输入字符串即可。比如subprocess.call( “ls -l”, shell - True )参数列表模式：如果未指明 shell =True或者在windows下，默认使用args模式。比如 subprocess.call([“ls”,”-l”])阻塞式调用：subprocess.call( cmd, shell = True )：返回执行结果。输出信息直接在执行过程中向标准输出打印。subprocess.check_call( cmd, shell = True ):返回0，检查执行结果，如果不为0，则直接抛出subprocess.CalledProcessError，该对象包含有returncode属性，可用try…except…来检查。输出信息直接在执行过程中向标准输出打印。subprocess.check_output( cmd, shell = True ):返回子进程向标准输出的输出结果【执行过程中输出信息不再打印】，检查执行结果，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性和output属性，output属性为标准输出的输出结果，可用try…except…来检查。非阻塞式调用：上述的阻塞式调用，其实就是对subprocess.Popen的封装。subprocess.Popen(cmd, shell = True,stdin = xx, stderr = xx, stdout = xx):cmd：shell命令字符串shell：是否以shell命令的格式输入命令stdin：输入来源【可以是另一个Popen的输出】【不设置则为标准输入，直接从控制台读取】stderr：错误输出【不设置则为标准错误输出，直接打印到控制台】stdout：输出信息【不设置则为标准输出，直接打印到控制台】返回值：一个subprocess.Popen对象ret流程控制函数：ret.wait()：等待子进程执行结束ret.poll()：检查子进程是否结束，如果结束将设置并返回执行结果。否则返回None。ret.kill() : 终止子进程ret.send_signal( sig ) : 向子进程发送信号ret.terminate() : 终止子进程ret.communicate( input = None )：使用input传入一个str，作为标准输入信息，然后等到子进程执行结束，程序会返回一个元组（stdout,stderr）。但要注意，如果我们之前在Popen初始化时没有设置，则输出信息直接到控制台中，且返回值的元组数据为（none,none）关键属性：ret.stdin：子进程的标准输入ret.stdout：子进程的标准输出ret.stderr：子进程的错误输出注意，上述三个属性，如果是我们自己打开的文件句柄，那么需要我们自己自己管理，记得close。如果不赋值【使用系统标准输入输出】或者使用subprocess.PIPE,则不需要我们管理。returnCode：执行结果pid：子进程ID文章正文：从Python 2.4开始，Python引入subprocess模块来管理子进程，以取代一些旧模块的方法：如 os.system、os.spawn*、os.popen*、popen2.*、commands.*不但可以调用外部的命令作为子进程，而且可以连接到子进程的input/output/error管道，获取相关的返回信息一、subprocess以及常用的封装函数运行python的时候，我们都是在创建并运行一个进程。像Linux进程那样，一个进程可以fork一个子进程，并让这个子进程exec另外一个程序。在Python中，我们通过标准库中的subprocess包来fork一个子进程，并运行一个外部的程序。subprocess包中定义有数个创建子进程的函数，这些函数分别以不同的方式创建子进程，所以我们可以根据需要来从中选取一个使用。另外subprocess还提供了一些管理标准流(standard stream)和管道(pipe)的工具，从而在进程间使用文本通信。 subprocess.call()父进程等待子进程完成返回退出信息(returncode，相当于Linux exit code) subprocess.check_call()父进程等待子进程完成返回0检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性，可用try…except…来检查 subprocess.check_output()父进程等待子进程完成返回子进程向标准输出的输出结果检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性和output属性，output属性为标准输出的输出结果，可用try…except…来检查。 这三个函数的使用方法相类似，下面来以subprocess.call()举例说明:复制代码 代码如下:&gt;&gt;&gt; import subprocess&gt;&gt;&gt; retcode = subprocess.call(["ls", "-l"])#和shell中命令ls -a显示结果一样&gt;&gt;&gt; print retcode0将程序名(ls)和所带的参数(-l)一起放在一个表中传递给subprocess.call() shell默认为False，在Linux下，shell=False时, Popen调用os.execvp()执行args指定的程序；shell=True时，如果args是字符串，Popen直接调用系统的Shell来执行args指定的程序，如果args是一个序列，则args的第一项是定义程序命令字符串，其它项是调用系统Shell时的附加参数。 上面例子也可以写成如下：复制代码 代码如下:&gt;&gt;&gt; retcode = subprocess.call("ls -l",shell=True)在Windows下，不论shell的值如何，Popen调用CreateProcess()执行args指定的外部程序。如果args是一个序列，则先用list2cmdline()转化为字符串，但需要注意的是，并不是MS Windows下所有的程序都可以用list2cmdline来转化为命令行字符串。 subprocess.Popen()复制代码 代码如下:class Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0)实际上，上面的几个函数都是基于Popen()的封装(wrapper)。这些封装的目的在于让我们容易使用子进程。当我们想要更个性化我们的需求的时候，就要转向Popen类，该类生成的对象用来代表子进程。 与上面的封装不同，Popen对象创建后，主程序不会自动等待子进程完成。我们必须调用对象的wait()方法，父进程才会等待 (也就是阻塞block)，举例：复制代码 代码如下:&gt;&gt;&gt; import subprocess&gt;&gt;&gt; child = subprocess.Popen(['ping','-c','4','blog.linuxeye.com'])&gt;&gt;&gt; print 'parent process'从运行结果中看到，父进程在开启子进程之后并没有等待child的完成，而是直接运行print。 对比等待的情况:复制代码 代码如下:&gt;&gt;&gt; import subprocess&gt;&gt;&gt; child = subprocess.Popen('ping -c4 blog.linuxeye.com',shell=True)&gt;&gt;&gt; child.wait()&gt;&gt;&gt; print 'parent process'从运行结果中看到，父进程在开启子进程之后并等待child的完成后，再运行print。此外，你还可以在父进程中对子进程进行其它操作，比如我们上面例子中的child对象:复制代码 代码如下:child.poll() # 检查子进程状态child.kill() # 终止子进程child.send_signal() # 向子进程发送信号child.terminate() # 终止子进程子进程的PID存储在child.pid二、子进程的文本流控制子进程的标准输入、标准输出和标准错误如下属性分别表示:复制代码 代码如下:child.stdinchild.stdoutchild.stderr可以在Popen()建立子进程的时候改变标准输入、标准输出和标准错误，并可以利用subprocess.PIPE将多个子进程的输入和输出连接在一起，构成管道(pipe)，如下2个例子：复制代码 代码如下:&gt;&gt;&gt; import subprocess&gt;&gt;&gt; child1 = subprocess.Popen(["ls","-l"], stdout=subprocess.PIPE)&gt;&gt;&gt; print child1.stdout.read(),#或者child1.communicate()&gt;&gt;&gt; import subprocess&gt;&gt;&gt; child1 = subprocess.Popen(["cat","/etc/passwd"], stdout=subprocess.PIPE)&gt;&gt;&gt; child2 = subprocess.Popen(["grep","0:0"],stdin=child1.stdout, stdout=subprocess.PIPE)&gt;&gt;&gt; out = child2.communicate()subprocess.PIPE实际上为文本流提供一个缓存区。child1的stdout将文本输出到缓存区，随后child2的stdin从该PIPE中将文本读取走。child2的输出文本也被存放在PIPE中，直到communicate()方法从PIPE中读取出PIPE中的文本。注意：communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成 代码实践：import commandsimport osimport subprocessprint "=========os.system"ret = os.system("ls -l")print type(ret) #intprint retprint "=========os.popen"ret = os.popen("ls -l")print type(ret) #fileprint ret.read()ret.close()print "=========commands"ret = commands.getstatusoutput("ls -l")print type(ret) #tupleprint retprint type(ret[0]) #intprint ret[0]print type(ret[1]) #strprint ret[1]print "=========subprocess.call"ret = subprocess.call("ls -l",shell = True)print type(ret) #intprint retprint "=========subprocess.check_call"ret = subprocess.check_call("ls -l",shell = True)print type(ret) #int,0print retprint "=========subprocess.check_output"ret = subprocess.check_output("ls -l",shell = True)print type(ret) #strprint retprint "=========subprocess.Popen" # 管道用法child1 = subprocess.Popen(["cat","/etc/passwd"], stdout=subprocess.PIPE)child2 = subprocess.Popen(["grep","0:0"],stdin=child1.stdout, stdout=subprocess.PIPE)child2.wait() #child2.communicate()也可以print child2.stdout.read()print "=========subprocess.poll" #轮询用法# ret = subprocess.Popen("sleep 3| ls -l",shell = True)# aa = ret.poll()# print aa# while aa != 0:# print aa# aa = ret.poll()# else:# print aa# print type(ret) #subprocess.Popenprint "=========subprocess.communicate"ret = subprocess.Popen("ls -l",shell = True)test = ret.communicate()print type(test)print test]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyCharm使用指南]]></title>
      <url>%2F2017%2F02%2F09%2FPyCharm%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[PyCharm使用指南使用指南：对于正常的开发来说，PyCharm Community Editor已经完全够用了。对于IDE优化设置，可以参考：基本参数优化：http://blog.csdn.net/pipisorry/article/details/39909057&nbsp;&nbsp;快捷键优化：http://www.jeepshoe.org/285014912.htm。注意如果发生键位冲突，可以考虑强制添加，IDE会弹出提示框警告是否移除其他相关的快捷键设置。设置移植方法：使用 Export Setting可以将设置导出使用，然后使用Import Setting导入设置复用。但存在以下两点小问题：win和Mac上快捷键偏好不一致。当然，建议尽量保持统一。win和Mac、甚至不同电脑上，Project Interpreter的位置各不相同，这个一定要check一遍！常用快捷键：选中整块代码，按住 tab键可以向右缩进。按住 shift + tab 键可以向左缩进。授权服务器：http://jetbrains.tencent.click/&nbsp;&nbsp;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习指南]]></title>
      <url>%2F2017%2F02%2F09%2FPython%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Python学习指南 教程总纲：http://www.runoob.com/python/python-tutorial.html 进阶教程：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 基本概念：（按照Python3标准来开发） 按照缩进来区分代码块 python默认不支持中文，采用 ASCII 编码，如果需要使用中文（特别要小心中文的标点等，也会引起运行时错误），那么可以参考文章：http://www.jb51.net/article/26298.htm python是顺序执行的脚本，它不在乎变量的声明位置，只要在使用这个变量之前，之前的代码执行过这个变量的初始化，那么这个变量的使用就是合法的。 局部变量：以函数调用为分界线，函数内声明的变量是不能在函数外使用的 。 全局变量：在函数外声明的全局变量，是可以在任意地方被访问到的。但是在函数内会默认创建一个同名的局部变量，我们可以使用 global 变量名 表示这个变量来自于全局变量，请不要创建局部变量而直接使用即可。 在定义模块时，所有的文件都不应该有全局变量和全局执行代码（即不在 def 和 class 中的代码），如果有，那么这些代码被import后将会被执行运行。 PYTHONPATH 用于指定 python库的搜索路径，在 pyCharm中会在开始前自动执行一段脚本，将当前的工程目录加入到搜索列表中去。 多版本python管理软件： 多版本python管理工具：pyenv的使用 可以在交互式命令行中使用 help( 查询的类名或者函数名 ) 来获得帮助信息 python内置函数：https://docs.python.org/3/library/functions.html python本身是不支持函数重载的。在同一个类中或者是全局函数中，都不允许出现同名函数。（参数类型本身就无法区分，因为是动态语言。参数个数没有参考价值，所以其完全不支持多态） 打包教程： python的import语句会将文件加载到当前文件中，在该文件首次加载时，会执行文件内部的顶层代码。 import语句默认是调用 __import__( "xxxx" )来加载模块，该函数返回一个集合名，之后需要以这个集合名为对象名，访问模块内的各种属性。 导入模块（包和模块是一样的）的两种形式： import &lt;模块名&gt;：将会包含所有的xxx模块内的元素，在使用时，有命名空间限制，需要加上模块名 xxx 才能调用模块内的内容。（在最终文件使用时，推荐这种方式，避免大范围的命名冲突） form &lt;模块名&gt; import &lt;内容&gt;：从模块中导入一个指定的部分到当前命名空间中。不需要再加上前缀，可以直接使用。（可能导致大范围的命名冲突，但是在 __init__.py 中建议使用中这种方式，以避免复杂的模块内命名空间） form &lt;模块名&gt; import * ：可以完整的导入模块内的所有内容（函数、全局变量名等），并且不需要使用命名空间，但是非常容易引起冲突， 前面的内容均可以使用 as 为导入内容生成别名。例如 import CJFKit as CJFXXX. 建议在编写自己模块的时候，少用全局变量，避免冲突。 python的包组织形式是文件夹形式，文件夹名字即是包名。然后其内一定有一个 __init__.py 文件，其内包含所有的文件引用。 总之，使用 import引入包或者模块时，都需要加上前缀对象名才可以访问内容。 数据类型相关： None是一种类对象，是NoneType类型。如果没有return语句，函数执行完毕也会返回结果，只是结果为None。 Python标准数据类型： Numbers（数字） ： int（有符号整型）:位数是64位，最长能显示 [ -922 3372 0368 5477 5808, 922 3372 0368 5477 5808 ]。 long（长整型[也可以代表八进制和十六进制]，后面加L）：起码128位 float（浮点型） complex（复数，表示为 a + bj 或者是 complex（a,b）） String（字符串） : 可以使用 单引号、双引号 和 三引号（期间包含的内容将不经过转码直接显示，可以直接包含换行、引号等内容） 表示字符串字面量。 支持下标操作，且支持负数下标。 使用 == 比较内容(注意在python3中 cmp函数被移除) List（列表/序列） ： 【】: 列表，即可变数组。支持下标操作，且支持负数下标。 打印时显示为 【 xx,xx,xx....】,且字符串类型会带上单引号。 Tuple（元组） ： （）：元组，即只读数组。支持下标操作，且支持负数下标。 打印时显示为 ( xx,xx,xx.... ),且字符串类型会带上单引号。 Dictionary（字典）： { xxx:xxx, } : 字典。内容可变。键可以为任意的不可变类型，值则可任意类型。 dic.keys()会返回一个键列表，dic.values()会返回一个值列表。 打印时显示为 { xx：xx,xx.... },且字符串类型会带上单引号。 使用 in 检测是否存在key。比如 “xxxx” in dic ，返回值是个BOOL值。 Set（集合）： 使用list或者是tuple来初始化set，会去重后生成set集合。表示为 { 1,2,3，………… } 这种类型 可以使用集合操作符：| 表示合集,&amp; 表示交集,- 表示A相对于B的补集,^ 表示双方的差集 set要求传入的元素均为不可变对象，否则会直接报错。 不支持下标操作，会直接报错。 类型转换： int(x [,base]) 将x转换为一个整数 long(x [,base] ) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符，只支持ASCII字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值，只支持ASCII字符，直接以字符串的形式放入即可 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 使用 到变量[头下标:尾下标] 可以截取 字符串、列表 和 元组的子元素。使用这种方式截取的子元素，其类型与原类型相同。且这是个半闭包（前包后不包）取值。 range(x1,x2):这也是一个半闭包，前包后不包。 Python不支持单字符类型，单字符也在Python也是作为一个字符串使用。 元组中只包含一个元素时，需要在元素后面添加逗号: tup1 = (50,) 变量的类型是可以变的，即一个变量在上一个语句指向一个str对象，接下来你还可以将它指向int对象。即所有指针都是通用的。（怀疑是存在一个通用的基类） 函数相关： 默认参数： 函数可以使用默认参数（必选参数在前，可选参数在后），例如 person ( name , age = 19 , city = "SH" ) 可以选择性使用参数（即可跳过一定的中间可选参数），但对于选择性使用的参数需要强制指明变量名，类似于 city="xcasca"。例如 person( "jack" , city = "BJ" ). 由于函数默认参数是采用静态对象的方式保存的，一旦被定义就维持着这一个对象，因此函数默认参数对象必须采用不可变对象。 可变参数： 使用 calc( *number ) 这样的形似就可以了一个可变参数函数。它可以接受多个参数传入，会将它们自动组合成为以number为变量名的tuple。 其允许传入0到多个参数 我们可以使用一个list或者tuple传入多个参数，那么需要在对象前加上*，表示解析为多个参数。 关键字参数： 我们可以使用 person( name, age, **dic)，这个 **kw就表示可变参数。然后调用时使用 person( "jack" , 19 , "city" = "SH" , "job" = "fuck" )，这样的类型来调用，后面的两个参数会组装成字典 dic的元素，然后我们可以通过读取 dic来获取这些参数。 可以直接将一个字典 例如 extraDic ,使用 person( "jack" , 19 , **extraDic ) 的方式传入。 命名关键字参数：（主要是为保证我们不传错参数） 定义类似于 person(name, age, *, city, job) ，正常情况下中间的 * 不可忽略。 如果 person(name, age, *args, city, job) ，存在可变参数，那么 * 必须忽略。注意，此时在可变参数之后的参数，都是命名关键字参数，需要使用键值对的形式才能赋值。 其在调用时，必须 使用 person( “jack” , 19 , city = “SH” , job = “enginner” ).必须指明命名关键字标志后面的参数的名字 和 值，否则会报错。 这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。例如： def f1(a, b, c=0, *args, ddd ,eee = 19 , **kw): print(a)；print(b)；print(c) print("change”)；for n in args: print(n)； print("key”)；print(ddd)；print(eee) print("kw”)；print(kw) f1(1,2,3,4,5,6,7,8,9,ddd=1) 结果为：1、2、3、change、4、5、6、7、8、9、key、1、19、kw、{} 递归函数的尾递归优化： 函数的堆栈层级是受限制的 ，一般肯定小于1000（在本机测试的结果是 998为极限）。 尾递归优化技术的条件：在return语句中，只返回本函数的调用，不包含任何的其他计算。（当然参数上可以计算），例如 return fact_iter( num -1 , num * product ) 这是符合尾递归优化的函数。但是 return n * fact( ｎ －１ ) 这是不符合尾递归优化。 当符合尾递归优化时，编译器会优化调用，是其始终只占用一层调用堆栈。 并没有什么鸟用！！！因为Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题！ 基础语法相关： 变量不需要声明类型，直接使用即可，但Python依然是强类型语言，必要时需要类型转换语句。注意此处的转化并不是指指针上的转化，因为python中的指针是万能指针，可以指向任何对象。这里的转化是指对实际对象的转化工作，否则在运行时相应对象如果调用了它不存在的属性或者方法将会引起运行时错误。 print 自带了换行符,print后面接任何东西都会以string的形式打印出来 赋值语法： a, b = b, a + b 表示 a = b ; b = a + b s1,s2 = sss.split(".”) :表示 将函数返回的list值，依次组装到等号左边的元素中去。注意，如果此处参数个数不相等，会产生运行时错误。 没有++ 或者 - - 语句，需要采用原始的 i = i+ 1来完成 语句后面不需要分号，if \ else \ for 语句后面需要 冒号 成员运算符：用于在容器类中包含判断包含元素。 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 身份运算符：用于判断两个变量的存储单元是否一致。 is is是判断两个标识符是不是引用自一个对象 x is y, 如果 id(x) 等于 id(y) , is 返回结果 1 is not is not是判断两个标识符是不是引用自不同对象 x is not y, 如果 id(x) 不等于 id(y). is not 返回结果 1 逻辑运算符： and x and y 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔"或" - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False pass 语句 pass是空语句，是为了保持程序结构的完整性。 for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行结束（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。 基本数学相关方法：http://www.runoob.com/python/python-numbers.html 随机数 与 随机方法 三角函数 类型转换 数学常量，使用 math库，math.pi 常量。 字符串相关所有操作符： + 字符串连接 a + b 输出结果： HelloPython * 重复输出字符串 a*2 输出结果：HelloHello [] 通过索引获取字符串中字符 a[1] 输出结果 e [ : ] 截取字符串中的一部分 a[1:4] 输出结果ell in 成员运算符 - 如果字符串中包含给定的字符返回 True H in a 输出结果 1 not in 成员运算符 - 如果字符串中不包含给定的字符返回 True M not in a 输出结果 1 r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母"r"（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 print r'\n' 输出 \n 和 print R'\n'输出 \n % 格式字符串 请看下一章节 字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行，键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。 类型判断：type( xxx )可以返回类对象，该思想与OC一致，且每种类对象都全局单例唯一。可以使用 type( xx ) is xClass 来判断（但不建议使用，已经不适用于类族的情况）。建议使用： isinstance( var , class )来判断。 如果需要判断一个函数类型可以用这种方法。也可以使用： 或者是 使用 callable( xxx ),如果返回true则表示可以，否则就表示不可以。（推荐这一种） 所有参数（自变量）在Python里都是按引用传递，所有变量在python中都是对象，python没有内置类型。如果你在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。 python支持可变参数传值，加了星号（*）的变量名会存放所有未命名的变量参数。选择不多传参数也可。可变参数变量在内部表现为元组形式使用。 python中的 lamdba 可以持续的捕捉变量的数据，同时追踪它在 lamdba表达式之外是否发生变化，内部变量也同步发生变化。可以认为，其捕捉的变量和外部变量是同一个变量。 python变量的作用域，只有全局和局部的区别。且局部变量只出现在函数调用内部，语句块不影响变量的可见性。 Python会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。因此，如果要给全局变量在一个函数里赋值，必须使用global语句。 global VarName的表达式会告诉Python， VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量了，否则结果就是会出现一个UnboundLocalError的错误。 使用__init__.py 形成包的组织形式。 File 对象方法: file对象提供了操作文件的一系列方法；OS 对象方法: 提供了处理文件及目录的一系列方法。 全局变量是全局可见的，且与定义位置无关。 自定义类相关： # 例子： class Employee: '所有员工的基类’ # 可以使用类的帮助信息可以通过ClassName.__doc__查看 empCount = 0 # 算是静态变量 def __init__(self, name, salary): #成员函数的第一个参数一定是 self self.name = name #成员变量不需要声明，直接使用即可 self.salary = salary Employee.empCount += 1 在类定义中，与方法同级的变量是 static变量，归属于类对象。类对象最好使用类名.变量名去访问，直接使用 对象.变量名去访问，可能访问的是对象的动态属性。 对象的属性可以动态变更（不仅是类的实例变量的属性可以动态增删，连类对象的static变量都可以支持动态增删），使用如下方法，当我们使用 .属性访问时，其实默认内部调用的就是这些方法。目测在类内部维持有一个属性字典，以支持动态的增删属性： getattr(obj, name[, default]) : 访问对象的属性。如果不存在该属性，将会处罚exception。 hasattr(obj,name) : 检查是否存在一个属性。 setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。 delattr(obj, name) : 删除属性，删除后属性整个就不存在了。 如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性： class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的 类的实例方法的参数，第一个一定是 self。 类的属性获取都应该先使用 hasattr 判断是否存在，然后再进行下一步操作。 使用 self.__class__ 或者 实例变量.__class__ 可以返回该实例变量的类对象。 类对象的内置属性：（注意是类对象的，而不是实例变量的，其实也是静态变量） __dict__ : 类的属性（包含一个字典，由类的数据属性组成）【其中包含了所有的静态变量、方法（静态或非静态）、类的内置属性】 __doc__ :类的文档字符串 __name__: 类名 __module__: 类定义所在的模块（类的全名是'__main__.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod） __bases__ : 类的所有父类构成元素（包含了以个由所有父类组成的元组） id( xxx ) 可以返回一个对象的内存地址。可以用 id( xx ) == id( xxx ) 来判断是否是同一个对象。 类继承的写法以及特性： 实例： http://blog.chinaunix.net/uid-22920230-id-3070742.html 在继承中基类的构造（__init__()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。 在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数（在类外调用的话，是都不需要的）。 Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。 类的方法可以可以动态的添加和删除。 在类对象上添加方法：className.method_name = method; 。在添加完成后，所有的该类的实例对象都可以使用该方法。 在实例对象上添加： 需要先导入 from types import MethodType 然后使用 instanceName.method_name = MethodType( method ,instanceName ) 这样的设置方法，该方法只有被设置的对象可以使用，其他对象不能不能使用。 动态设置属性方法。 使用属性名作为设置和获取的方法名。 使用@propety修饰获取方法 使用@属性名.setter 来修饰设置方法 内部的实际存取变量或者运算还是由自己控制的。属性方法不会自动生成关联变量。 可以设置只读属性和只写属性。 示例： 定制化类：（内置方法的实现） 使用 __init__ 实现自己的定制化初始化方法。 使用__slots__ 赋值为元组，限制属性 实现 __len__ 函数可以在外部调用len()函数时，打印自己的长度。 打印相关：__str__ 方法，在print instance时被调用。__repr__ 在debug输出时被调用 成为Iterable对象：实现__iter__函数，返回相应的可迭代对象。如果是自己的话，那么再继续实现__next__函数，来支持 for-in循环。 支持下标和切片操作：实现 __getitem__ 函数，返回相应的list 或者 tuple。（要注意的是，切片有多种形式，需要覆盖完全才可,切片的类型是slice） 动态属性生成：__getattr__函数，可以支持返回变量和方法，如果是后者，那么外部需要加上调用式。 注意，此方法只有在无法找到合法属性时才会调用，且最好在尾部raise出异常 此方法与链式语法结合可以达到很好的效果 编程可调用对象：实现 __callable__ 函数，即可使对象可被调用 枚举类： 使用 Enum生成简易枚举对象： 导入头文件：from enum import Enum 生成类对象：Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')) 继承于Enum类对象，实现高度定制化枚举类： 导入头文件：from enum import Enum，unique 定义类： @unique class Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 高级语法特性： 切边：即快速选取部分元素，这在上面有提到过，范围是个半闭包。 只能用于list和tuple 以下标作为截取范围标记 切边产生的元素类型与原类型一致 有多重表现形式： 【startIndex:endIndex】不包含末位 【：length】默认从0开始 【：】完整的赋值 【-a:-b】从倒数第b位开始，到倒数第a位，不包含第a位。注意，此时list末尾的依然是0开始，然后向左递减。注意，此时截取的list内元素顺序依然是之前的顺序，这个范围只决定截取范围。 【-a:】表示倒数第0位到倒数第a位，不包含倒数第a位。 【a：b：c】表示截取[a,b)范围元素,并且在这些元素中，每c个取一个,都取第一个,末位的分组也会被取一个。 迭代：符合迭代对象的，都可以使用 for-in遍历 包含 from collections import Iterable，使用 isinstance('abc', Iterable) 可以判断一个对象是否是可迭代对象Iterable，如果是的话，那么就可以直接使用 for-in遍历。 常见的迭代器对象：range 、dict、list、tuple、set、str 其中dict的迭代方式最多： for key in d ： 默认遍历key for value in d.values() ：遍历value for k, v in d.items() ： 遍历key 和 value 使用 enumerate 实现下标循环： for i, value in enumerate(['A', 'B', 'C']) 使用tuple可以获取多个变量：for x, y ,z in [(1, 1,1), (2, 4,6), (3, 9,27)]: ，但必须保证 变量个数与tuple内单个元素的length相同。 列表生成式： 用于快速生成列表的表达式（且仅能用于list），基本规则为：【 生成表达式 for - in 语句 】 举例说明：[x * x for x in range(1, 11) if x % 2 == 0]，这一段代码等价于 L = list() ; for x in range(1,11): if x % 2 == 0: L.append( x * x ) 即 生成表达式最终会被放入 append 函数中，但只有符合前置条件，才能到达这个位置。 支持多种循环嵌套使用,且在中括号内的函数不需要使用 ： 和 ； 生成器： 是generator 类型，该类型表示一个生成器对象，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误，正统函数的返回值包含在StopIteration对象的value中。 这样可以有效的减少内存压力 generator也是一个迭代器对象，可以用于 for-in中，且这样遍历更为安全，不会产生越界错误。 generator有两种方式定义： 一种使用函数的方式来定义的，例如： def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator，generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 一种是只要把一个列表生成式的[]改成()，就创建了一个generator。 迭代器： 主要分为两种类型： 一类是集合数据类型，如list、tuple、dict、set、str等，这些都是Iterable对象，可以通过iter()函数转化一个Iterator对象。 一类是generator，包括生成器和带yield的generator function，这些本身就是Iterator对象； Iterable类型：可以用于for循环 Iterator类型：不止可以用于for循环，还可以用你next 获取下一个元素。 Python的for-in循环本质上就是通过不断调用next()函数实现的，在遇到exception时break。 函数式编程： 函数式编程简介：https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn/blob/master/FunctionalProgrammingForTheRestOfUs.cn.md 函数式编程的特点： 其与数学公式是相对应的，特别是当我们使用generator的时候，他可能就是一组符合公式的无穷数组。 它是惰性求值的，我们不需要担心内存问题。 它的函数也是对象，是一等公民。我们可以把函数作为对象传入或输出，更可以结合 lambda表达式创造可变函数返回对象：（例如） def _not_divisible(n): return lambda x: x % n &gt; 0 函数本身也是变量，即变量可以指向函数。函数名也是变量，一旦被重新赋值，就不再指向原来的函数，而是指向新的变量。其类型为 &lt;class 'builtin_function_or_method’&gt; 。 一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 常用系统高阶函数： map( func, iterable ) 将func 应用于iterable中的每一个元素，并返回一个 iterator。 注意，由于返回的是 iterator，因此是惰性求值的，如果我们希望等到一个已运算完成的数据集合，需要使用 list( iterator )，即将 iterator list化。 reduce( func, iterable ): 表示 func( x,y ) ，其中x是上次运算的结果，y为下一个元素，首次时x,y分别为前两个元素。这是一种归纳求值的操作。 注意，reduce() 需要包含 from functools import reduce ，方能使用。 注意，由于返回的是 iterator，因此是惰性求值的，如果我们希望等到一个已运算完成的数据集合，需要使用 list( iterator )，即将 iterator list化。 filter( func , iterable ): filter()函数用于过滤序列 filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素. 注意，由于返回的是 iterator，因此是惰性求值的，如果我们希望等到一个已运算完成的数据集合，需要使用 list( iterator )，即将 iterator list化。 请参见：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431821084171d2e0f22e7cc24305ae03aa0214d0ef29000里面关于素数筛选的例子非常好的诠释了函数式编程的特点和优势，虽然我还不明白它编译器要怎么做，但确实是很不一样的编程思路。 sorted（….）： 这是一个排序函数，且支持传入预操作函数和排序顺序。 有两类sorted函数：（在python3中 cmp函数被移除） sorted(iterable, key=None, reverse=False) L.sort( key=None, reverse=False) 其中的key可以使用 lambda表达式： 比如 key= lambda x:x["xxx"] ,即 x表示一个元素， 冒号后面返回参与比较的元素 iterableb表示迭代器对象，key函数确定作为排序依据的key值，将会在排序前作用于每一个元素并取得这个元素的key值，然后根据这个key值进行排序，reverse表示是否反序。 需要注意的是，sorted函数不会影响list中元素的值，只会影响其排序关系。 内部函数与返回函数： 通常返回函数都是内部函数，这些内部函数可以捕获外部变量被自己使用。这些特性称为闭包。 返回的函数并没有立刻执行，而是直到调用了f()才执行 这些捕获的变量通常会指向同一块内存地址，因此会导致外部变量变化时，捕获变量也一起变化。 返回函数不要引用任何循环变量，或者后续会发生变化的变量。否则会导致函数难以维护以及内存泄露。 如果一定要引用循环变量：方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 匿名函数： python对lambda提供有限的支持。 匿名函数有个限制，就是只能有一句表达式，不用写return，返回值就是该表达式的结果. 可以把匿名函数作为返回值返回 形式：lambda 【paramter】: 【表达式】 装饰器： 这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。 decorator（）函数的参数定义是（func），不能附加其他参数，这是规范。如果希望传入外界变量给装饰器函数使用，那么就需要外界再套一个函数，这样避免循环引用。 装饰器函数根据是否需要捕获外界变量分为两种： 不捕获外界变量： 捕获外界变量：它所能捕获的参数仅限于log函数的传入参数。这里需要使用三层的原因，是由于@的展开式导致的，可以看一下下面关于@展开格式的论述。（注意，@展开式是固定的） 函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'。因为返回的那个wrapper()函数名字 就是'wrapper'， 所以，需要把原始函 数的__name__等属 性复制到 wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。 这句话的本质其实就是def now ….; now = log(now)。其实就是对@xxx做了一次调用。如果是@log(“asa”)则变成 now = log(“asa”)( now ) 的调用形式。最后结果一定要是返回 wrapper函数。 更多内容可以参考：pycharm/python3/LearnDecorator. 装饰器的用法： 先在前面定义相应的装饰器函数，根据是否需要使用额外的外部变量，采取上面两张写法中的一种。 使用@装饰器函数名字，如果有参数的话，在此处还有传入参数。 紧接着上面这行代码，定义需要使用到函数 为装饰器函数改名：只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。需要预先 import functools. 偏函数： 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 int2 = functools.partial(int, base=2) --- int2('1000000') =&gt; int2('1000000', base=2) 被设置的默认参数依然可以继续被覆盖 代码调试： if __name__=='__main__’: test() 。 当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。 命名规范： 变量命名： 全局变量：一定要在前面加上”G_" 前缀 不可变变量：一定要加上 “C_” 前缀 全局不可变变量：加上 “GC_” 前缀 临时变量：可以随意命名，采用驼峰命名法 函数命名： 本地函数： 外部可见引用函数：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符编码知识]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[字符编码知识基础概念：字符集：表示一系列自然语言的符号的集合以及其编号。比如 ASCII码字符集，Unicoe字符集等。字符集可以决定一个字符的编码值。且编码值仅能由字符集决定。字符编码方式：将一个字符集具体编码成为二进制表示的编码方式。比如 UTF-8（UTF-8是Unicode字符集的编码实现方式），UTF-16以及原始的ASCII编码等。编码方式可以决定 具体编码值的存储方式，比如定长存储还是变长存储，边界如何区分等。字符编码顺序：由于一个字符可能由多个二进制字节表示，而二进制的存储单位是以8位为一个字节存储单元的。（在字节存储单元内部，顺序固定从从左至右）而字节之间的顺序是不一定的。因此，诞生了大端模式 和 小端模式：（以“严”字 unicode编码“4E25”为例）大端模式：前者在左，后者在右。最终编码为 4E25 。符合中国人阅读顺序。小端模式：后者在左，前者在右。最终编码为 254E 。参考文章：字符编码笔记：http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[颜色空间]]></title>
      <url>%2F2017%2F02%2F09%2F%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%2F</url>
      <content type="text"><![CDATA[颜色空间 颜色空间包括：RGB,HSL,HSB,CMYK RGB:红绿蓝三色色彩模式，工业界比较通用的色彩空间模式 HSL:色相(H)、饱和度(S)、明度(L)颜色空间，工业界比较通用的色彩空间模式 HSB:色相(H)、饱和度(S)、亮度(B)颜色空间，对应的媒介是人眼。 CMYK：青色(cyan)、品红色(magenta)、黄色(yellow)、黑色(black,为避免与RGB中的Blue混淆而采用K代指黑色)印刷四色模式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图解HTTP-读书笔记：HTTPS相关内容及HTTP协议的扩展]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%9B%BE%E8%A7%A3HTTP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9AHTTPS%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E5%8F%8AHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
      <content type="text"><![CDATA[图解HTTP-读书笔记：HTTPS相关内容及HTTP协议的扩展HTTP的缺点：安全方面的缺点：未加密，采用明文传输易被窃听易伪造，通信时没有验证双方的身份易篡改，传输过程中内容可能会被篡改功能方面的缺点：一条链接上只可发送一条请求，虽然该链接可以复用，但是只有等上次的请求响应返回后才能发送下一次请求。无法实现并行发送。请求只能由客户端发起，服务端被动响应。且客户端无法接受响应wait的其他指令。请求/响应的首部字段无法压缩，且每次都需要带上完整的首部字段。导致冗余信息过多。虽然可以选择任意压缩格式，但是仅限于对于实体有效，且非强制进行压缩。HTTPS并非是一种新的协议，而是HTTP通信部分接口采用SSL协议（也是一个应用层协议）代替而已（之前是直接采用TCP协议来实现）。其中SSL是独立的协议，也是广泛引用的网络安全传输协议。其可以与SMTP、Telnet等联合使用，提高安全性。SSL协议加密要点讲解：存在完全可信的第三方认证机构CA，其的数字证书和公开密钥会提前植入在浏览器内部。CA使用私有密钥对服务器的的公开密钥进行数字签名，并将结果返回给服务端保存。在发起链接时，客户端会先发起请求打通链路。服务端回应请求，并返回第二步中已被签名的公开密钥证书。客户端向CA认证证书有效性，通过后将使用其公开密钥进行加密通信。接着，双方采用RSA加密方式协商完成DES加密所需的密钥值。然后SSL链接建立完成，之后的通信将采用DES加密完成。SSL协议分析：由于RSA加密代价较高，因此只在协商DES加密所需的密钥时使用。之后为了加快效率，将使用协商后的DES加密来通信。完全可信的CA机构，及其内嵌至浏览器内的公开密钥证书，是整个SSL加密可靠性和安全性的最终保障。一旦CA的私有密钥被攻破，那么服务端的公开密钥将随时可被伪造，整个SSL加密的可靠性也将完全丧失。HTTP使用的认证方式：Basic认证方式：明文密码传输方式，已无人使用。Digest认证方式：密码散列后传输，已无人使用。SSL客户端认证：确保通信链路的可靠性，但却无法认证用户的可靠性，基于表单的认证：输入账号密码，可以识别用户的可靠性。配合SSL认证使用后，可以确保有效的用户安全的使用链接。基于HTTP的追加功能/协议：Ajax技术方案：采用XMLHttpRequest的API，利用JS就能和服务端进行HTTP通信。其可以在已完成请求的web网页上发起局部请求。SPDY协议：实现的扩展功能：多路复用流功能，通过单一的TCP链接可以同时发起多条HTTP请求，TCP处理效率得到提升。可以针对每个请求赋予优先处理优先级，避免由于带宽限制导致的响应变慢问题。压缩HTTP首部字段推送功能，服务器可以主动推送通知给客户端，客户端也能合法的接受这类通知。服务器提示功能。实现的原理：其在原始的HTTP通信上，再附加了一层会话层，使HTTP协议从无状态变成了有状态协议。但它没有变更HTTP协议本身。优先：其可以有效的消除HTTP在性能上的瓶颈。且原始的web内容端无需做改变，只是web服务器和浏览器需要针对此协议做额外的适配。一旦适配完成，就可以提供额外的API以供使用。WebSocket协议：客户端和服务端全双工通信协议。其是独立的标准协议，但是其需要基于HTTP才能实现。优点：可以实现双向通信，且数据量少（因为首部字段减少）。实现原理：需要借由HTTP首部的Upgrade字段升级协议。需要一次HTTP交互切换协议。其在JS中提供原生支持API。HTTP2.0技术：目前已经出台，但是未大面积普及。其结合了多方协议来决定最终效果，参考协议如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图解HTTP-读书笔记：HTTP基础概念]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%9B%BE%E8%A7%A3HTTP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[图解HTTP-读书笔记：HTTP基础概念万维网由三个基本协议构建：HTML(超文本标记语言)、HTTP(超文本传输协议)、URL(统一资源定位)与HTTP相关的常见协议： TCP：传输层协议，提供可靠流传输。三次握手（使用 SYN + ACK 同步），四次释放（由于需要确认双向关闭，避免对之后的通信链路造成影响）。IP：网络层协议，中转传输。通过将 IP地址 与 MAC地址 绑定，将数据从一台主机传输到另一台主机。DNS：应用层协议，用于将 URL地址转化为 IP地址。HTTP请求分为两个部分（两者之间采用 CR+LF分割）&nbsp;&nbsp;： 报文首部：一个请求行：包含 HTTP方法、请求URI、HTTP版本多个请求头参数：通用首部字段请求首部字段实体首部字段其他（主要是 cookies）报文主体： 可以支持 chunked编码传输，理论上其并没有大小的范围限制。可以在 content-Type 中指明 multipart/form-data（表单上传） 或者是 multipart/teranges（响应返回），通过该参数内的 boundary 字段指明分割标志，从而传输多类型实体。HTTP响应分为两个部分（两者之间采用 CR+LF分割）：报文首部：一个响应行:包括 协议版本、状态码、原因短语多种响应头参数：通用首部字段响应首部字段实体首部字段其他（主要是 cookies）报文主体：可以支持 chunked编码传输可以在 content-Type 中指明 multipart/form-data（表单上传） 或者是 multipart/teranges（响应返回），通过该参数内的 boundary 字段指明分割标志，从而传输多类型实体。可以使用Cookie将无状态的HTTP协议变为有状态。cookie由服务端主张设置，客户端执行设置，并在下次请求中附带内容。Session是基于Cookie管理的。可以使用 Range 字段指定想要请求的资源范围。但这需要服务器支持，如果服务器支持这种请求，那么会返回 206 Partial Content 以及指定范围的内容。否则将返回 200 OK 以及完整的实体内容。服务器和客户端可以就 响应资源的内容进行协商，从而返回最适合客户端的响应。协商方式：服务器驱动协商：需要客户端在请求参数中传入完善的协商信息，然后服务端根据要求返回相应的内容客户端驱动协商：用户可以在客户端手动配置一些选项，比如切换语言等，然互通过JS脚本的方式实现替换。透明协商：主流模式，就是上面两者的结合体。协商相关的字段：（主要是请求首部字段，因为协商必然是需要根据请求来做处理的）Accept：用户代理能处理的媒体类型及媒体类型优先级。可以有多个值。Accept-Charset：用户代理支持的字符集以及能接受的字符集优先级。Accept-Encoding：用户代理能支持的内容编码及其优先级。主要有gzip、deflate、compress 和 identity等。Accerpt-Language：用户代理能处理的自然语言集及其优先级。HTTP请求响应状态码区分：（具体内容可以参见图解HTTP举例）1xx：信息性状态码，接受的请求正在处理。2xx：成功状态码，请求正常处理完毕。3xx：重定向状态码，需要进行附加操作以完成请求。其中 304 Not Modified 表示 在请求中附加附带条件时，如果服务端判断条件不满足，即无可响应实体，便会返回这个字段。其虽归类为重定向一族，但是与重定向无关。一般来说，重定向后浏览器会自动将POST改为 GET，但是 307 Temperory Redirect 强制要求不可转换方式。其他均会被默认转换方式。4xx：客户端错误状态码，服务端无法处理请求。一般表示请求错误，或者服务端不想响应，或者需要验证等。5xx：服务器错误状态码，一般表示服务器处理出错，或者过载。通信数据转发程序：代理服务器、网关 和 隧道。代理服务器，其基本行为就是接受客户端发送的请求后转发给其他的服务器。代理不改变请求的URI，会直接发送给前方持有资源的目标服务器。分类：按照是否使用缓存：缓存代理 和 透明代理。按照是否会修改报文： 透明代理 和 非透明代理。相关字段： via，每次通过代理服务器时会追加这一字段。有些请求参数在通过 代理服务器时会被删除，因为其只在 客户端和代理服务器之间生效。缓存有效性问题：一份缓存的有效性需要综合 客户端要求、缓存的有效期等因素决定，在超出有效期后需要发送请求向服务端确认。首部字段根据生效的持续时间被划分为两种：End-to-End Header：端到端首部，其参数会一直保留在HTTP请求中，从客户端一直传递到服务端。Hop-by-hop Header：逐跳首部，其参数只会在单次转发中生效，然后就会被删除。具体有以下字段：Connection、Keep-Alive、Proxy-Authenticate、Proxy-Authenorization、Trailer、TE、Transfer-Encoding、Upgrade具体首部字段的含义请参考《图解HTTP》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON深入解析]]></title>
      <url>%2F2017%2F02%2F09%2FJSON%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[JSON深入解析 JSON的基本结构： JSON的根类型要么是数组（以中括号开始【】），要么是对象（以花括号开始{}）。 JSON的数组内，一定全部都是对象。需要以花括号包围。同时，数组内对象的具体格式可以不同，均可解析为合法的json对象。 除了最外层的对象没有名字，其他任何的JSON结构都有名字。 在一个作用域范围内，（作用域是指 数组 或 对象）除去最后一个元素外，每一个元素都需要在最后加上 逗号‘，’分隔。 IOS上的JSON解析： The top level object is an NSArray or NSDictionary. All objects are instances of NSString, NSNumber, NSArray, NSDictionary, or NSNull.(和标准JSON相比，我们不接受boolean值，其会被转化为NSNumber使用) All dictionary keys are instances of NSString. Numbers are not NaN or infinity. 使用方法： 生成JSON串： NSMutableDictionary *dictionary = [[NSMutableDictionary alloc] init]; [dictionary setValue:@"Anthony" forKey:@"First Name"]; [dictionary setValue:@"Robbins" forKey:@"Last Name"]; [dictionary setValue:[NSNumber numberWithUnsignedInteger:51] forKey:@"Age"]; NSArray *arrayOfAnthonysChildren = [[NSArray alloc] initWithObjects:@"Anthony's Son 1", @"Anthony's Daughter 1", @"Anthony's Son 2", @"Anthony's Son 3", @"Anthony's Daughter 2", nil]; [dictionary setValue:arrayOfAnthonysChildren forKey:@"children"]; NSError *error = nil; NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dictionary options:NSJSONWritingPrettyPrinted error:&amp;error]; NSString* str = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; 解析JSON串: NSString *dataFilePath = [[NSBundle mainBundle] pathForResource:@"data" ofType:@"json"]; NSData *data = [NSData dataWithContentsOfFile:dataFilePath]; NSDictionary *rootDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; iOS JSON对象与原生对象的转化类型： JSON对象 原生对象 “asdas” NSString { .. } NSDictionary [ ... ] NSArray 18 或者 18.9 NSNumber true / false NSNumber null NSNull python中JSON对象与原生对象的转化类型： JSON对象 原生对象 “asdas” unicode(basestring的一个子类) { .. } dict [ ... ] list 18 int 18.9 float true / false bool null NoneType 参考文章： JSON使用可以参照《ios网络高级编程》P83 可以参考官方API文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[结构体内存对齐问题]]></title>
      <url>%2F2017%2F02%2F09%2F%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[结构体内存对齐问题一个结构体，如果要求内存对齐，那么需要满足以下要求：结构体占用的总内存占用大小是其下最大的内存占用成员变量的整数倍。结构体中，每个成员变量的首地址必须符合如下要求：首地址 % sizeof(类型) = 0，如果紧接着的地址不能符合此要求，那么必须空出这个地址，直到找到下一个合适的地址为止。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大端小端问题]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[大端小端问题基本概念：比如我们有一个结构体，其内有【int32、short16、char8】三个成员，那么在内存地址分配上，【在不考虑是否内存对齐的情况下】，int排在首位 ，例如0x0000，然后是 short的首地址0x0004，最后是char的首地址0x0006。但是在每个元素的内部，并没有规定一个确定的顺序。总体来说，从整体看是先声明先分配，从每个成员看，取决于大端序还是小端序，从字节内看，与书写习惯一致。常见名词：大端序：与书写习惯一致，高位低字节。小端序：与书写习惯相反，高位高字节。【可以先写出大端序的内容，再按字节为单位翻转顺序即可】主机序：表示该主机使用的顺序。网络序：表示该网络协议使用的顺序。常见应用场景：根据TCP/IP网络协议要求，在网络上传输的内容都是大端序。主机序由具体的操作系统决定，那么建议统一将 大端序的网络数据转化为主机序后使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图解HTTP-读书笔记：web页面安全及构建相关内容]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%9B%BE%E8%A7%A3HTTP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9Aweb%E9%A1%B5%E9%9D%A2%E5%AE%89%E5%85%A8%E5%8F%8A%E6%9E%84%E5%BB%BA%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[图解HTTP-读书笔记：web页面安全及构建相关内容web页面构建技术概览：HTML：超文本标记语言，用于格式化传输和展示内容。CSS：层叠样式表，专注于如何展示HTML内的元素，控制布局的样式。JS语言：提供动态的脚本语言执行能力。DOM：一系列可以操作HTML和XHTML的API，使用JS即可调用。web页面数据交换格式：XML：标签易于扩展，但冗余数据过多。JSON：轻量级数据交换格式，目前的主流。Web页面攻击技术：（暂时不关注这一块，可以以后再看）因输出值转义不完全导致的安全漏洞：跨站脚本攻击：即在表单填写时，写入JS语法或者是HTML语法，使其在浏览器内动态的执行。最明显的就是document.getCookie 盗取网站的cookies信息了（需要该网站未设置 cookies 未 HttpOnly 才行）。SQL注入：利用SQL语法特性，使输入语句执行特定的SQL。常见的比如 -- 可注释掉之后的SQL语句OS命令注入：利用OS命令注入，使系统额外执行特定的shell命令。比如 利用 ； 隔开后，直接执行其他未经许可的命令。目录遍历攻击：使用 . .. 等标识符，定位到未经许可的文件夹中操作。Http首部注入攻击：在首部写入字段中插入换行，使换行后的内容成为HTTP首部的字段之一邮件首部注入攻击：也是通过换行符的操作执行的。远程文件包含漏洞：PHP语法漏洞，可以支持从外部服务器加载执行文件因设置或设计上的缺陷引发安全漏洞：强制浏览：即原本不对外暴露的URL，通过强设URL，即可进行访问不正确的错误处理信息：不应该将详细信息返回给用户代理，否则可能会将自己服务器的信息泄露给别人。开放重定向功能：即在URL后附加Redirect字段。因会话管理疏忽引发的安全漏洞：会话劫持：即通过获得到用户的cookies后，伪装成用户进行会话。会话固定：即诱导用户去认证，然后拿到认证信息或者会话ID后，伪装成用户去访问。跨站点请求伪造：即通过嵌入脚本的形式，诱导用户触发，然后通过用户代理发起请求。（此时请求视为是用户主动发起的，因此服务端无法识别到差异）其他安全漏洞：密码破解点击劫持：利用透明按钮等方式，使用户在不知不觉中触发事件。Dos攻击（Denial of service attack）:拒绝服务攻击。一般有两种方式：海量访问，使服务器过载。多台计算机发起的Dos攻击称为 DDos攻击（Distributed&nbsp;&nbsp;Denial of service attack&nbsp;&nbsp;）利用服务器安全漏洞，是其宕机。后门程序Web页面攻击防护技术：客户端验证：使用JS对输入做校验。服务端做验证：输入值验证：对输入的数据做校验，及早发现对系统存在攻击性的文案输出值转义：对输出值做转义，防止输出对象对输出接受者造成损害。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP指南]]></title>
      <url>%2F2017%2F02%2F09%2FHTTP%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[HTTP指南HTTP请求基础：每个HTTP请求和HTTP响应都是一对一关系，不会出现一个请求返回多个响应的情况。但是，无论是请求还是响应，都是采用TCP传输的，而TCP有最大分块限制，所以一个请求/响应可能划分为多个TCP块进行传输，那么对于 ios 接受者/发送者来说，可以在 delegate 中重载方法，得知这一些TCP块的接受/发送情况，并且分步的处理这一些数据，减少内存的占用。GET请求的特性：根据定义，GET请求不应该包含请求体，而只应该包含请求行和请求头，且GET请求不应该请求的资源发生变化，否则，由于中间设备的缓存策略，可能会导致下一次GET请求出错。HTTP1.1 开始支持长连接和管道化请求的特性：长连接：即connection:keep-alive，可以在客户端和服务器之间维持一条TCP链接，直到由一方发送 connection:close为止管道化请求：即不需要等待上一个响应返回，即可发送下一个请求，但服务一定要确保按照相同的顺序返回请求。必须在长连接上才能发起管道化请求。响应的返回顺序必须与请求的发送顺序一致。需要随时做好重发的准备，因为链接随时可能会被close。不要使用管道化请求发送能篡改服务器数据的请求，比如POST。URL相关内容：在请求时，需要对 URL字符串 进行 URL编码.URL编码是一种浏览器用来打包表单输入（get方式）的格式，即组装Query String的方式。浏览器从表单中获取所有的name和其中的值 ，将它们以name=value参数编码（移去那些不能传送的字符，将数据排行等等）作为URL的一部分或者分离地发给服务器。所有的name &nbsp;&nbsp;和 value &nbsp;&nbsp;都单独采用百分号编码，然后要求采用 ？ 分隔开URL，然后在后面拼接上 请求串，使用 & 分隔不同的参数值对。(注意 ？ = & &nbsp;&nbsp;以及原始的url地址 都不需要进行base64编码)具体过程如下：&nbsp;&nbsp;请求的URL地址不需要经过编码。请求的参数 key 和 value需要先单独经过百分号编码，即非ASCII字符的全部使用百分号转化采用URL编码规则将编码后的key,value 按照 key = value 进行组装将组装好的Query String按照约定拼接到 URL上（GET），或者 放入 Body中。百分号编码规则：任何特殊的字符（就是那些不是简单的七位ASCII，如汉字）将以百分符%用十六进制编码，当然也包括象 =,&；，和 % 这些特殊的字符（指的是在name &nbsp;&nbsp;或者 value 中包含的这些特殊字符）。其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，每两位十六进制需要在前面加上“%”。“胡”的ascii码是-17670，十六进制是BAFA，url编码是“%BA%FA”请求体内容：Multipart请求相关信息：http://blog.csdn.net/MSPinyin/article/details/6141638multipart/form-data的基础方法是post，也就是说是由post方法来组合实现的multipart/form-data与post方法的不同之处：请求头，请求体。multipart/form-data的请求头必须包含一个特殊的头信息：Content-Type，且其值也必须规定为multipart/form-data，同时还需要规定一个内容分割符用于分割请求体中的多个post的内容，如文件内容和文本内容自然需要分割开来，不然接收方就无法正常解析和还原这个文件了。其有两个必须的实体首部字段：Content-Type 和 Content-Disposition:form-data;name=“xxxxx";filename=“xxxx”.在总的Header的首部字段需要有 Content-Type:multipart/form-data;boundary=“xxxxxxx"在html协议中，用&nbsp;&nbsp;“/r/n”&nbsp;&nbsp;换行，而不是&nbsp;&nbsp;“/n”实际上，每部分数据的开头都是由"--" + boundary开始，而不是由 boundary 开始。仔细看才能发现下面的开头这段字符串实际上要比 boundary 多了个&nbsp;&nbsp;“--”数据流（NSData等）采用Base64编码后再传输：Base64码表：，所有有效字符都在这上面。针对对象：一定是针对data型数据使用，如果是NSString，那么需要先转化为NSData，然后再进行Base64编码。使用场景：Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单（http body）和HTTP GET UR中的Query String的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到。具体规则：参考文章：http://blog.csdn.net/sealyao/article/details/5863716以三个字节为一组，不够的在右边补零在三个字节内部，以六位为一组，在每一组左边填充00做二次映射：0-25:A-Z , 26-51:a-z , 52-61:0-9 , 62 :【标准：+ &nbsp;&nbsp;&nbsp;&nbsp;URL改进：-】, 63：【标准：/ &nbsp;&nbsp;URL改进：_ 】， 尾部全0 填充映射为 = 。特殊规则：按照MIME的规定，每76的base64需要添加换行，用于email发送。但是一般我们都不遵循这个标准。最后的结尾的处理：标准未规定，MIME建议加上换行符。书籍参考：《图解HTTP》：图解HTTP 读书笔记：HTTP基础概念、图解HTTP 读书笔记：HTTPS相关内容及HTTP协议的扩展、图解HTTP 读书笔记：web页面安全及构建相关内容]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Head First:HTML与CSS读书笔记]]></title>
      <url>%2F2017%2F02%2F09%2FHead%20First%3AHTML%E4%B8%8ECSS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Head First:HTML与CSS读书笔记注意：本文所有的样式展示均采用 chrome mac 2016/07 最新版编写。HTML部分： 功能定义：负责描述网页的结构。 元素分类： 内联： 内联元素：不会再元素的周围插入换行。比如&lt;img&gt;、&lt;quote&gt;等 块元素：会在元素的两边插入换行 内容： 空元素：元素只有单个&lt;&gt;，不需要内容。比如：&lt;br&gt;、&lt;img&gt; 普通元素：元素有一对&lt;&gt;，需要添加内容，否则没有意义。 img是一个内联元素，且是一个空元素。 浏览器加载图像的规则是：先加载HTML网页，然后再加载图像。因此，可能会引起页面跳跃。建议提前设置图像的width 和height，提供结构信息。 HTML中过多的空白符会被简化为一个空格，换行必须使用&lt;br&gt;来完成。 HTML4.0语法规范： &lt;head&gt;元素是放置&lt;title&gt;、&lt;meta&gt;和&lt;style&gt;元素唯一合法的地方。 只能在&lt;body&gt;元素下直接放置块元素，所有内联元素和文本都必须包含在块元素中。 块元素禁止包含在&lt;p&gt;元素中 列表&lt;ul&gt;和&lt;ol&gt;中只允许直接放置&lt;li&gt;元素，其他元素不允许直接放置。 ul使用 如下样式展示： ol 使用如下样式展示： &lt;blockquote&gt;中应该先加入块元素，再加入文本。 XHMTL是一种格式规范。它采用xml的格式编写，使HTML更加规范化，且易于扩展。 格式规范要求： 把DOCTYPE改为XHTML。 在&lt;html&gt;标签中添加 xlmns、lang和 xml:lang 属性。示例：&lt;html xmlns=“http://www.w3.org/1999/xhtml” lang=“en” xml:lang=“en”&gt;. 确保&lt;html&gt;是DOCTYPE后第一个标记，且&lt;/html&gt;是最后一个标记。 所有的元素名称必须使用小写字母表示。 所有开始标记都必须有对应的结束标记。如果是空元素，那么它的标记必须以空格结尾，后跟/&gt;. 所有属性的值必须非空，且带有双引号。 优点： 严格规范的语法方便浏览器解析，以及不同浏览器取得统一的行为。 可以扩展新标记 只要能读取XML的程序，都可以直接解析HTML。 对移动设备的支持更好 高级布局部分： div元素：用于将多个块元素进行进行逻辑划分。 span：给内联元素的内容划分区域。 可以使用CSS盒模式编程。但是边界的话，只有左右两侧是有效的，而上下两侧是无效的。补白也是左右有效，上下侧则占用公共空间（即不影响该元素与其他元素之前的位置），会产生重叠效果。 表格元素： 表格的元素： &lt;table&gt;：表示这是一个表格，其内有有一个 summary 属性，这个属性可以设置表格的摘要，但是摘要完全不会再网页上显示出来，只是为了使表格更加可读。 &lt;caption&gt;:表格的标题 &lt;tr&gt;:表示这是表格的一行内容 &lt;th&gt;:表示这是表格的头行的标题单元格 &lt;td&gt;:表示这是普通单元格 HTML中表格采用的是基于行布局的模式。 请不要把表格和列表搞混了，后者是 &lt;ul&gt; 和 &lt;ol&gt;的内容。 表格的单元格的外貌设置类似于盒模式，内容区、补白、边框都一致，但是边界稍有不同。单元格的边界是不能单独设置的（即 margin 属性对于 th 或者 td 是无效的），而是整个表格统一设置一个表格间距，需要在 table 选择符的CSS 中设置该属性： border-spacing：10px 30px （前者为水平间距，后者为竖直间距） 在单元格元素中 使用rowspan 或者 colspan 添加 行合并 或者是 列合并。在有合并存在的表格中，合并表格的位置，在其设置之初就决定了，剩下的单元格只是单填充空格。 table不受 text-align 属性影响。 列表元素： 列表的元素： &lt;ul&gt;：无序列表 &lt;ol&gt;：有序列表 &lt;li&gt;：列表项 ul默认使用 如下样式展示： ol 默认使用如下样式展示： li 项的样式可以变的，可以在CSS中调整 list-style-type 属性： disc：实心圆点 circle：空心圆点 square：方块标志 None：无 …………多的是哦，反正在 webstorm上可以自动填充 也可以使用 list-style-image: url(xxxxx); 来指定自定义标识 表单元素： 在最外围使用 &lt;form action=“xxxxx.php” method=“POST”&gt;，里面的 action 属性指明了提交的url地址，method指明了 提交的方式。 我们可以将任意的块元素放入表单中。 交互表单元素： &lt;input type=“text” name=“xxxxx” maxlength=“100” /&gt;：文本输入框，name用于WEB程序提取值，可以设置输入字数限制,maxlength表示输入字符限制。 &lt;input type=“password” name=“xxxxx” maxlength=“100” /&gt;：密码输入框 &lt;input type=“submit” value=“name" /&gt;：确认按钮,value是按钮上显示的名字 &lt;input type=“reset” value=“name" /&gt;：重置按钮,value是按钮上显示的名字 &lt;input type=“radio” name=“xxxx” value=“xxx” checked=“checked” /&gt;：单选框，name相同的为同一个单选组，value可以各不相同. &lt;label for=“xxxx”&gt;:使用示例如下，但一般来说，我们会直接使用文本代替。 &lt;input type=“checkbox” name=“xxxx” value=“xxx” /&gt;：复选框，name相同的为同一个复选组 &lt;textarea name=“xxx” rows=“10” cols=“10”&gt;—初始化文本—&lt;/textarea&gt;：一个多行文本输入区，rows 和 cols告诉浏览器文本框的宽度和高度，以字符作为计数标准。 :选择列表及其选项。可以在 select中添加 multiple=“multiple”，是单选变成多选，但是不太好用，需要使用 ctrl或者command采用实现多选。 fieldset(控件组) 和 legend（传说） ：用来块状组合表单元素，示例如下：，效果如下： &lt;input type=“file” name=“xxx”&gt;：表示选择文件，该文件给将随着请求一起发送给服务端，这意味着我们必须采用POST方式。 在 &lt;input&gt;元素中 添加 checked=“checked”，表示默认选中状态。 布局方式： 采用CSS布局表单 采用表格布局表单 采用表格搭建表单位置框架，配合CSS调整表单外观（最佳方式） CSS部分： 功能定义：负责描述网页的样式。 基本语法： CSS规则需要写在&lt;head&gt;标签内，使用如下格式： 其中p表示的是 html的语法元素，这句话将整体的修改p元素的样式。 为多个元素定义同一套规则，可以使用“ , ”将多个元素分隔开来。例如： 元素的样式可以多次定义取其合集作为最终样式标准。 如果使用外部引用的CSS文件，那么需要使用link元素。例如：&lt;link type=“text/css” rel=“stylesheet” href=“./lounge.css” /&gt;，注意，link元素是一个空元素，需要在结尾加上“ /&gt;”才可。 type：表示信息的类型，此处表示是一个css文件。 rel：表示XHTML与需要链接的文件之间的关系，此处表示为 样式表。 href：表示被链接文件的地址。 样式链接冲突规则：后链接（优先）的相同选择符的属性将覆盖先链接的选择符的属性。 在单独的CSS文件内部，我们不要引入任何xhtml元素，只要完全按照css的语法编写即可。 可以为样式创建单独的子类，子类将继承父类元素（即主选择符，如果没有，那就是XHTML中上级元素）的属性。例如： 可以为所有选择符添加子类，包括未声明的。例如：。此时，所有的XHTML元素都可以使用 class=“greentea” 这一样式属性了，例如：&lt;p class=“greentea”&gt;…………&lt;/p&gt; 注意，一个元素可以加入多个样式类，比如：&lt;p class=“greentea raspberry biueberry”&gt;，此时三个类的样式将共同作用于该元素上。 样式使用冲突应用规则：当有多个类，以及继承关系上的属性存在冲突(非冲突元素将全部继承)时，将按照以下规则为内容选择样式： 在继承关系上，子类属性覆盖父类属性，子元素覆盖父元素。 优先级：具体子类 &gt; 模糊子类（.） &gt; 具体选择符 &gt; 该选择符的父元素 如果优先级相同，那么选择样式描述语句中最靠后的规则。 id的定义：当为全页面中唯一的元素添加样式时，最好选用id来保证互斥性。id的定义语法：。使用方法：例如&lt;h3 class="test3" id="testid"&gt;asncnqkwnxdqw xkqpwdxqw qkdxkdk&lt;/h3&gt;，在这个例子中，h3的背景颜色\文本颜色和下划线都显示了出来，即id和class是可以共存的。 类和id之间唯一的区别：id选择符只跟页面中一个元素匹配。（注意，此处的id与 XHTML中a元素的 id锚点 是同时生效的，也就是说他们成为了定位目标。） link和style元素都有一个 media 属性，该属性指明了该样式表应用于哪种设备。 设备通常可以分为 电脑屏幕、移动设备、打印机、电视、盲文等。 当使用 media 属性时，浏览器只在特定设备上启用相应的样式表。 如果没有指定 media 属性，那么样式表将作用于所有设备。 最好将应用于所有设备的样式表，放在前面，然后将特定设备的样式表放在后面。这样可以确保优先使用特定设备样式表内的属性。 可以特别的指定特定作用于的选择符，例如：.在这个例子中，cjf p比div p更加精确，将实行优先覆盖。这种空格隔开的表示，在最后一个空格前的容器内的特定孩子元素，使用相应的样式。 扩展（可以指定多层容器）：div blockquote p：{……} 表示在 div 容器下的 blockquote 容器内的 p孩子（可以是儿子、孙子或者曾孙等等），使用此样式。 CSS的基本元素叫选择符，其对应一个XHTML元素起作用。由于XHTML元素是树形层级结构，因此样式落实到某个具体的叶子节点是将会是叠加的（可以理解为是继承关系）。比如：，在这里面，p选择符和em选择符的样式将共同作用于 “qwlknlkqwndlkq”这段内容。如果是相同的样式属性，那么 em选择符的样式属性将覆盖 p选择符的样式属性。但是，并不是所有的元素都可以被继承，大体上，影响你文本外观的样式，比如字体颜色、字体以及字体样式等，都可以被继承。但是。例如边框这样的属性，就不可以被继承。 基本字体分类：（是按照样式划分族类的） Serif Family：衬线字体，字正方圆，一般用于报纸印刷。 Sans-serif family:无衬线字体，相比于衬线字体更具有可读性。 Monospace Family：等宽字体。 Cursive Family：手写字体。 Fantasy Family：趣味字体。 颜色空间的表示方式： 直接使用CSS内置的颜色属性，目前约17种。比如 yellow/green等。 使用 rgb( 80%,40%,0% )：分别代表 红色80%，绿色40%，蓝色0%。 使用 rgb( 80,102,0 )：分别代表 红色80，绿色102，蓝色0. 直接使用十六进制表示：#cc6600 CSS常见属性使用详解： width 和 height ：可以指定元素的大小，使用px作为单位，或者是相对于元素所在容器(比如div或body等)的百分比表示。块元素的width默认值是auto，将扩展到浏览器的边界，而高度将由内容与width计算后决定。显示设置宽度后，元素的大小不再随着浏览器的变化而变化。 text-align:内容对齐方式。 font-family:可以指定元素使用到字体。可以使用列表形式，将优先匹配前面的字体。例如：。在这个例子中，我们可以按照优先级列出我们想要使用的字体，一旦浏览器发现某一个字体可用，那就不再继续匹配。一般最后一个是一个字体族，以确保有可用字体。(注意对于包含空格的字体名，请使用”"包裹使用) font-size： 浏览器默认字体大小是16px。 字体大小描述： 使用px直接描述大小，比如 font-size：12px 使用%百分比，表示与父元素（父类）相比的差值。比如 font-size:150% 使用关键字描述大小，关键字如下：xx-small、x-small、small、medium和large、x-large和xx-large。基本上以20%的比例在递增，其中small通常定为12px。 网页字体设计规范技巧： 定义body的字体大小，最好选用关键字定义，方便与浏览器共进退。 用百分比描述其他子元素相对于body元素的字体大小。 font-weight：控制字体的粗细。有 normal 和 bold两种值。 font-style：可以选择为斜体，italic或者oblique表示斜体。 font-variant:设置字体的异体。取值有 normal 和 small-caps。其效果是缩放小写字母。 text-decoration：（线的长度与文本长度一致，这些值可以共存） underline：下划线 overline：顶部线 blink：闪烁，但基本无效 line-through：删除线 none：无装饰 color：定义了文本的前景颜色，包括文本颜色和边框颜色。 background-color：背景颜色 CSS盒模式： 内容区：一个大小与内容切边的区域，不会有留白。 补白（可选）：在内容区和边框之间的一层留白区域，四边的大小都是可控的。补白本身是透明的，没有颜色或者装饰。（但是可以显示背景色或者背景图像） 边框（可选）：围绕着补白的一条线。边框可以有各种宽度、颜色和样式。 边界（可选）：包围着边框，用于分隔开其他盒子。边界本身也是透明的，没有颜色或装饰。（但是可以显示背景色或者背景图像） 注意事项： 元素的背景色或者背景图像会延伸到补白底下，但不会到边界。 语法属性： border-color：边框颜色，可以单独指定。否则将使用color中的值。 line-height：定义文本行高度，可以像font-size一样，使用 px,%,em等来定义。扩大了每一行文本的高度。 border-color 和 border-top-color等：边框线的颜色 border-width 和 border-top-width等：边框线的宽度，使用px。也可以使用关键字，thin瘦，medium中等，thick厚。 border-style 和 border-top-style等：边框的样式。分为solid实线，dotted点线，double双线（内外两根，不同色），dashed虚线，groove凹框线，inset嵌入式框，outset凸框线，ridge突出边界样式。 可以使用一条语句完整的描述三个边框属性，比如： border:solid thin black;（style width color） border-bottom:dashed 6px #ff0000； padding 和 padding-left 等：使用px描述补白的宽度。注意，后设置的属性将覆盖先设置的同类属性的值。 margin 和 margin-left等：使用px描述边框的宽度。注意，后设置的属性将覆盖先设置的同类属性的值。 background-image:url(image/background.gif) 使用如上格式引入背景图片。（注意，背景图片更多的是起到背景装饰作用，其会与内容产生重叠。因此不可以代替&lt;img&gt;元素） background-repeat：设置是否重复元素。有以下几种取值：no-repeat、repeat-x、repeat-y、inherit。 background-position：决定背景图像的位置。 CSS常见缩写： padding：0px 20px 30px 40px（上，右，下，左） padding：20px（当四边元素都一样时使用） margin：0px 20px 30px 40px（上，右，下，左） margin：20px（当四边元素都一样时使用） border：solid 7px #007e7e（样式，宽度，颜色） background（背景）：white url(./sadasd/asd.gif) repeat-x（颜色，图片地址，重复） font：font-style font-variant font-weight font-size（必选）/line-height font-family（其他都是可选的，字体family里不同字体采用,隔开） 伪类：伪类的本质是覆盖浏览器自动生成的类。每一个伪类实际上是代表着一个具体的元素样式，可能与状态有关。 伪类的语法：例如 a:link{……} 常见的伪类：a:link、a:visited、a:focus、a:visited、a:hover、a:active 层叠样式表属性值确定方法：（以某一个元素的属性为例） 把所有样式表集中起来（作者、读者、浏览器） 找出和该元素属性相一致的属性规则定义 将符合的规则按照 作者 &gt; 读者 &gt; 浏览器 的方式排列 按照声明的 具体程度 来进行排序 具体程度的计算方式： 初始化三个数字： 0 0 0 如果这个选择符有id，那么每个id都使首位数字+1 如果这个选择符有类或者伪类，那么每个类都使中间的数字+1 如果这个选择符有元素名称，那么每个名称都使末位的数字+1 最后，数字越大的元素，优先级越高 当此时还有冲突时，按照他们在文件（引用文件）中出现的顺序来决定 然后，顺序中的第一个规则就是胜者。 在属性后面使用 !important 可以使该属性规则达到最优级别。例如：CSS在实际使用中，应该多用组合，少用继承，这样可以增加灵活性。比如使用&lt;div class="box fs-12 pd-20"&gt;this a clear color fontsize12px padding20px box&lt;/div&gt;，里面一共有 box、fs-12、pd-20 这3种自定义CSS类样式。CSS还支持多重继承，即 .box 类定义后， .box.gray 、 .box.red 样式也是可以被定义的。在具体使用时，例如&lt;div class=“box gray fs-12 pd-20"&gt;this a gray fontsize12px padding20px box&lt;/div&gt;。可以看出， 【box gray】是这种多重继承类的正确引用方法。 其他部分： 颜色空间使用建议： 文本和背景要使用高对比颜色以提高可读性，最高做到文本用深颜色，背景用浅颜色。 集合部分： 浏览器布局原则： 浏览器布局是采用流式原则放置元素。 块元素的布局顺序是从上至下，按照XHTML中的写法依次排列的。块元素之间有换行，每个块元素如果不指定width，那么默认占据上层元素全部的大小。（如果是浏览器，那就是全部的浏览器大小） 内联元素的布局顺序是在块元素的限制下，按照左上角至右下角的顺序依次填充的 相邻块元素之间的间距（主要是边界距离计算），是按照两个块元素较大一方的边界值来计算的，而不是累加的。 漂移布局要点：（这是浏览器布局的基础，即使使用其他布局，也是建立在流式布局的原则上的） 适用范围：主要表现为一部分与浏览器贴边，而页面的其他元素，需要随着浏览器的变化而变化自身的大小。 漂移元素被移出了正常的文档流，放到了左边或者右边。漂移的范围是相对于他的父元素而言的。 要漂移的元素的width必须是固定的，而填充在此处的另一个块元素，其大小就是浏览器宽度（就块元素本身而言，它是和漂移的块元素发生重叠的）。但是块元素里面的内容，会在触及漂移元素的边界时换行，最后的布局效果还是正确的。 要一个块元素发生漂移的起始位置，一定是在他在XHTML中上一个块元素的下面。且发生漂移的块元素的width一定是固定的。 而自动适应宽度的块元素，需要在发生漂移的块元素的下面。在实际的显示层级上，自适应宽度的块元素的宽度实际上一直等于浏览器宽度，只是内容元素的布局在遇到漂移漂移元素的边界时会换行。例如：，在这里面，漂移元素一直覆盖在自适应块元素的上面。 块元素漂移，需要设置 float:right/left ，注意，这个样式一般使用id来定义。 可以对块元素设置 clear:right | left 这两个属性，来确保不会有漂移元素在他们右边/左边/两边。避免覆盖是需要包含边界计算的。 在使用漂移布局时，有两种策略：左紧右松 和 左松右紧。他们的共同特点是 浮动层都在上面，而固定曾在下面。具体使用哪种，需要根据实际情况决定。需要注意的是，在小屏幕上，浮动层先于固定层显示，而不是在同一行显示。 冻结布局要点：（非常喜欢） 在body里创建一个固定大小的 div，并在里面进行主要元素的布局。 该 固定div的有以下必要元素是一定需要写的： width：一定要写具体值，确保固定布局 margin-left &amp;&amp; margin-right：auto。当把一个块元素的 width设置为auto时，浏览器会根据内容区的需要调整内容区的宽度。而当把边界设置为 auto时，浏览器会确保两边的边界是相等的，且计算出一个合适的大小。最终显示效果是内容区居中显示。 绝对布局要点：（比漂移布局优先） 一个新的属性 position，其有四个属性值。 static:将元素放到正常的文档流中参与流式布局。如果某个元素使用了 float 属性，那么他的本身不参与文档流的布局，但是其大小将会影响文档流中元素的内容区布局。 absolute：将元素从文档流中抽离，其他元素完全感受不到这个元素的存在。是完全哦！ fixed：使用的是相对于浏览器的固定位置布局，而absolute使用的是基于页面的固定位置布局。这意味着fixed将会固定停留在浏览器的某个位置上，即使我们滚动网页也不会消失。 relative:元素依然是文档流中的一部分，在参与完流式布局后，有了一个位置，然后再根据设置的相对位置属性，对元素进行偏移操作。 使用 top、right、bottom、left 这四个元素来指定这个元素的绝对位置。可以用 px指定绝对位置，或者是 百分比，指定相对关系。（注意，这也将形成一个黏着效果） 绝对布局的属性可以对 块元素 或者是 内联元素 使用，这一点上没有限制。但建议使用块元素&lt;div&gt; 包裹内联元素后再使用。 可以使用 z-index 指定同为 绝对布局的元素，在页面层级显示上的优先关系。 三种基础布局的比较： 漂移布局：主要涉及 float 属性，但是他要求漂浮元素在HTML中的顺序需要先于固定元素，这在小屏幕设备上将造成困扰。 冻结布局：外围 使用 div 创建一个固定的大小，所有元素都在这个固定大小内实现布局。 绝对布局：可以将漂浮元素变成绝对布局元素，来达到我们的显示要求。但是此时在小设备上，将会产生覆盖，且由于 clear属性的失效，对于绝对布局元素的边界处理时非常困难的。 综上所述，我个人还是最喜欢 冻结布局。 固定布局要点： 这是一种相对于浏览器的布局方式。 需要将 position 属性置为fixed，被设置的元素也完全从文件流中移除。 剩下的就是设置 top、left、bottom、right这四个属性 相对布局要点： 相对布局是在流式布局完后，对使用了相对布局的元素，根据他们设置的属性，使他们发生相对于当前位置的偏移。 相对布局的元素首先需要参与流式布局，然后进行微调。 需要把 position属性设置为 relative 剩下的就是设置 top、left、bottom、right这四个属性 它和直接调整补白和边界相比，后者你无论如何调整，都是无法把一个元素放到它所处的盒子外面，但是这个可以。 附注内容： 更多的CSS选择符： 伪类选择符： p:first-letter : 段落的首个字符 p:first-line ： 段落的首行 属性选择符： 基于兄弟的选择符：h1+p{ ….} 表示对一个紧跟着h1的段落使用CSS属性。 组合选择符： .blueberry p{}:表示选择了blueberry类的一个元素的子孙段落。 div#greentea &gt; blockquote p:first-line 框架，支持划分页面，引入第三方页面展示，但是不被 W3C建议。 使用 Object 完成多媒体的播放。 搜索引擎建议： 提高你的排序：主要是 描述 和 关键字 组织搜索引擎： 关于打印的样式表编写建议： 文本背景颜色设置为白色 建议使用 serif 字体族 建议隐藏导航菜单栏、工具条以及其他无关、辅助内容等，使用CSS的 display:none即可 注意固定宽度的元素，可能不适合打印]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript常见问题学习指南]]></title>
      <url>%2F2017%2F02%2F09%2FJavaScript%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[JavaScript常见问题学习指南判断一个对象是否是string：(obj instanceof String || obj.constructor == String) ：返回YESjson对象内的元素默认是string类型【非String类型】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript权威指南：第6版，ECMAScript5和HTML5]]></title>
      <url>%2F2017%2F02%2F09%2FJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%EF%BC%9A%E7%AC%AC6%E7%89%88%EF%BC%8CECMAScript5%E5%92%8CHTML5%2F</url>
      <content type="text"><![CDATA[JavaScript权威指南：第6版，ECMAScript5和HTML5注意：本文所有的样式展示均采用 chrome mac 2016/07 最新版编写。JavaScript语言基础：特有关键字：delete：作用：用于删除一个对象的某一属性。语法为：delete aa.xxx ，如果表达式不为某一对象属性的引用，则语句无效。删除属性只能删除自有属性，不能删除继承属性。而且当一个对象的属性被删除时，是对象的同一原型的所有对象的这一属性都将被删除。具体解释：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/deletetypeof：作用：typeof操作符返回一个字符串,指示未经计算的操作数的类型.用法为：typeof operand，operand 是一个表达式，表示对象或原始值，其类型将被返回。具体解释：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof返回类型示例： 类型结果Undefined"undefined"Null"object" (见下方)Boolean"boolean"Number"number"String"string"Symbol (ECMAScript 6 新增)"symbol"宿主对象(由JS环境提供)Implementation-dependent函数对象 ( [[Call]] 在ECMA-262条款中实现了)"function"任何其他对象"object"debugger：认为的在代码中添加断点。用法：直接在某一行添加 debugger 即可。with：用于设置代码在特定对象中的作用域。例如：var sMessage = "hello"; with(sMessage) { alert(toUpperCase()); //输出 "HELLO" }在这个例子中，with 语句用于字符串，所以在调用 toUpperCase() 方法时，解释程序将检查该方法是否是本地函数。如果不是，它将检查伪对象 sMessage，看它是否为该对象的方法。然后，alert 输出 "HELLO"，因为解释程序找到了字符串 "hello" 的 toUpperCase() 方法。提示：with 语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。in：检测对象中是否存在某一属性。用法： 属性名字符串/索引 in 对象名。instanceof ： 测试某一个对象是否是一个特定类的实例。用法： 对象名 instanceof 特定类对于一些基本类型无法做判断，比如string【String是其封装形式】。关于原型对象以及原型对象创建的对象的讨论：当使用原型对象创建对象后，创建的对象修改继承属性只会影响自己。但是如果原型对象修改属性，会影响由他创建的所有对象。原型创建与继承不同。问题列表：关于宿主对象的讨论？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript学习笔记]]></title>
      <url>%2F2017%2F02%2F09%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[JavaScript学习笔记 HTML 中的脚本必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间。 脚本可被放置在 HTML 页面的 &lt;body&gt; 和 &lt;head&gt; 部分中。 您可以在 HTML 文档中放入不限数量的脚本。 脚本可位于 HTML 的 &lt;body&gt; 或 &lt;head&gt; 部分中，或者同时存在于两个部分中。 通常的做法是把函数放入 &lt;head&gt; 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。 上面例子中的 JavaScript 语句，会在页面加载时执行。 通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。 如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。 您将在稍后的章节学到更多有关 JavaScript 函数和事件的知识。 也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。 外部 JavaScript 文件的文件扩展名是 .js。 如需使用外部文件，请在 &lt;script&gt; 标签的 "src" 属性中设置该 .js 文件。外部脚本不能包含 &lt;script&gt; 标签。 如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。 请使用 "id" 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容： 请使用 document.write() 仅仅向文档输出写内容。 如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。 JavaScript 对大小写是敏感的。 JavaScript 使用 Unicode 字符集。 JavaScript 中，常见的是驼峰法的命名规则，如 lastName (而不是lastname)。 分号用于分隔 JavaScript 语句。 通常我们在每条可执行的语句结尾添加分号。 使用分号的另一用处是在一行中编写多条语句。您也可能看到不带有分号的案例。 在 JavaScript 中，用分号来结束语句是可选的。 JavaScript 会忽略多余的空格。您可以向脚本添加空格，来提高其可读性。 如果重新声明 JavaScript 变量，该变量的值不会丢失： 在以下两条语句执行后，变量 carname 的值依然是 "Volvo"： var carname="Volvo"; var carname; 数据类型：字符串（String）、数字(Number)、布尔(Boolean)、数组(Array)、对象(Object)、空（Null）、未定义（Undefined）。可以使用 typeof 操作符（加粗的为可能返回结果）来检测变量的数据类型。 在JavaScript中，数组是一种特殊的对象类型。 因此 typeof [1,2,3,4] 返回 object。用 typeof 检测 null 返回是object。 在 JavaScript 中, undefined 是一个没有设置值的变量。 typeof 一个没有值的变量会返回 undefined。任何变量都可以通过设置值为 undefined 来清空。 类型为 undefined. typeof "John" // 返回 string typeof 3.14 // 返回 numbertypeof false // 返回 booleantypeof [1,2,3,4] // 返回 objecttypeof {name:'John', age:34} // 返回 object fullName()是一个函数，如果你要访问 person 对象的 fullName 属性，它将作为一个定义函数的字符串返回：function () { return this.firstName + " " + this.lastName; } 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 JS函数的参数不需要声明类型，直接使用function mytest( name , job ) HTML 事件可以是浏览器行为，也可以是用户行为。 以下是 HTML 事件的实例： HTML 页面完成加载 HTML input 字段改变时 HTML 按钮被点击 通常，当事件发生时，你可以做些事情。 在事件触发时 JavaScript 可以执行一些代码。 两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串 字符串也可以使用不等号比较，使用首个相等字母的ascii码作为比较结果。 可以对 JavaScript 语句进行标记。 如需标记 JavaScript 语句，请在语句之前加上冒号： Undefined 和 Null 的区别 typeof undefined // undefinedtypeof null // objectnull === undefined // false，值相等，但数据类型不同null == undefined // true，值相等 JavaScript 数据类型 在 JavaScript 中有 5 中不同的数据类型： string number boolean object function 3 种对象类型： Object Date Array 2 个不包含任何值的数据类型： null undefined constructor 属性返回所有 JavaScript 变量的构造函数。你可以使用 constructor 属性来查看是对象是否为数组 (包含字符串 "Array”)：function isArray(myArray) { return myArray.constructor.toString().indexOf("Array") &gt; -1; } 一元运算符 + Operator + 可用于将变量转换为数字：如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字): 当 JavaScript 尝试操作一个 "错误" 的数据类型时，会自动转换为 "正确" 的数据类型 5 + null // 返回 5 because null is converted to 0"5" + null // 返回"5null" because null is converted to "null""5" + 1 // 返回 "51" because 1 is converted to "1" "5" - 1 // 返回 4 because "5" is converted to 5 自动转换为字符串 当你尝试输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法. 正则表达式是由一个字符序列形成的搜索模式,正则表达式可以是一个简单的字符，或一个更复杂的模式: 实例解析：var patt = /w3cschool/i /w3cschool/i 是一个正则表达式。 w3cschool 是一个模式 (用于检索)。 i 是一个修饰符 (搜索不区分大小写)。 在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。 search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 然后，使用 JavaScript 内置函数 JSON.parse() 将字符串转换为 JavaScript 对象: var obj = JSON.parse(text); javascript:void(0) 中最关键的是 void 关键字， void 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值。 href="#"与href="javascript:void(0)"的区别 # 包含了一个位置信息，默认的锚是#top 也就是网页的上端。 而javascript:void(0), 仅仅表示一个死链接。 在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id。 如果你要定义一个死链接请使用 javascript:void(0) 。 JavaScript 函数可以通过一个表达式定义。 函数表达式可以存储在变量中var x = function (a, b) {return a * b}; var z = x(4, 3); 参考文档：http://www.runoob.com/js/js-syntax.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Charles HTTPS抓包]]></title>
      <url>%2F2017%2F02%2F09%2FCharles%20HTTPS%E6%8A%93%E5%8C%85%2F</url>
      <content type="text"><![CDATA[Charles HTTPS抓包由于目前使用的版本在3.10以上，可以直接在菜单栏的help中找到 SSL Setting，里面有完善的设置。 只要在移动设备以及自己的mac上装上相同的根证书，那么就可以抓取所有的https的包并且读取里面的内容。基本操作：移动设备：通过连接上Charles代理浏览器访问chls.pro/ssl安装并信任证书Mac主机：导出Charles的SSL证书【pem文件】双击安装到KeyChain在KeyChain中搜索到该文件，并选中-显示简介-信任-始终信任输入密码并保存即可因为在mac上chrome直接使用的是系统的keychain，所以执行一次这种操作即可。 下面解释一下它是怎么做的，以及目前这么做存在什么缺陷： ---------------------------------------------------------------------------------------------------------------------------- 简单的说就是中间人攻击，也就是“man-in-the-middle attack” 先来看一下charles的document： “Charles can be used as a man-in-the-middle HTTPS proxy, enabling you to view in plain text the communication between web browser and SSL web server. Charles does this by becoming a man-in-the-middle. Instead of your browser seeing the server’s certificate, Charles dynamically generates a certificate for the server and signs it with its own root certificate (the Charles CA Certificate). Charles receives the server’s certificate, while your browser receives Charles’s certificate. Therefore you will see a security warning, indicating that the root authority is not trusted. If you add the Charles CA Certificate to your trusted certificates you will no longer see any warnings – see below for how to do this.” 先说一下https使用的非对称加密的原理。等等说非对称加密之前还要说下对称加密的原理。简单来说，对称加密就是加密解密使用同一个密钥。浏览器和服务器交互的话一般会动态生成一个密钥，所以密钥如何交换就成了问题。 下面引入非对称密钥，非对称加密主要用于密钥交换（也叫密钥协商），能够很好地解决这个问题。浏览器和服务器每次新建会话时都使用非对称密钥交换算法协商出对称密钥，使用这些对称密钥完成应用数据的加解密和验证，整个会话过程中的密钥只在内存中生成和保存，而且每个会话的对称密钥都不相同（除非会话复用），中间者无法窃取。 密钥交换过程：服务器的公钥是公开的，私钥是不公开的。浏览器先向服务器取得公钥，然后用公钥加密自己的私钥连同自己私钥加密的请求一并发送给服务器。服务器使用自己私钥解密得到浏览器的私钥，使用浏览器的私钥解密请求。然后再用浏览器的私钥加密response发送回服务器。 中间人攻击是先伪装服务器向浏览器发送伪造的公钥，从而取得浏览器的私钥。这样就完成的浏览器端的解密。服务器端类似。 但是！！！https是可以防止中间人攻击的，因为服务器的公钥是用证书的。charles伪造的证书一般浏览器会警告，所以我们需要将charles的证书认为可靠的。从而实现中间人。 关于iOS 9的无法使用Charles抓包的问题。 SSL Proxying with iOS 9 You need to disable App Transport Security in your app to use Charles SSL Proxying with apps running on iOS 9. To disable ATS you need to add keys to your app's Info.plist file, as below. See this tech note from Apple for more information. You must remember to re-enable ATS before you release your app to take advantage of the security that ATS provides. &lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; Note that this means that you cannot use Charles to observe SSL traffic from apps that you do not control. ref： FAQs • Charles Web Debugging Proxy About ATS：Cocoa Keys 简单地说，iOS的ATS是一种对安全的加强。在About ATS里面我们可以看到ATS对证书的一些限制。现在无法使用Charles，则是因为iOS 9 认为这个连接不安全，目前的解决方案是禁用ATS。长远来看，要么Charles的证书能够是ATS眼中的『安全证书』，要么ATS自己修改spec将Charles的证书认为是安全的，但是这两种方法目前看来可能还需要一段时候。 常见问题： 问题描述：SSL Proxying not enabled for this host: enable in Proxy Settings, SSL locations 解决方案： 方案一：对你需要抓取的ssl网址，在列表中选中，然后右键 Enable SSL Proxying. 方案二：对所有SSL网址都进行抓取，则在 Proxy - SSL Proxying Setting - SSL Proxying中添加 *：443.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HomeBrew的常用命令]]></title>
      <url>%2F2017%2F02%2F09%2FHomeBrew%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[HomeBrew的常用命令顺便贴一些最常用 Cheatsheet：安装（需要&nbsp;&nbsp;Ruby）：ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)" 搜索：brew search mysql查询：brew info mysql&nbsp;&nbsp;主要看具体的信息，比如目前的版本，依赖，安装后注意事项等更新：brew update&nbsp;&nbsp;这会更新&nbsp;&nbsp;Homebrew&nbsp;&nbsp;自己，并且使得接下来的两个操作有意义——检查过时（是否有新版本）：brew outdated&nbsp;&nbsp;这回列出所有安装的软件里可以升级的那些升级：brew upgrade&nbsp;&nbsp;升级所有可以升级的软件们清理：brew cleanup&nbsp;&nbsp;清理不需要的版本极其安装包缓存常用的就这些。一般来说如果你追求新版本（不升级不舒服斯基），那么你最常用的操作序列就是这样：brew&nbsp;&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;更新&nbsp;&nbsp;Homebrew&nbsp;&nbsp;的信息 brew&nbsp;&nbsp;outdated&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;看一下哪些软件可以升级 brew&nbsp;&nbsp;upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;如果不是所有的都要升级，那就这样升级指定的 brew&nbsp;&nbsp;upgrade;&nbsp;&nbsp;brew&nbsp;&nbsp;cleanup&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;如果都要升级，直接升级完然后清理干净 常见问题：如果在brew上下载不了 正常的应用，那么在下载其包后，在bin目录下将该 可执行文件 移动到&nbsp;&nbsp; usr/local/bin/ 即可执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Fiddler使用指南]]></title>
      <url>%2F2017%2F02%2F09%2FFiddler%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Fiddler使用指南Fiddler-HTTPS抓包功能开启以及安装：菜单栏 - Tools - Telerik Fiddler Options选择HTTPS栏： 勾选上Capture HTTPS Connect勾选上Decrypt HTTPS Traffic勾选Ignore Server CER Error[建议]下拉按钮内的选项需要确保 Remote Client是可以被接受的。旁边有个Action，选择 Export Root CER to Desktop在桌面可以看到一个.cer证书证书安装到设备使用如下方案： 在ios9及以上系统，可以通过将该文件Airdrop到设备上，然后选择 接受-安装，即可。在ios8及以下设备，需要使用发一封邮件，将.cer作为附件的方式，然后在邮件内点击证书，之后 安装 即可。【可能有其他方案，但我一直是这么做的】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github Pages博客搭建]]></title>
      <url>%2F2017%2F02%2F09%2FGithub%20Pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[Github Pages博客搭建基本思路：使用Github Pages + Hexo + 具体主题完成博客搭建。参考文章：入门Demo文章：https://fzy-line.github.io/2016/11/30/Github-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/【可行性搭建】Hexo操作文章：https://hexo.io/zh-cn/docs/index.htmlNext主题配置文章：http://theme-next.iissnan.com/getting-started.html其他技能：由于网站上的图标都使用Font Awesome Icon【一个图标集合网站】，只要写上具体的 Icon在这个网站上的名字，就可以从网络上下载到这个icon。比如weibo【微博】，github【github】等。 Font Awesome简介：就是将无数小图标，视为字体，然后合成为一个字体库，最后用加载字体的方式加载图标。且由于图标时矢量的，所以可以接受任意缩放效果。 参考文章：http://www.frontopen.com/2145.html建议http://fontawesome.io/icons/直接在这个网站上搜索即可但有时候网站上面有的东西，但是本地却展示不了，那就代表本地的 font awesome的字体库里没有这个图标，毕竟图标是实时更新的。在网站上搜索时，注意要避开New Icons，因为图标字体库是随着HEXO版本更新的，hexo可能还没有及时的更新到最新库。【Web Application Icons】这个部分的Icon一般都是有的。博客文章使用 markdown 语法编写。 在http://www.appinn.com/markdown/网站可以学习到 markdown 的基本语法。由于Github Pages的免费空间只有300M，那么建议图片可以放到 外部云盘，然后通过链接的方式分享过来。注意事项：在 全局配置文件 和 主题配置文件 中，都是可以使用本地资源的。但是本地需要使用路径写明。 所有的资源路径必须是以 ‘/‘ 开头的，而&nbsp;&nbsp;全局配置文件 和 主题配置文件 的位置是不同的。全局配置文件：root文件夹是 hexo 中的 source 文件夹。主题配置文件：root文件夹是 自己主题文件夹中的 source 文件夹。Hexo常见命令：部署相关： $ hexo clean&nbsp;&nbsp; #清除缓存 网页正常情况下可以忽略此条命令 &nbsp;&nbsp;$ hexo generator&nbsp;&nbsp; #生成静态页面至public目录 【缩写：hexo g】【可选】$ hexo server &nbsp;&nbsp;#本地测试【缩写：hexo s】$ hexo deploy&nbsp;&nbsp; #将.deploy目录部署到GitHub【缩写：hexo d】新建文章： hexo new: 标准格式：hexo new 【scaffolds_type】 【名字】新建侧边栏内容，比如categories、about、tags等：hexo new page 【名字】新建文章：hexo new post 【名字】新建草稿：hexo new draft 【名字】其中的 post 、 page 和 draft 都是 scafflods 文件夹下预配置的文件格式，其中侧边栏大类使用 page ，文章使用 post。当然，我们也可以引入更多的格式以及修改默认格式。其他命令： hexo help： 显示帮助hexo init：新建一个hexo仓库hexo config：获取和设置配置【建议在_config.yml中直接修改】hexo publish: 将草稿从 _drafts 移动到 _post，这意味着公开。hexo list：获取某一项的信息hexo version：版本信息文件夹作用：source：这是文件和资源的根目录。在配置文件中以 "/" 的地址均为这个目录。 _posts：普通的文章存放在此目录中_draft：草稿内容，不公开自定义侧边栏文件夹：【需要使用 hexo new page xxx 创建】 adout：介绍信息categories：分类信息tags：标签信息scaffolds：模板文件夹。默认有三个模板： draft.md：草稿模板page.md：侧边栏模板post.md：文章模板thems：主题文件夹，里面的每个文件夹都是一个主题。 主题配置默认会覆盖全局配置_config.yml：配置文件public【不可修改】：由hexo自己控制，生成的最终文件保存在此处。package.json【不可修改】 ：版本控制信息db.json【不可修改】 ：未知node_moudules【不可修改】 ：依赖的代码网络不佳时的尝试：网络通畅时，部署不会超过10分钟。但我们不要急于关闭终端，因为在网络传输结束后，还需要一点时间等待响应。可以考虑在 https 和 git 之间切换上传方式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git使用指南]]></title>
      <url>%2F2017%2F02%2F09%2FGit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Git使用指南获取git build号的操作：git获取build的方式： git&nbsp;&nbsp;rev-list&nbsp;&nbsp;--count&nbsp;&nbsp;HEAD &nbsp;&nbsp;，可以生成和SVN类似的计数码。我们在填写project的 build号时需要用到git tag的使用方式：当使用git打下标签后，我们可以方便的根据标签回到当时打下标签的状态，具体操作分为一下两种：终端操作方式：先&nbsp;&nbsp;git&nbsp;&nbsp;clone&nbsp;&nbsp;整个仓库，然后&nbsp;&nbsp;git&nbsp;&nbsp;checkout&nbsp;&nbsp;tag_name&nbsp;&nbsp;就可以取得&nbsp;&nbsp;tag&nbsp;&nbsp;对应的代码了。但是这时候&nbsp;&nbsp;git&nbsp;&nbsp;可能会提示你当前处于一个“detached&nbsp;&nbsp;HEAD"&nbsp;&nbsp;状态，因为&nbsp;&nbsp;tag&nbsp;&nbsp;相当于是一个快照，是不能更改它的代码的，如果要在&nbsp;&nbsp;tag&nbsp;&nbsp;代码的基础上做修改，你需要一个分支：git&nbsp;&nbsp;checkout&nbsp;&nbsp;-b&nbsp;&nbsp;branch_name&nbsp;&nbsp;tag_name（建议方式）。这样会从&nbsp;&nbsp;tag&nbsp;&nbsp;创建一个分支，然后就和普通的&nbsp;&nbsp;git&nbsp;&nbsp;操作一样了。sourceTree直接操作方式：有一个 “检出”的按钮 ，在其上选择一个提交，弹出警告框直接确认即可。这步操作相当于 上面的建议方式，会新建一个分支出来继续操作。在你切换回去的时候，会默认删除这个分支。.gitinore的配置问题：（git仓库忽略文件设置）在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件(该文件位置在该git项目的根目录上，与.git同级)的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：?1234567# 此为注释 – 将被 Git 忽略&nbsp;&nbsp;*.a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 忽略所有 .a 结尾的文件!lib.a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 但 lib.a 除外/TODO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件（未被track的定义是未加入到仓库中，即使处于工作区，也是未track的），如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：?123git&nbsp;&nbsp;rm&nbsp;&nbsp;-r&nbsp;&nbsp;--cached&nbsp;&nbsp;.git&nbsp;&nbsp;add&nbsp;&nbsp;.git&nbsp;&nbsp;commit&nbsp;&nbsp;-m&nbsp;&nbsp;'update&nbsp;&nbsp;.gitignore'git分支合并操作处理：主要针对projectFile讨论，其他冲突比较简单，直接处理即可：（要对projectFile进行差异化比较，单纯使用sourceTree自带的FileMerge是不够的，最好额外安装一个 Axisa Merge软件，并在偏好设置中将其设为 merge和compare的工具）首先逐个检查冲突项，一般资源文件则全部保留，证书文件只要保留一份即可。如果这样做了还是无法打开项目，可能是两个分支分别创建了一个同名的类或者是同名的资源文件，删除它，再引入即可。（这个最好在项目开始的时候，就通过命名规范来规避掉它）如果以上办法都不行，那么只能取一个分支为准，然后把另一个分支上的所有修改都移植过去。合并不同分支的方法：（命令行方式）具体分为 merge 和 rebase 两种方法，具体内容请参考：http://blog.csdn.net/wh_19910525/article/details/7554489&nbsp;&nbsp;。推荐使用 rebase 方法，否则时间线会乱掉，很难追溯哪一次提交导致仓库变动。在合并时，git会现将文件进行比对，内容一致的地方会被直接跳过。只有内容不一致的地方，且处于同一个插入点上时，才会产生冲突处理。因此，如果我们在两个分支上对同一处代码进行相同的修改，是不会导致冲突的，这对配置文件来说尤为重要。如果我们在两个地方进行相同的配置文件修改，那么合并时会自动保留一份，而不是两份。仅当我们在同一个插入点的修改是不一致时，才会引发冲突，且git会尽量减少冲突的范围，先合并相同行，再划分冲突。SourceTree使用帮助：当直接从别人电脑上copy库时，默认提交人会是那个人。我们需要在工作副本，提交栏左侧的那个头像处点击，然后选择成我们自己方可正常提交。使用sourceTree查看选中项的修改日志时，修改内容可能显示不完整。git异常合集：git状态不一致，无法推送的解决方案：当git状态不一致时，存在无法推送的情况，此时需要 执行命了 git gc 。清理本地缓存之后，即可正常的pull 和 push。也可以选择删除本地分支后全部重新拉取，但会丢失部分更改且耗时较旧，不推荐使用。git clone error:RPC failed;result=56,HTTP code=200错误解决： 原因：Maximum&nbsp;&nbsp;size&nbsp;&nbsp;in&nbsp;&nbsp;bytes&nbsp;&nbsp;of&nbsp;&nbsp;the&nbsp;&nbsp;buffer&nbsp;&nbsp;used&nbsp;&nbsp;by&nbsp;&nbsp;smart&nbsp;&nbsp;HTTP&nbsp;&nbsp;transports&nbsp;&nbsp;when&nbsp;&nbsp;POSTing&nbsp;&nbsp;data&nbsp;&nbsp;to&nbsp;&nbsp;the&nbsp;&nbsp;remote&nbsp;&nbsp;system.&nbsp;&nbsp;For&nbsp;&nbsp;requests&nbsp;&nbsp;larger&nbsp;&nbsp;than&nbsp;&nbsp;this&nbsp;&nbsp;buffer&nbsp;&nbsp;size,&nbsp;&nbsp;HTTP/1.1&nbsp;&nbsp;and&nbsp;&nbsp;Transfer-Encoding:&nbsp;&nbsp;chunked&nbsp;&nbsp;is&nbsp;&nbsp;used&nbsp;&nbsp;to&nbsp;&nbsp;avoid&nbsp;&nbsp;creating&nbsp;&nbsp;a&nbsp;&nbsp;massive&nbsp;&nbsp;pack&nbsp;&nbsp;file&nbsp;&nbsp;locally.&nbsp;&nbsp;Default&nbsp;&nbsp;is&nbsp;&nbsp;1&nbsp;&nbsp;MiB,&nbsp;&nbsp;which&nbsp;&nbsp;is&nbsp;&nbsp;sufficient&nbsp;&nbsp;for&nbsp;&nbsp;most&nbsp;&nbsp;requests.解决方案： git config --global http.postBuffer xxxxxxxxx(例如52428800，尽量大就好)。而且要让 souceTree的git版本使用系统版本。这样可以维持一致。最后，如果不行，可以使用git 终端下载分支，再使用sourceTree绑定本地分支。解决方案：使用brew重新安装git，且brew安装后，git版本会自动切换过去，不需要再去手动设置。 （该方法目前无法完美解决问题）还是不行的话，可能是DNS解析存在问题，可以手动修改host文件，绑定域名与IP地址的关系，可以解决这个问题。（目前京东git是这种情况）git本地仓库添加到远端方案：在远端建立好仓库，获得地址：address1在本地仓库中，点击push，在推送到仓库中选择自定义：address1一个分支一个分支的推。 如果当前仓库中的分支在远端仓库中已经存在同名仓库，那么建议在本地新建一个别名分支，然后再推送到远端。然后在远端仓库将别名分支与同名分支合并即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac使用指南]]></title>
      <url>%2F2017%2F02%2F09%2FMac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Mac使用指南常见问题： mac快捷方式创建： command + option + 鼠标拖动，生成的快捷方式会带有箭头标志。 Finder隐藏文件显示操作： 显示隐藏文件：defaults write com.apple.finder AppleShowAllFiles -bool true 不显示隐藏文件：defaults write com.apple.finder AppleShowAllFiles -bool false ，需要重启Finder才能生效。 软件取消更新：在 launchpad界面长按该软件，当出现删除图标时，点击删除并确认，即可取消更新。 使用Airdrop向手机分享文件：使用Airdrop分享文件时，当接收成功，文件需要有一个应用来打开，然后文件会临时缓存在某个文件夹中，如果在接收时选择了应用来打开它，那么就会转移到应用文件夹下面，并永久的保存。否则，你将失去这个文件的可见性，并在下次重启手机时，该文件在物理上被删除。 KeyNote投影指南： 显示屏投影模式分为两种：（可以在排列中更改设置） 镜像模式：自己桌面是什么样子，那么投影仪投放也是什么样子。 双屏幕模式：即投影仪扩展为自己的第二屏幕，可以在排列中设置，在这里变动时，可以更改投影仪相对于自己屏幕的位置，到时候只要把相关界面直接拖放到投影仪上即可。 投影仪缩放模式，有些屏幕的分辨率较高，超过投影仪所能承受的极限，就导致投影仪和屏幕出现闪烁现象，为此，我们需要将显示屏的分辨率调低，以适应投影仪。（即显示-缩放-720P） keyNote有专门的演示者模式，可以使主屏幕 和 投影仪 显示两个不同的画面，可以在 播放 中打开。 keyNote可以添加演讲者注释， 可以在 显示 中打开。 Mac键盘符号表：（可以在 系统菜单栏中，选中输入法按钮（原生的），选择 显示虚拟键盘 即可看到。）Mac rootless机制：介绍文章：https://segmentfault.com/a/1190000003751923作用：保护电脑的最后一道防线，通过降低root用户的权限来提升电脑的安全性。关闭/开启机制： 在电脑开机时，按住 command + R 打开终端 输入 csrutil disable / enable 在打开后，建议及时关闭，以保护电脑不受侵害。Mac硬盘容量不足解决方案： 删除不用的app程序（作用不大） 删除Xcode - Windows - Originize 里的所有 Archiver文件，大约可以释放10GB+。 （最佳方案）使用OmniDiskSweeper定位文件消耗根源。通常可以在以下几个地方发现硬盘消耗点： ~/Library/Containers:包含程序的缓存文件。可以在里面找找有没有已删除应用的文件。 ~/Library/Developer/Xcode/DriverdData:Xcode对以往所有打开项目的处理缓存。（随便删，占比极高） 参考文章：http://www.cnblogs.com/weilaikeji/p/3395614.html ~/Library/Developer/Xcode/xxx DeviceSupport：Xcode对所有已连接设备的符号表的缓存。（最好不要删） 然后再大致看一遍每一个文件夹下的硬盘大户是否属于已删除的app，回收一遍硬盘即可。 查看文件编码的方式：用vim打开文件，然后输入 :set fileencoding，输出即为当前文件的编码方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XX-Net使用指南]]></title>
      <url>%2F2017%2F02%2F09%2FXX-Net%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[XX-Net使用指南 github地址：https://github.com/XX-net/XX-Net 其内包含使用教程和配置方法 配置完成后终端需要一直打开 使用 start.command 打开应用，选择 Enable auto GAEProxy 可以兼顾国外网站和国内网站的顺畅性。 该工具源于 GOAgent ，搭建一个中间服务器，本地client将数据包发送给中间服务器，然后中间服务器与目标主机通信，最后将数据返回给源主机。 该工具的关键在与其会扫描可用IP地址，然后通过这些IP地址发起与中间服务器的连接（毕竟IP地址黑名单也是存在遗漏情况的，且不同地区的IP地址黑名单情况也不一致）。 GFW的实现原理： IP地址黑名单（存在遗漏问题，以及设备覆盖不全的问题） 内容审查：扫描HTTP数据包内的数据，发现敏感数据后向双方发送TCP重置数据包，达到断开连接的目的。 DNS污染：有多重污染方式，对于国内DNS服务器采取缓存污染策略，对于国外返回的DNS响应进行篡改。 具体实现原理可以参考：GFW的实现原理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode工程 整体arc转换]]></title>
      <url>%2F2017%2F02%2F09%2FXcode%E5%B7%A5%E7%A8%8B%20%E6%95%B4%E4%BD%93arc%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[Xcode工程 整体arc转换操作步骤：使用 Edit &nbsp;&nbsp;-> &nbsp;&nbsp;Convert &nbsp;&nbsp;-> To Objective-C ARC ，选择需要转换的文件对于勾选的文件，那么 将自动帮你做 arc 转换。比如删除 release、retain和autorelease，以及将retain属性变为strong，dealloc函数中 super调用删除。但要注意的是，如果有些语句是在宏中定义的，那么xcode无法自动处理，需要我们逐一修改。（通常直接修改宏即可）对于未勾选的文件，那么将帮你 加上 -fno-objc-arc 这一标志位。整个项目的arc配置将在你执行这一步操作之后，变为 YES。注意事项：在任何配置下，为文件添加&nbsp;&nbsp;-fno-objc-arc 或者 -f-objc-arc 都是合法的，只是有没有作用的区别。转换后需要检查宏是否转换正常。在内存转换过程中，类定义的实例变量定义可能是最容易出错的地方。&nbsp;&nbsp;对于原MRC文件里类内定义的&nbsp;&nbsp;实例变量（非属性声明方式），原来的内存管理语义相当于&nbsp;&nbsp;__unsafe_unretained&nbsp;&nbsp;，但是转化为ARC后，相当于变为了&nbsp;&nbsp;strong。&nbsp;&nbsp;这里会产生一些错误，比如&nbsp;&nbsp;某些代表delegate含义的变量在转换后将会形成循环引用，（比如&nbsp;&nbsp;controller.m中的rootDelegate&nbsp;&nbsp;和&nbsp;&nbsp;NetworkAPI中的delegate&nbsp;&nbsp;均会出现此情况）。 请大家多使用&nbsp;&nbsp;leaks&nbsp;&nbsp;的&nbsp;&nbsp;cycles&nbsp;&nbsp;&&&nbsp;&nbsp;roots&nbsp;&nbsp;工具检测（检测循环引用的工具）。参考文章：http://www.cocoachina.com/ios/20140912/9605.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS图片加载与显示优化指南]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%98%BE%E7%A4%BA%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[iOS图片加载与显示优化指南图片资源有着多种不同的加载方式：缓存加载方式：当使用该方式时，加载的图片会被自动缓存到内存中，以方便下次调用时快速使用，节省时间但是会消耗内存。但在合适的时候会由系统自动释放。主要用于经常使用的图片。且这种方式加载的图片在加载的时候就完成了解压操作。否则解压操作会被放到绘制前进行。京东内部定义宏： JDImg(__name__) ,名字不需要后缀，会自动匹配1x图和2x图。函数实现： [UIImage imageNamed:__name__]单次加载方式：直接从硬盘加载图片，加载后不将图片缓存在内存中，主要用于使用频率不高的图片。京东内部定义宏： JDImgContentOfFile(__name__, __type__)，需要名字和后缀分开写，也可以自动匹配1x图和2x图。函数实现： [UIImage imageWithContentsOfFile:[[NSBundle mainBundle] pathForResource:__name__ ofType:__type__]]注意事项：经常使用是指经常需要拿这张图片给 view对象赋值，而一次赋值后多次使用这个view对象不算做是经常使用。图片格式：（苹果做过优化的格式是 JPEG 和 PNG）JPEG的压缩率比PNG高，因为其使用了更为复杂的压缩算法。因此：加载时间：JPEG优于PNG解码时间：PNG优于JPEG但综合来说，两者的性能差异不大。PNG和JPEG压缩算法作用于两种不同的图片类型：PNG格式允许透明度，而且产生大量的图像文件，是不适合压缩图像照片;JPEG是适合于小文件和提供了一系列的压缩质量，以适应题材，但不允许透明度。混合图片：基本思路：对于包含透明的图片来说，最好是使用压缩透明通道的PNG图片和压缩RGB部分的JPEG图片混合起来加载。这就对任何格式都适用了，而且无论从质量还是文件尺寸还是加载性能来说都和PNG和JPEG的图片相近。开源实现：https://github.com/nicklockwood/JPNG图像性能问题：加载问题：当需要从闪存（比RAM慢200倍）加载图片，或者是网络加载图片时，会有较长的等待时间。解决方案：使用缓存解决IO问题在快速滑动时，可以采用低分辨率图片代替高分辨率图片展示，以获取良好的性能，然后在停下来时，替换为高分辨率图片解压问题：原因：当加载图片的时候，iOS通常会延迟解压图片的时间，一般直到准备绘制前才会进行解压之后。这就会在准备绘制图片的时候影响性能，因为需要在绘制之前进行解压。解决方案：使用 imageNamed加载图片：最简单的方法就是使用 UIImage 的 +imageNamed: 方法避免延时加载。不像 +imageWithContentsOfFile: （和其他别的 UIImage 加载方法），这个方法会在加载图片之后立刻进行解压（就和本章之前我们谈到的好处一样）。问题在于 +imageNamed: 只对从应用资源束中的图片有效，所以对用户生成的图片内容或者是下载的图片就没法使用了。在异步线程解压图片，将图片解压为Bitmap形式。细节可以参考AFNetworking的操作。绘制问题：能高效绘制在iOS上的图片也有一个大小限制。原因：所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048*2048，或4096*4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU。参照表：ios设备情况概览 http://iosres.com/图片打包存储方式：images.xcassets图片打包方式：目前只支持png格式的图片图片只支持[UIImage imageNamed：]的方式实例化，但是不能从Bundle中加载 。在编译时，Images.xcassets中的所有文件会被打包为Assets.car的文件。针对 其管理方式的分析：http://blog.csdn.net/yongyinmg/article/details/23845319其内部采用的是.json文件作为配置文件。当拖入图片资源时，会默认做一次copy，在相应文件夹下生成文件。如果命名重复，则会自动重命名。在页面的属性栏，可以详细配置图片适配的设备、图片间隙、缩放方式和不同内存的使用策略等。直接导入项目，命名上要分为@1x[可省略],@2x,@3x.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[app性能问题定位与解决]]></title>
      <url>%2F2017%2F02%2F09%2Fapp%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%2F</url>
      <content type="text"><![CDATA[app性能问题定位与解决 -------------------------------基础概念------------------------- iOS设备图形显示架构： ios设备情况概览：http://iosres.com/ 图像渲染流程： 动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的渲染服务。在iOS5和之前的版本是SpringBoard进程（同时管理着iOS的主屏）。在iOS6之后的版本中叫做 BackBoard 。 所有的图像渲染都是分为两大部分，六个阶段完成的： 在 APP 内部的有4个阶段 ： 布局（CPU,可被控制）：在这个阶段，程序设置 View/Layer 的层级信息，设置 layer 的属性，如 frame，background color 等等。 显示（CPU,可被控制） ：这是图层寄宿图片被绘制的阶段，无论是通过 setContents 将一个 image 传給 layer，还是通过 drawRect：或 drawLayer:inContext：来画出来的。所以 drawRect：等函数是在这个阶段被调用的。 准备（CPU）：在这个阶段，Core Animation 框架准备要渲染的 layer 的各种属性数据，以及要做的动画的参数，准备传递給 render server。同时在这个阶段也会解压要渲染的 image。（除了用 imageNamed：方法从 bundle 加载的 image 会立刻解压之外，其他的比如直接从硬盘读入，或者从网络上下载的 image 不会立刻解压，只有在真正要渲染的时候才会解压）。 提交(CPU)：在这个阶段，Core Animation 打包 layer 的信息以及需要做的动画的参数，通过 IPC（inter-Process Communication）传递給 render server。 在 APP 外部的2个阶段，当这些数据到达 render server 后，会被反序列化成 render tree。然后 render server 会做下面的两件事： 生成渲染树(GPU)：根据 layer 的各种属性（如果是动画的，会计算动画 layer 的属性的中间值）,计算呈现树，，转化为被OpenGL渲染的可视化三角形（即渲染树）。 OpenGL渲染(GPU) ：渲染可见的三角形到屏幕。接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。 如果做动画的话，前面的两个步骤会一直重复知道动画结束。 我们都知道 iOS 设备的屏幕刷新频率是 60HZ。如果上面的这些步骤在一个刷新周期之内无法做完（1/60s），就会造成掉帧。 所以一共有六个阶段；最后两个阶段在动画过程中不停地重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你真正只能控制前两个阶段：布局和显示。Core Animation框架在内部处理剩下的事务，你也控制不了它. GPU效率影响因素：（相比于CPU，GPU能做的事比较单一：即只做渲染操作） 太多的几何结构（其实瓶颈不在GPU处理上，而是在数据传输上） - 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在CoreAnimation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数（见本章后续“CPU相关操作”）。 重绘 - 主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多。 离屏绘制 - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。 OpenGL 中，GPU 屏幕渲染有以下两种方式： On-Screen Rendering 意为当前屏幕渲染，指的是 GPU 的渲染操作是在当前用于显示的屏幕缓冲区中进行。 Off-Screen Rendering 意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。 离屏渲染的代价：（只要是两方面） 创建新缓冲区:要想进行离屏渲染，首先要创建一个新的缓冲区。 上下文切换:离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。 引发离屏渲染的因素： CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。 解决方案： 开启 shouldRasterize 属性：由CPU将layer缓存为图片，将计算转嫁给CPU。（当我们发现屏幕卡顿，GPU占用很高，但是CPU不高时，可以采用此方法。） 或者采用图片来代替代码绘制 过大的图片 - 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理（自动完成），同样也会降低性能。 CPU效率影响因素： 布局计算 - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应该是比老版的自动调整逻辑加强了CPU的工作。 视图懒加载 - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示（见后续“IO相关操作”），都会比CPU正常操作慢得多。 Core Graphics绘制 - 如果对视图实现了 -drawRect: 方法，或者 CALayerDelegate 的 -drawLayer:inContext: 方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，CoreAnimation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。 （因此，建议使用专业的layer类型去处理相关的事项） 解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片（14章“图片IO”会更详细讨论）。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用 UIImageView ）或者把它绘制到Core Graphics中 图层转化 - 当图层被成功打包，发送到渲染服务器之后，CPU仍然要做如下工作：为了显示屏幕上的图层，Core Animation必须对渲染树种的每个可见图层通过OpenGL循环转换成纹理三角板。由于GPU并不知晓Core Animation图层的任何结构，所以必须要由CPU做这些事情。这里CPU涉及的工作和图层个数成正比，所以如果在你的层级关系中有太多的图层，就会导致CPU没一帧的渲染，即使这些事情不是你的应用程序可控的。 IO相关操作： 一个典型的例子就是两个视图控制器之间的过渡效果，这就需要从一个nib文件或者是它的内容中懒加载，或者一个旋转的图片，可能在内存中尺寸太大，需要动态滚动来加载。 参考文章： OpenGL ES 基础以及 iOS 设备渲染探究优化： http://rannie.github.io/ios/2016/02/22/ios-display-opengles.html ----------------------------------性能问题定位---------------------------------- 性能问题定位的基本方法： ios建议流畅的界面需要保持60HZ的刷新频率，这表示每一帧的界面计算和显示需要在16ms内完成。 如果我们使用Core Animation去完成动画的话，就意味着动画的FPS是60HZ，这是由系统决定的，我们无法改变。（属性动画、关键帧动画、动画组和过渡动画均是如此）。但当我们使用NSTimer和CADispalyLink去更新动画时，帧数是可以由我们自己控制的。 不要使用模拟器去定位性能问题，因为模拟器的CPU强于手机，但是GPU由于使用软件去模拟硬件操作，所以性能弱于手机。 在使用profile时，一定要选择Release模式，其符号化会通过dSYM文件来完成。 用于定位性能问题的Instrument主要工具：(可以使用 Blank 工具，将多个工具组合到一个视图内查看，添加工具可以点击右上角的 + 完成) Time Profile - 用来测量被方法/函数打断的CPU使用情况。 Core Animation - 用来调试各种Core Animation性能问题。 GPU Grive：查看GPU的使用率 OpenGL ES驱动 - 用来调试GPU性能问题。这个工具在编写Open GL代码的时候很有用，但有时也用来处理Core Animation的工作。 定位问题的基本思路： 将以上三个工具放到一个 blank 中进行同时运行。 查看帧率是否正常 查看CPU和GPU的使用占比如何 查看CPU使用占比，如果一个函数的占比不超过40%，那么一般来说都是正常的现象。 如果CPU没问题，那么就定位Core Animation 和 Open GL ES中的问题项。 cell耗时定位： 使用吴迪的工具类：DWURecyclingAlert 使用方法：直接导入该文件即可，注意，其中的 DEBUG 宏是工程默认添加的，但是可以被删除。需要确认自己的工程内有没有这个宏，没有的话，需要替换为其他宏。 github地址：https://github.com/diwu/DWURecyclingAlert 目前该调优工具对于 手动布局 的cell，有较好的性能测算效果。但是对于 使用了 autolayout 的cell，测算效果并不准确。因为它遗漏掉了自动布局的时间。 它主要监测的是 获取cell对象所花费的时间（cellForRaw）以及 cell对象绘制所花费的时间（drawRect） 针对于这两个时间来说，如果之和超过 10ms（计算的是CPU时间，需要为GPU预留6ms的时间），那么就存在潜在的性能问题。 性能建议：对于没有多种布局情况的cell，尽量使用 手动布局的方式编写，这样可以尽可能的提高效率。 CPU耗时定位： 主要工具：TimeProfile 它是时间分析工具，计算的是时间分配比例，与CPU占用率无关，可能是由IO引起的卡顿问题 参考文章：http://www.jianshu.com/p/9e1f0b44935c 使用技巧：（在右下边栏打开以下选项） 通过线程分离 - 这可以通过执行的线程进行分组。如果代码被多线程分离的话，那么就可以判断到底是哪个线程造成了问题。 隐藏系统库 - 可以隐藏所有苹果的框架代码，来帮助我们寻找哪一段代码造成了性能瓶颈。由于我们不能优化框架方法，所以这对定位到我们能实际修复的代码很有用。 （但有些时候，我们希望暴露出系统调用的问题的话，就不要隐藏掉） 只显示Obj-C代码 - 隐藏除了Objective-C之外的所有代码。大多数内部的CoreAnimation代码都是用C或者C++函数。 注意事项： 它会累积截止目前为止的函数运行时间占比，因此，我们需要在我们想要测试的界面长时间运行代码，以便将问题暴露出来。 在进行profile前，工程的需要在build setting — build options — debug information format 应该选为 DWARF with dSYM file，这样可以在函数call tree中直观的展示函数名（否则是伪编码）。 GPU耗时定位： UIKIT性能调优：http://www.cocoachina.com/cms/wap.php?action=article&amp;id=15238 （使用core animation进行性能调优） Core Animation工具使用： 使用 Color Blended Layers 勘探图层混合情况： 绿色越多越好，红色越少越好。 避免图层混合，尽量将opaque的值位置为 NO（UIView的opaque属性默认值就是true，也就是说只要不是人为设置成透明，都不会出现图层混合）。但是如果view中的alpha不为1的话，也会出现图层混合。 对于UIImageView来说，如果不仅它自身需要是不透明的，它的图片也不能含有alpha通道。 个人认为比opaque属性更重要的是backgroundColor属性，如果不设置这个属性，控件依然被认为是透明的。因此尽量避免设置 背景色为clearColor（但默认就是这个值，因此需要我们手动修改） 如果label文字有中文，依然会出现图层混合，这是因为此时label多了一个sublayer。此时，需要使用 label.masksToBounds = YES,使其绘制性能得到提升。（单纯的masksToBounds 不会引发性能问题） 使用 Color Hits Green and Misses Red 检测光栅化的命中情况： 绿色越多越好，红色越少越好。 当我们设置layer.shouldRasterize = true时，表示需要将这个控件光栅化。 使用光栅化表示将这个控件渲染为位图保存在缓存中，当屏幕滑动，重新使用到该控件时，我们可以使用缓存而不需要重新生成。 但是光栅化存在以下几个问题： 需要额外的消耗内存以及写入操作 缓存的有效时间很短，如果超过100ms没用到，缓存就失效，会被删除。 光栅化命中需要控件内容完全一致，对于label这类的控件来说，几乎是不可能的。 因此光栅化仅适用于较复杂的、静态的效果 目前，默认情况下光栅化都是关闭的。 使用 Color Copied Images 来检测图片的颜色空间是否被GPU支持： 如果需要GPU做实时格式转换的，那么会被标为蓝色。蓝色应该越少越好。 使用 Color Misaligned Images 来检测图片是否被缩放： 当图片显示为黄色是表示图片被缩放，如果没有像素对齐，则标记为紫色。没颜色最好。 使用 Color Offscreen-Rendered Yellow 来检测离屏渲染： 离屏渲染会被显示为黄色，应该尽量避免。 离屏渲染意味着把渲染结果临时保存，等用到时再取出，因此相对于普通渲染更占用资源。 可能导致离屏渲染的操作： 重写drawRect方法 有mask或者是阴影(layer.masksToBounds, layer.shadow*)，模糊效果也是一种mask layer.shouldRasterize = true 当使用圆角时，需要取舍，如果频繁出现的话，那么可以考虑使用光栅化技术加快速度。或者将 view 转化为 自带圆角的image 来完成显示。 使用 Color Compositing Fast-Path Blue 检测由CPU完成路径混合操作的区域： 如果是由cpu完成，那么将被标记为蓝色，蓝色越多越好。 使用 Flash updated Regions 检测在变化时需要重绘的区域： 如果为黄色，则表示是需要重绘的区域。 Open GL ES工具使用： Renderer Utilization - 如果这个值超过了~50%，就意味着你的动画可能对帧率有所限制，很可能因为离屏渲染或者是重绘导致的过度混合。 Tiler Utilization - 如果这个值超过了~50%，就意味着你的动画可能限制于几何结构方面，也就是在屏幕上有太多的图层占用了。 --------------------------------------性能调优建议-------------------------------------- 性能调优建议： 参考文章： 性能调优总指南：http://blog.jobbole.com/37984/ 优化请求性能： 优化请求性能 基本容器性能分析： 基本容器collection对象性能分析 内存相关建议： 大量临时对象采用autorelease保护。在ARC下使用@autorelease 块语句包裹。 资源懒加载机制：（但这样做会拖慢使用时速度，如果是运行时卡顿严重但是内存消耗不大，那么建议不要使用这种机制） 图片懒加载：在TableView中有大量图片行，再快速滑动时，不加载图片，等停止滑动时，获取当前显示在屏幕上的cell，然后开始加载它们。 对于属性对象的分配上（如果可能的话）我们也应该重载他们的get函数，并在get函数内部去分配它。 界面性能具体建议： CALayer在无用户交互的地方可以代替UIView。可以节省内存和运行时间。 最好使控件的opaque属性设置为true，backgroundColor最好有一个固定的颜色且不透明。 如无特殊需要，不要设置低于1的alpha值，最好让图片没有alpha通道。 确保图片颜色格式被GPU支持，避免劳烦CPU转换。 当有复杂及大量文本排布的需求时，使用CATextLayer/Core Text/Text Kit代替 UILabel是一个提升性能的很好方案。而且文本其实也是图片，是绘制到寄宿图上的图片，对性能的消耗不可忽视。 圆角和阴影的处理方案请参考CPU性能优化以及关于圆角的解决方案 GPU性能建议： 纹理的渲染： 图片过多的情况：所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。 图片过大的情况：当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096。 视图的混合： 对于不透明的图层，尽量设置opaque=1，以避免无用的 Alpha 通道合成。 把多个视图预先渲染为一张图片来显示。（计算转嫁给CPU，并且缓存下来） 离屏渲染问题：（CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering）） 采用图片来代替代码绘制：比如将复杂图层制作成为图片或者是光栅化（建议前者，光栅化的性能消耗也较大） 对于复杂形状的阴影，设置shadowPath来减少CPU计算的工作。（优先采用这种方案而不是光栅化） 当有圆角/阴影/复杂图层时可以考虑开启 shouldRasterize 属性：由CPU将layer缓存为图片，将计算转嫁给CPU。请把此方案作为最后的方案处理。 当我们发现屏幕卡顿，GPU占用很高，但是CPU不高时，可以采用此方法。 请使用Core Animation确认缓存的命中率，如果命中率不高，则放弃使用。 CPU性能相关： 布局更新是相当消耗性能的地方： 设置属性消耗性能：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。 布局计算本身也可能相当消耗性能。所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。 图片解码： 原因：当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。 解决方案：如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。 文本显示大小的计算：如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。 文本渲染：屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。 软件绘图：图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）： - (void)display { dispatch_async(backgroundQueue, ^{ CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^{ layer.contents = img; }); }); } 轻微影响的因子： 对于频繁使用的数据结构，一般采用C语言结构，而不是采用OC类封装，因为每一种方法的访问（普通方法、类方法、属性访问等都是方法访问的一种），都是采用消息转发的传递机制完成的，其开销远大于普通的函数栈调用。因此，从性能角度考虑，也应该使用C结构完成这种工作（比如，CGPoint）。 对象销毁：复杂对象的销毁比较消耗性能，可以放到后台线程执行。（可采用block捕获的形式） 通过资源文件初始化对象，比如在storyBoard中初始化对象或者xib。（比较轻微） 减少图层对象：（实现减少混合和排版以及IPC传输的目的）——只有在图层极多且性能出现问题时，才需要优化 Core Animation非常擅长处理对视觉效果无意义的图层。但是经常性地,你自己的代码会比Core Animation更早地想知道一个图层是否是有用的。理想状况下,在图层对象在创建之前就想知道,以避免创建和配置不必要图层的额外工作。 可以通过精确的代码控制，只添加会展示的图层到图层树中去。 通过复用展示图层可以减少对象的创建与销毁，从而提高性能。 详细代码参考《iOS核心动画高级编程》 — 348 不可见图层分类如下： 图层在屏幕边界之外,或是在父图层边界之外。 完全在一个不透明图层之后。 完全透明 光栅化的使用例子： 每一行的字符和头像在每一帧刷新的时候并不需要变，所以看起来 UITableViewCell 的图层非常适合做缓存。我们可以使用 shouldRasterize 来缓存图层内容。这将会让图层离屏之后渲染一次然后把结果保存起来，直到下次利用的时候去更新。 关于cell重用与离屏渲染的问题： cell重用是指在内存层面发生的对象重用。但是当这个layer层级被转化为渲染树并被提交给GPU渲染时，GPU还是需要渲染树的要求，生成新的一帧画面。这与cell是否被重用没有关系。一个是内存层面的复用，一个是GPU渲染层级时的事，完全不搭嘎的。 适合光栅化的场景：当一个屏幕上出现大量的离屏渲染因素，且这个layer可以长时间保留在屏幕上时（这个长时间是以帧率来计算的，一般来说，只要不是动画，那么就都可以算是长时间） 请把光栅化作为最后的解决方案处理 解决圆角的方案：（优先级从高到低） 直接生成图片来解决。在生成图片解决时，可以使用九宫格图片，即使用layer.contentCenter 属性，圈定九宫格范围，以适配任意大小的内容。 采用CALshapeLayer生成圆角图层。 可以使用光栅化来解决 参考文章： ios保持界面流畅的技巧：http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS事件响应机制]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[iOS事件响应机制事件分类：触屏事件（Touch Event）运动事件（Motion Event）远端控制事件（Remote-Control Event）处理事件时的两个关键路径：传递链：用于确认事件最初开始响应的对象。由系统向离用户最近的view传递。UIKit –&gt; active app’s event queue –&gt; window –&gt; root view –&gt;……–&gt;lowest viewhitTest:withEvent: 用于确认该事件是否发生在那个视图对象上。并返回该对象。pointInside:withEvent: 该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图。【重载此方法可用于扩大/缩小当前空间的点击范围】hitTest:withEvent:方法的处理流程如下:首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；若返回NO,则hitTest:withEvent:返回nil;若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)响应链：用于确认最终接受事件并处理的对象。响应链确定的最初响应对象向appdelegate传递，具体传递顺序如下： initial view –&gt; super view[兄弟视图此时不参与传递]&nbsp;&nbsp;–>&nbsp;&nbsp;&nbsp;&nbsp;….. –>&nbsp;&nbsp; super view[VC.View]&nbsp;&nbsp;–&gt; view controller -&gt; super view 【VC.view.superView】–>&nbsp;&nbsp;&nbsp;&nbsp;…..&nbsp;&nbsp; –> window –> UIApplication -> AppDelegate&nbsp;&nbsp;响应传递规则描述： 响应者链通常是由视图（UIView）构成的一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View)视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图单例的窗口（UIWindow）的内容视图(UIView)将指向窗口本身作为它的下一个响应者单例的应用（AppDelegate）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环响应打印示例：2016-12-09 11:45:22.716 iPadDemo[67886:1128053] next:&lt;UIView: 0x7f85dfe1aaf0; frame = (10 10; 80 80); layer = &lt;CALayer: 0x60000003d6e0&gt;&gt;2016-12-09 11:45:22.717 iPadDemo[67886:1128053] next:&lt;UIView: 0x7f85dfe1a950; frame = (100 100; 100 100); layer = &lt;CALayer: 0x60000003c720&gt;&gt;2016-12-09 11:45:22.717 iPadDemo[67886:1128053] next:&lt;UIView: 0x7f85dfe0c150; frame = (0 0; 768 1024); autoresize = W+H; layer = &lt;CALayer: 0x60000003be80&gt;&gt;2016-12-09 11:45:22.717 iPadDemo[67886:1128053] next:&lt;ViewController: 0x7f85dfe18860&gt;2016-12-09 11:45:22.718 iPadDemo[67886:1128053] next:&lt;UIViewControllerWrapperView: 0x7f85dfe0e490; frame = (0 0; 768 1024); autoresize = W+H; layer = &lt;CALayer: 0x6000000285e0&gt;&gt;2016-12-09 11:45:22.718 iPadDemo[67886:1128053] next:&lt;UINavigationTransitionView: 0x7f85dfc07860; frame = (0 0; 768 1024); clipsToBounds = YES; autoresize = W+H; layer = &lt;CALayer: 0x60800002c380&gt;&gt;2016-12-09 11:45:22.718 iPadDemo[67886:1128053] next:&lt;UILayoutContainerView: 0x7f85dfd0c6d0; frame = (0 0; 768 1024); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x60800005cf80&gt;; layer = &lt;CALayer: 0x60800002bac0&gt;&gt;2016-12-09 11:45:22.718 iPadDemo[67886:1128053] next:&lt;UINavigationController: 0x7f85e101fa00&gt;2016-12-09 11:45:22.719 iPadDemo[67886:1128053] next:&lt;UIWindow: 0x7f85dfd0a980; frame = (0 0; 768 1024); gestureRecognizers = &lt;NSArray: 0x60800005b000&gt;; layer = &lt;UIWindowLayer: 0x60800002b760&gt;&gt;2016-12-09 11:45:22.719 iPadDemo[67886:1128053] next:&lt;UIApplication: 0x7f85dfe009e0&gt;2016-12-09 11:45:22.719 iPadDemo[67886:1128053] next:&lt;AppDelegate: 0x608000028d40&gt;UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。我们熟悉的UIApplication、 UIViewController、UIWindow和所有继承自UIView的UIKit类都直接或间接的继承自UIResponder，所以它们的实例都是可以构成响应者链的响应者对]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS安全模式开发]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[iOS安全模式开发参考文章：微信读书实现：http://www.cnblogs.com/fengmin/p/5552024.html【一般般】天猫实现：http://pingguohe.net/2016/06/20/safemode.html【模式不咋地】自己实现的方案：关于安全模式的定位：安全模式是为了保护应用启动时连续发生崩溃的情况，对于其他情况下发生的崩溃，统统不做保护。开发注意事项：安全模式保护的时间阈值：延时任务启动的时间阈值，代表了安全模式需要保护的启动时间有多长。 在默认执行热修复的情况下，阈值一般很小，只保护热修复无法完成的情况，比如0.1s；否则，阈值一般取5s。超出这个阈值时发生的崩溃，不计入崩溃计数。如果阈值设置较大的话，需要注意保护用户手动kill的情况，以及应用升级、系统升级等情况。【但是这些可以依靠多次计数的特性，自动归零】文件清除范围： 清除硬盘文件时，为了保证系统的稳定性，需要保留原来的系统文件夹结构。【3个大文件夹，2个小文件夹】NSUserDefaults需要被重置。keychain中的数据暂时不做清除。模块流程图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS插件指南[废弃]]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E6%8F%92%E4%BB%B6%E6%8C%87%E5%8D%97%5B%E5%BA%9F%E5%BC%83%5D%2F</url>
      <content type="text"><![CDATA[iOS插件指南[废弃]推荐插件：XAlign：代码格式化工具。选中代码段后，shift+command+xSCXCodeSwithExpander：switch-case自动填充工具。生成switch后，在变量框内输入相应变量即可。其对enum的格式不做要求，但是首次安装后的第一次打开可能不生效，需要关闭后再次打开才可。总之，多尝试几次就好。FuzzyAutocomplete（目前已被弃用）：模糊匹配工具。在Xcode的 菜单栏-Editor-FuzzyAutocomplete-Plugin-Setting中可以设置匹配规则。一般来说，我比较喜欢这样的配置方式（这个插件目前已经自带化，不需要额外安装）GitDiff: 代码版本控制显示软件。可以在代码行处对增加的代码、修改的代码和删除的代码加上不同的颜色显示。不需要操作。SCXcodeMiniMap:左侧代码缩略图，和GitDiff配合使用，可以一目了然的看到哪里的代码被修改了。（易导致crash，不推荐安装）KSImageNamed:图片缩略图显示插件。当我们使用[UIImage imageNamed:@“xxx”] 函数时，会根据名字找到这张图片并显示相应的缩略图。不需要操作。XcodeColorSense：颜色直观显示插件。但只对使用原始的UIColor语句有效。只要焦点停留在颜色代码行，就将会直观的显示颜色。VVDocumenter-Xcode：代码注释快捷生成软件。使用 /// 快速生成注释。Alcatraz：插件管理工具包，这TM才是最有用的插件。在 菜单栏-windows-Package Manager 里可以管理相应的插件。DXXcodeConsoleUnicodePlugin:debug框内uicode编码的中文显示自动转化为中文输出，对于打印son串返回的数据很有效果。XTodo:可以快速的添加不同的标记，并提供单独的搜索框。在 菜单栏-View-ToDoList 可以显示搜索框。在 菜单栏-View-Snippets 可以查看各个标记的默认快捷键。总的来说是 shift+control+'x'HOStringSense:用于字符串快速编写，不需要担心转码的问题。特别适合编写正则表达式。上方出现字符数统计，点击后可以出现单独的编辑模块。FastStub：快速的未实现函数补全器。按ctrl+cmd+k 会直接弹出，支持多选。一些不错，但是由于工程限制，暂时没有使用的插件：cocoapods-xcode-plugin：pod相关的操作可以在xocde的菜单进行。在 菜单栏-Product-Cocoapods 可以管理该插件的功能。XcodeColor：debug彩色输出。使用方式稍微有点复杂，需要自己定义宏，然后使用相应的宏打印输出，可以参照文章：http://www.w2bc.com/Article/74050xcode更新后插件更新脚本：在 桌面-ownerSpace-xcode-plugin 中可以调用。（即采用脚本的方式添加 udid 到插件中去）注意事项：插件是有一定几率导致xcode crash的，需要谨慎使用。目前遇到过的可能引发crash的插件有：1.SCXcodeMiniMap：不太稳定，易导致crash。插件问题集合：使用插件管理工具 Alcatraz 可以方便的管理各类插件，这个插件在安装其他插件时有失败的风险，但不会有状态不一致的情况出现，多尝试几次即可。在安装完成后，需要重启Xcode,并选择 Load Bundle来加载插件。（存在失效可能性）插件的快捷键设置，在 系统偏好设置 -&gt; 键盘 -&gt; 快捷键 -&gt; 应用快捷键设置 -&gt; 添加，在应用名选择 xcode，第二个名字是 相应快捷操作的全名，必须完全匹配，快捷键是按照名字来匹配的。最后是相应操作的快捷键设置。（需要注意的是，只要是打开的应用，无论现在是否是主控应用程序，其设置的快捷键都可以被监听且执行，尤其是QQ的swiftly快捷键，command*2,简直就是屎！！！）。如果遇到 插件管理工具下载后，插件不生效的。 使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID &nbsp;&nbsp;&nbsp;&nbsp; 获取xocde uuid编号 请在 插件目录&nbsp;&nbsp;~/Library/Application&nbsp;&nbsp;Support/Developer/Shared/Xcode/Plug-ins &nbsp;&nbsp;下，打开相应的插件包，并检查 其DVTPlugInCompatibilityUUIDs 的list中添加一个Xcode uuid的item。有些插件的生效时间比较慢，比如&nbsp;&nbsp; SCXcodeSwitchExpander , 它会等待Xcode对当前的建立索引后，收到了IDEIndexDidChange通知，才开始生效。所以，请耐心等待。主题也是按照类似于插件的形式来管理的，以下是手动管理指南：用户自定义主题文件夹：~/Library/Developer/Xcode/UserData/FontAndColorThemes主题文件后缀：.dvtcolortheme。直接放入文件夹后，重启xcode即可读取。辅助文档工具：appledoc &lt;option&gt; + 项目文件夹 ,appledoc的使用方式比较奇特。对于 appledoc来说，可以生成 HTML格式的文本，但index.html在 docket包内部，需要进入后打开。同时，docket可以支持在项目中使用 option + 单击 就可以调出相应的帮助文档。示例：appledoc -o /Users/chengjianfeng/Desktop/docOut --project-name /Users/chengjianfeng/Desktop/源码阅读/AFNetworking-master --project-company CJF /Users/chengjianfeng/Desktop/源码阅读/AFNetworking-maste格式解析：appledoc &nbsp;&nbsp; &nbsp;&nbsp; source_dir]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS断言机制]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E6%96%AD%E8%A8%80%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[iOS断言机制断言推荐使用的场景：用错误处理代码来处理预期会发生的情况,用断言来处理绝不该发生的状况.避免把需要执行的代码放到断言中.因为断言在Debug模式下是生效的,但在Release模式在无效,这样就会丢失执行代码.用断言来注释并验证前条件和后条件.对于高健壮的代码,应先使用断言,再处理错误.Xcode上断言生效的设置：Debug默认生效，Release模式下默认失效。断言常用宏：NSAssert( condition, description , …__vars__... )：OC断言宏，断言条件不成立时，打印信息并抛出异常【异常无人处理时将退出程序】。只适用于OC函数内部断言。 decription是输出表达式，__vars__是表达式中用到的变量参数。有多参数版本，其实就是根据有多少个 __vars__ 然后取不同名字的Assert版本，比如NSAssert1，NSAssert2，NSAssert3，NSAssert4和NSAssert5。【但其实直接用原版本即可】NSCAssert( condition, description , …__vars__... )：C断言宏，使用于C函数和OC函数内部只能使用此断言。【在C函数中只能使用NSCAssert】它与NSAssert的代码区别在于，取函数名时，NSAssert用的是__cmd,而NSCAssert用的是__PRETTY_FUNCTION__。然后NSAssertionHandler调用的抛出函数也不同。也有多参数版本。NSParameterAssert( condition )：定义：#define NSParameterAssert(condition) NSAssert((condition), @"Invalid parameter not satisfying: %@", @#condition)作用：失败时自动输出条件判断语句，相当于NSAssert的一层格式化封装。NSCParameterAssert(condition):定义：#define NSCParameterAssert(condition) NSCAssert((condition), @"Invalid parameter not satisfying: %@", @#condition)作用：失败时自动输出条件判断语句，相当于NSCAssert的一层格式化封装。AssertHandler断言处理回调：默认的断言处理回调：当断言不成立时，会向 NSAssertionHandler实例发送一个表示错误的字符串。每个线程都有它自己的NSAssertionHandler实例。【断点无法停留在准确的代码行】 NSAeert调用：[[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd object:self file:__assert_file__ lineNumber:__LINE__ description:(desc), ##__VA_ARGS__];告知断言失败。NSCAeert调用：[[NSAssertionHandler currentHandler] handleFailureInFunction:__assert_fn__ object:self file:__assert_file__ lineNumber:__LINE__ description:(desc), ##__VA_ARGS__];告知断言失败。注册自定义的断言处理回调： 继承NSAssertionHandler实现自己的断言处理类。在继承类中重载上面提到的两个方法。在需要使用自定义断言处理的线程上注册。自定义断言处理类示例：@implementation CJFAssertionHandler//处理Objective-C的断言- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...{ NSLog(@"NSAssert Failure: Method %@ for object %@ in %@ ,line: %li", NSStringFromSelector(selector), object, fileName, (long)line); //建议加上abort(),方便及时发现问题，且调用栈可观察。 abort();}//处理C的断言- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...{ NSLog(@"NSCAssert Failure: Function (%@) in %@ ,line: %li", functionName, fileName, (long)line); //建议加上abort(),方便及时发现问题，且调用栈可观察。 abort();}@end自定义断言处理类注册：CJFAssertionHandler *myHandler = [[CJFAssertionHandler alloc] init];//给当前的线程[[[NSThread currentThread] threadDictionary] setValue:myHandler forKey:NSAssertionHandlerKey];参考文章与示例：http://www.jianshu.com/p/6e444981ab45]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发常见问题大全]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[iOS开发常见问题大全代码问题：使用stringWithFormat 格式化数字时的进位问题：[NSString stringWithFormat:@"%.1f折",rate] ：在使用这个方法转化值时，会产生进位问题。即如果只保留一位小数，那么后面的尾数会四舍五入的进位。我们需要确认这个特性是否与我们想要的一致。Block判空问题：Block变量在使用时，一定要先判断是否为nil，如果为nil却直接调用，会引发crash。NSNumber对象使用完整判空语句：NSNumber对象会使用一种“标签指针”的技术来标注特定类型的数值，这种做法不使用NSNumber对象，而是将与数值相关的全部消息都放在指针值里面。此时，我们使用 if( xxx ) 来判断它是否为nil的话，就会引发bug。因为，该值可能会0，正好与 nil情况相似。因此，建议 if( xxx ) 判断应该 使用 if( xxx != nil )编写完全。原子特质属性使用方式：如果对属性使用了 atomic 特质，那么即使在 实现文件中，也不能直接访问 实例变量，而应该通过 set/get 方法操作。容器添加元素判空问题：如果对象需要加入到 字典 或者是 数组中，那么一定要进行判空操作。建议使用程序中的 safeAdd 方式。CoreFoundtion对象内存管理：使用 CFRelease( xxx ) 时需要进行判空操作，否则会出现crash。Xcode突然无法打印变量的系统bug：修复方法：http://stackoverflow.com/questions/36151708/xcode-7-3-debugger-not-showing-custom-class-variables。需要修改 build setting 中的内容方可。在block内直接访问成员变量的问题：在iOS中，使用block时，为了避免循环引用问题，我们一般会采用strongSelf-&gt;_xxxx，取访问成员变量。但是这种方式下，因为strongSelf可能为nil，从而导致crash问题。（如果是属性的话，那么是安全的）。因此，建议 所有Block 内使用成员变量的代码，都在最外层加上一个strongSelf != nil 的判断。保护代码不受crash。id对象方法调用的问题： 如果某一个对象是从容器中取出来的，或者是一个ID类型，那么在使用它之前必须判断它是否是我们预期中的类型。在OC中，如果调用未知方法是非常危险的，使用 performSelector 调用前，最好先使用 respondsToSelector 验证方法是否可调用。使用float时可能出现精度过低的问题，当有效数字位数达到8位时，会产生显示误差。非Retain显示屏字体模糊问题：在我们在设置坐标时，如果坐标、大小的位置不是整数时，就将导致文字显示模糊。（与坐标、宽度设置均有关系，都需要设为整数值）遇到这种问题，重点排查相应view的frame和center设置是否存在小数点设置。在设置值时可以采用 ceilf 向上取整设置值。对于模糊效果来说，不只是本身的坐标设置有影响，superView以及其上祖先view的坐标设置，也会对它是否模糊产生影响。虽然在理论上我们可以编写任意大小的Rect，但是实际物理的布局大小是以像素点为单位进行的，它无法完全依照我们的设想去完成布局。因此我们需要遵循这一规律： 在一倍屏上，最小布局point单位是 1.在二倍屏上，最小布局point单位是0.5. 这一才能有效的保证布局的正确性和效率。当我们碰到这类问题时： 如果是普通的view上布局。那么请尽量避开这种值，在不同设备上格式化到最小标准单位。或者是统一到 1，最为简单。（其实很难看出来）如果是对于 collectionView 这种 cellSize 、itemSpace等东西，如果我们写入这样的数值，那么系统会自动帮我们格式化到最小单位，然后将不足或者多余的大小，在 中间的space上补齐。又或者无法正常显示space。因此，我们在设置值时就应该写入以最小单位为标准的值。 为了补齐大小，不产生余数。我们可以是cell之间的大小是不一样的。反正它也是由 delegate方法返回的。 -（CGSize）collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath*) indexPath.系统字体变化的问题：系统字体的大小不是一成不变的，随着系统的更新，字体的大小会发生细微的变化，此时，如果lable等宽度是写死的，那么将会导致显示为省略号。建议不到万不得已，不要使用宽度写死的策略，应该使用sizeToFit去适应内容宽度。如果一定要写死，最好预留一定的宽度，比如1pt or 2pt。历史事件： 在ios6 -&gt; ios7 时，字体大小发生变化。在ios8 -&gt; ios9 时，字体大小发生变化。ios7上view的frame大小问题：在ios7上，当 viewController 采用 代码初始化方式初始化时（无xib参与），在viewDidLoad阶段，view.frame固定为 （0，0，768，1024）。而在 viewWillAppear 时，view.frame 恢复到其应有的大小。当采用 xib初始化时，其 view.frame的大小一开始就可以初始化为正确的大小。iOS内存告警处理方式：当我们收到系统的内存告警的时候，我们需要及时处理，才能确保app不会被杀死：appdelegate会调用回调函数：-（void）applicationDidReceiveMemoryWarning:(UIApplication *)application系统会发送通知：UIApplicationDidReceiveMemoryWarning ViewController会回调函数：-（void）didReceiveMemoryWarning;每个view内部独有一个CALayer属性，该属性是一个bitmap图像的容器类。当UIView调用 drawRect时，CALayer才会创建这个 bitmap图像类。 具体占用内存的实际上是 bitmap这个对象，一般来说，CALayer只占48Bytes，UIView对象只占96Bytes，而一个全屏显示的iPad bitmap对象有12MB这么大。所以，当didReceiveMemoryWarning被调用时，会释放该vc下所有view的 bitmap （但是不会释放掉view本身）。这样即可以回收内存，又可以在需要的时候通过 drawRect 函数重建 bitmap对象。 等于说，在ios6之后，我们需要在 didReceiveMemoryWarning 中额外实现的（非必要，除非内存还是不够用），只是对我们VC自己的 数据进行管理而已。同时IOS针对bitmap的内存回收还做了优化，具体而言就是，在回收时是统一回收的，但是内存会被打上一个标志位，表示可被重新利用但未修改，只有在具体重用这块内存后，标志位才会被置为 已修改。那么，当需要重建这个bitmap 时，如果这个内存没有被重新利用，只需要直接复用就可以了，不需要再调用 drawRect来重建。数据清理操作：资源文件等一定要释放网络返回数据等选择性释放。如果选择释放，那么需要考虑好VC回退时如何恢复数据，是重新请求呢，还是之前做好持久化。iPad pro与模拟器上显示边界若隐若现问题：由于iPad Pro和模拟器的分辨率都较高，可以显示出即使是retain上也显示不出的像素，因此，有些图片的小于1px的边框，在这些屏幕上就有可能被显示出来。（但不是一定的，是随机的，因此会若隐若现）如果有这些情况出现，请首先怀疑是否图片存在问题！还有就是，怀疑问题思维要开阔，要勇于尝试！不要被常理所限制。Cell获取问题：当cell不可见时，是无法通过 [_collectionListView cellForItemAtIndexPath:[NSIndexPath indexPathForRow:i inSection:1]]; 获取到cell的，即使它在之前已经被加载出来。NSDate相关问题：NSTimeInterval是一个double类型的值，该值的小数点前一位表示秒，小数点后有6位，可以精确到微妙。 举个例子： time1 = 1451629204.236256 ,time2 = 1451629205.237414获取当前时间距离1970年0点的时间间隔： NSTimeInterval time1 = [[NSDate date] timeIntervalSince1970]; PS：这个获取的时间是按照格林尼治标准时间设置，即我们是东8区与其差了8个时区，实际上是要多 8 * 3600 s的。BadBeef问题：这个问题的起因是由于app内使用webview浏览M页时发生卡死。然后这个问题被webview发现了，系统为了有效的记录这一问题，所以自己主动去访问一个野指针，这个指针的地址就是0xbadbeef。数据压缩与数据加密的顺序问题：请遵循 先压缩，后加密 的顺序进行。这样做的好处在于：压缩率得到提升，先加密的话，压缩率会显著降低。几乎到了无法压缩的地步。减少加密的运算量。Xcode不同project之间头文件引用错误的问题：现象：在同一个工程的不同project之间，我们的实现文件由于有相应的Target Membership 的关联，可以确保正确的关联到相应的project中。但是，对于头文件而言，由于没有Target Membership的关联设置，那么工程会随机找到第一个可以引用的头文件，这就可能会导致出错。原因：由于xcode的工程没有所谓的文件路径引用的概念，包含文件时仅以文件名作为区分要素，这也导致了错误的发生。解决方案：一定要确保在统一工程中，没有相同名字的文件出现，哪怕是不同的project也不行。（但是对于实现文件而言，还是可以的）链接问题解决：（需要注意的是，这个问题是发生在链接阶段，也就是编译是没有错误的）关于Other link flags的使用帮助：http://small.qiang.blog.163.com/blog/static/978493072013112571950/关于找得到头文件但是找不到方法的解决方案：有可能是该头文件的最外围包括了一层宏定义，在该宏没有打开的时候，这个头文件的定义是空的。Xcode头文件查找问题：xcode的头文件在同一个project里是跨target查找的，这里会引发以下几个问题： 不同target的同名头文件，也就是说不同target之间不应该存在同名头文件，否则，各自target中可能会引用错误的头文件，导致编译出错。跨target引用头文件，这个理论上应该需要被禁止。理想的方案： 同一个project下的所有文件，都不应该存在同名文件，如果存在，那么请尽早修改名字。如果有一些文件需要被跨Target使用，请单独的整理出这些文件，放到独立的文件夹中（便于后期管理），然后为各自的target添加依赖关系和 MemberShip 。运行时动态库无法找到的问题：现象：dyld: Library not loaded: .................................................. ; Reason: image not found解决方案：需要在该 target 的配置中，general - embeded binaries 里添加这个确实的库，就可以解决这个问题了。建议：以后添加库都应该在general - embeded binarie 里添加。关于cookies的写入问题：新建NSHTTPCookie 对象时，需要传入一个字典对象去初始化属性，之后就只能读取这些属性而不能修改。通常需要设置的属性如下： NSHTTPCookieName：cookie的名字NSHTTPCookieValue：cookie的值NSHTTPCookieDomain：cookie的作用域名，在设置的时候不要加上协议名（例如：” api.m.jd.com" 即可,注意，cookie的匹配原则是从尾部开始匹配的，如果希望匹配所有京东的域名，可以使用 ".jd.com" ）NSHTTPCookiePath：cookies的详细文件路路径,可以使用“/”表示通配。关于drawRect的问题：首先，draw代表的是一种绘制技术，它绘制的对象是在当前view的layer上完成的。相比于subview，其的显示层级是最低的。关于dispatch_once重入性问题：dispatch_once是不可重入的，如果在dispatch_once中再次调用dispatch_once，会引起崩溃问题。这意味着，我们在获取单例对象时应该非常小心。关于应用启动时就卡死的原因：现象：一直停留在启动页面，对于京东来说，就是红色京东狗页面。原因：很有可能是 load 、 initialization 或者是 __attribute__((constructor)) 函数出了问题，因为这些函数可以在main函数开始前执行，一旦在里面发生死锁，就会锁死在启动界面。iOS SIGPIPE崩溃原因与解决方案：原因：管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。常见起因：使用socket的时候一般都会收到这个SIGPIPE 信号，处理方法大部分都是忽略。我们需要在send的时候检测到服务器已经关闭连接，进行重新连接。正常情况下send函数返回-1表示发送失败，但是在iOS上SIGPIPE在send返回之前就终止了进程，所以我们需要忽略SIGPIPE，让send正常返回-1，然后重新连接服务器。解决方案： 自己设置相应的回调函数，或者直接注册一个空函数。struct sigaction sa;sa.sa_handler = SIG_IGN;sigaction( SIGPIPE, &amp;sa, 0 );设置socket不抛出SIGPIPEint set = 1;setsockopt(sd, SOL_SOCKET, SO_NOSIGPIPE, (void *)&amp;set, sizeof(int));参考文章：http://blog.csdn.net/tangaowen/article/details/46822167NSString文件操作相关的方法：定义在 NSPathUtilities.h 中，属于NSString (NSStringPathExtensions) 分类。常见方法： 路径组装路径拆分文件名获取后缀名获取绝对路径静态库中发生unrecognized selector ：需要特别关注调用的方法是否是分类方法，是的话，一般是由于程序没有加载静态库中的分类方法。需要在Other linker Flag 中添加处理【一般加上 -Objc 即可】。Bitcode库有效性校验：参考文章：http://www.cocoachina.com/ios/20151201/14432.html主要内容： .a校验： otool -arch armv7 -l xxxx.a | grep __bitcode | wc -l ，可以具体指定某一类型的架构校验.framework校验： otool -l xxxx | grep __LLVM | wc -l ，当然也可以指定架构校验 otool -arch armv7 -l xxxx | grep __LLVM | wc -l结果有效性：并不保证完全有效，仅作参考作用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS疑难bug记录笔记]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E7%96%91%E9%9A%BEbug%E8%AE%B0%E5%BD%95%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[iOS疑难bug记录笔记----------------------------------------- 基本方法 -----------------------------------------崩溃文件定位方针：查看调用栈信息，能否定位到自己的代码查看assitInfo，得到大致VC、OSVersion和设备相关的基本信息从崩溃信息中【主要是调用栈】得到关键信息，然后Google一下在线调试定位方针：查看调用栈信息如果xcode无法定位到具体代码行【即崩溃发生在系统中】，且没有任何打印。那么尝试开启僵尸对象调试、----------------------------------------- 疑难问题 -----------------------------------------iOS UIScrollView / UITableView / UICollectionView 内部不一致错误：调用栈示例：Thread 0 Crashed:0libobjc.A.dylib 0x38f74626 objc_msgSend + 61UIKit 0x312a6740 -[UIScrollView(UIScrollViewInternal) _notifyDidScroll] + 602UIKit 0x31020798 -[UIScrollView setContentOffset:] + 6003UIKit 0x312a76b6 -[UIScrollView(UIScrollViewInternal) _adjustContentOffsetIfNecessary] + 13944UIKit 0x310d33d2 -[UIScrollView(UIScrollViewInternal) _stopScrollingNotify:pin:tramplingDragFlags:] + 4145UIKit 0x310d322a -[UIScrollView(UIScrollViewInternal) _stopScrollingNotify:pin:] + 266UIKit 0x310d31e2 -[UIScrollView removeFromSuperview] + 267UIKit 0x31001952 -[UIView dealloc] + 3748CoreFoundation 0x2e700140 CFRelease + 5569CoreFoundation 0x2e70b668 -[__NSArrayM dealloc] + 15610libobjc.A.dylib 0x38f79b66 objc_object::sidetable_release(bool) + 17011libobjc.A.dylib 0x38f7a0ce (anonymous namespace)::AutoreleasePoolPage::pop(void*) + 35412CoreFoundation 0x2e70347c _CFAutoreleasePoolPop + 1213CoreFoundation 0x2e798f0e __CFRunLoopRun + 131014CoreFoundation 0x2e703724 CFRunLoopRunSpecific + 52015CoreFoundation 0x2e703506 CFRunLoopRunInMode + 10216GraphicsServices 0x336726ce GSEventRunModal + 13417UIKit 0x3106486c UIApplicationMain + 113218BoatSenzeDev 0x00110648 main (main.m:16)19libdyld.dylib 0x39468ab4 start + 0错误原因：系统bug，在执行过渡动画时，scrollView的delegate已经被释放，但是，系统依然尝试发送消息给它。会导致一个访问野指针的错误。调试方法：直接使用xcode调试的话，不会得到有用的信息，崩溃定位直接停在main中了。但开启僵尸调试可以有效的调试这个问题，并产生额外的信息。 不开启僵尸调试时，系统的野指针访问是不会有任何打印信息和代码定位的。开启僵尸调试后，会得到类似以下信息： -[JDLiveViewController scrollViewDidScroll:]: message sent to deallocated instance 0x131438650 。由这句话我们就知道，这确实是一个野指针引起的问题，并且引发野指针访问的因素是向已经释放的 delegate 发送代理消息。解决方案：在 delegate 的 dealloc时，将 UIScrollView / UITableView / UICollectionView 的 delegate/datasource 都置空。参考文章： http://stackoverflow.com/questions/26103756/uiscrollview-internal-consistency-crash----------------------------------------- 疑难问题 -----------------------------------------UICollectionView crash on unhighlightAllItems：调用堆栈示例：【未明确验证】Thread 0 Crashed:0 libobjc.A.dylib 0x39dd2b26 objc_msgSend + 61 UIKit 0x31fd5eef -[UICollectionView cellForItemAtIndexPath:] + 1112 UIKit 0x32060bfd -[UICollectionView _unhighlightItemAtIndexPath:animated:notifyDelegate:] + 1493 UIKit 0x32383947 -[UICollectionView _unhighlightAllItems] + 1514 UIKit 0x3205f9fb -[UICollectionView touchesBegan:withEvent:] + 3675 UIKit 0x31fcb101 forwardTouchMethod + 2336 UIKit 0x31fcb101 forwardTouchMethod + 2337 UIKit 0x31e3be4b _UIGestureRecognizerUpdate + 55238 UIKit 0x31e73c41 -[UIWindow _sendGesturesForEvent:] + 7739 UIKit 0x31e735e7 -[UIWindow sendEvent:] + 66710 UIKit 0x31e48a25 -[UIApplication sendEvent:] + 19711 UIKit 0x31e47221 _UIApplicationHandleEventQueue + 709712 CoreFoundation 0x2f69e18b __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 1513 CoreFoundation 0x2f69d6e1 __CFRunLoopDoSources0 + 34114 CoreFoundation 0x2f69be4f __CFRunLoopRun + 62315 CoreFoundation 0x2f606ce7 CFRunLoopRunSpecific + 52316 CoreFoundation 0x2f606acb CFRunLoopRunInMode + 10717 GraphicsServices 0x342f4283 GSEventRunModal + 13918 UIKit 0x31ea8a41 UIApplicationMain + 113719 JackThreadsIpad 0x000922b7 main (main.m:16)错误原因：iOS7系统bug。当你在页面drag的同时reloadData，那么就有可能会导致这个问题。调试方法：在iOS7上模拟上述操作。解决方案：方案描述：引入标志位，在Darg时延后reloadData，而是在修改标志位。然后在Drag结束时，判断标志位是否设置，是的话，就执行reloadData操作。代码描述：- (void)updateData { if (self.collectionView.isTracking) { self.updateDataOnScrollingEnded = YES; } else { [self.collectionView reloadData]; }}- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{ if (!decelerate) { [self scrollViewStopped:scrollView]; }}- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView{ [self scrollViewStopped:scrollView];}- (void)scrollViewStopped:(UIScrollView *)scrollView{ if (self.updateDataOnScrollingEnded) { [self updateData]; self.updateDataOnScrollingEnded = NO; }}参考文章：http://stackoverflow.com/questions/19032869/uicollectionview-crash-on-unhighlightallitems----------------------------------------- 疑难问题 ----------------------------------------- 调用堆栈示例：__exceptionPreprocess (in CoreFoundation_10.1.1) + 124objc_exception_throw (in libobjc.A.dylib_10.1.1) + 56+[NSException raise:format:] (in CoreFoundation_10.1.1) + 0-[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:] (in Foundation_10.1.1) + 112-[UITableView _endCellAnimationsWithContext:] (in UIKit_10.1.1) + 7540错误诊断：Application threw exception NSInternalInconsistencyException: attempt to insert section 1 but there are only 1 sections after the update。错误原因：在插入/删除section或者row时，未更新数据源，使界面上的section数量与数据源的section数量不一致，导致crash。解决方案：确保自己更新数据后，再执行插入或者删除操作。或者直接使用reloadData来执行更新操作。参考文章：http://stackoverflow.com/questions/11706254/nsinternalinconsistencyexception-reason-attempt-to-insert-row-0-into-section]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发细节集合]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82%E9%9B%86%E5%90%88%2F</url>
      <content type="text"><![CDATA[iOS开发细节集合iOS开发WIKI（第三方维护）：http://iphonedevwiki.net/index.php/Main_PageOC语法特性：OC中，函数重复定义的标准是：参数个数相同以及选择器名称（即方法名称）相同。与方法返回类型、参数类型以及参数名称均没有关系。在使用@property后，编译器都会自动生成隐藏的实例变量、相应的get/set方法。如果希望自己实现这些（此时属性声明的作用只相当告诉外界我拥有这两个方法而已），需要在implementation中声明@dynamic&nbsp;&nbsp;属性名 ，然后自定义变量以及相应的set/get方法。在ios6之后，编译器会默认检查是否存在对应的读写函数，如果都存在，则不会再生成变量。如果需要屏蔽父类中的变量，只需要在子类中重新实现该属性的set/get方法即可。如果需要覆盖，则需要子类中也在定义一个相同类型的变量用于存储。只要符合函数重复定义的标准，那么在父子类中，子类就将覆盖父类中的对应方法。如果是在同一个类中重复定义，那么将会直接报错。在OC中，OC函数调用是消息转发，而C函数调用是直接调用。而无论哪个，其函数返回值是 R-Value（右值），不可以用于赋值。对于属性值的访问，都是函数调用，因此其get函数的返回值不能直接用于修改数据。在iOS中，有些类是不允许继承的。比如NSTimer，它本身就是一个抽象类。且苹果没有提供将其具象化的方法。未知对象调用方法：在OC中，对于不确定的对象，比如id、任何从数组或字典中取出的对象、Class等，调用未声明的方法，是不会导致编译报错的。但是可能会导致编译时crash。如果对于类型明确的对象（比如已经明确指出该对象是什么指针类型的），那么，直接调用未声明方法是会编译报错的。但可以通过 performSelector&nbsp;&nbsp;间接的调用想要调用的方法。但是这个方式有参数个数的限制，最多支持两个参数。再多就需要使用NSInvacation了。因此，在OC中，如果调用未知方法是非常危险的，使用 performSelector&nbsp;&nbsp;调用前，最好先使用 respondsToSelector&nbsp;&nbsp;验证方法是否可调用。如果类对象 调用 [classObj&nbsp;&nbsp;respondsToSelector:@selector(xxxx:)];&nbsp;&nbsp;判定的话，那么只有类方法会返回 true，成员方法会返回false，且类方法是可以被成功调用的。这里我们需要指出的是，OC中，类方法与普通方法都是按照消息模式处理的，也是按照响应链依次判定调用的 。只不过对于类对象来说，它的方法响应链上只包含静态类方法（这与它是一个对象的概念是一致的，类的类方法属于类对象所属的类的实例方法），其他方法一概不能调用。(不仅包含自身的静态类方法，还包括父类的静态类方法，且遵循响应链调用顺序)内存管理：当有for循环时，且每次循环内部都有大量的临时变量产生。那么在ARC下，我们需要在for循环内部添加上一个 @autorelease ，以便及时的释放这些内存。（特别是图片格式转换这类函数，会有很大的临时内存持有，并残留在autorelease中） &nbsp;&nbsp;网络返回数据的处理问题：可能引发crash的原因：返回类型为null，那么这个类型将会被转化为 【NSNull class】，之后对这个对象不管调用什么方法，都将引起crash。返回类型不符合预期类型，可能会导致crash。比如返回的是一个string，但是以为他是array，之后调用了objectForIndex 等，将直接导致crash。返回类型符合预期，但是是非法值。这个错误一般不会立即引起crash，但是可能在程序的地方，引起crash。保护措施： 对于网络请求的返回数据，每取一次数据都需要校验一次，不可以一次取多层数据（比如嵌套的调用 objectForKey）。对于数据的合法性判断，采用 validateXXXX 来判断合法性，这个在取中间数据和直接使用数据时比较常用。如果当前是在对一个model类型进行初始化，那么最好使用 toValidateXXX 直接产生一个合法的初始值给对象，当然，你也可以采用&nbsp;&nbsp;validateXXXX 再根据返回结果取自己赋自定义初值。NSArray 与 NSDictionary 的初始化方法：语法糖初始化方式：在使用直接初始化方法时 （ NSArray —— &nbsp;&nbsp;@[ &nbsp;&nbsp;, &nbsp;&nbsp;, &nbsp;&nbsp;]不需要nil ； NSDictionary ——@{ … : …，… : …，… : … } 不需要nil ），一旦遇到为nil的元素，就引发插入crash。方法调用初始化：使用【NSArray arrayWithObjects:obj1,obj2,obj3,nil】 （需要添加nil）时，一旦遇到nil元素就会停止添加，从而导致数组或者字典内的元素数量与预期的不一致。这两者前者容易crash，但容易暴露问题数据。后者不容易crash，但是可能引发数据不一致问题，而这个问题更加难定位。因此建议使用前者。关于非 xib 文件的控件存储属性设置：首先，在xib中，由于顶层的view默认持有创建好的所有view,可以将里面的控件声明为 weak，以方便系统进行自动的内存回收。如果是在非xib文件中，那么属性均要使用 strong 来承载，因为 系统自动回收的间隔期是不确定的，如果赋值为weak很有可能在赋值过程或者未加入superView的过程中就已经被释放啦，所以为了安全起见，必须将 该控件属性声明为 strong。多button切换界面，使用同一个显示容器时的注意事项：如果使用同一个显示容器，在不同的button之间切换，那么，就要做好网络保护措施。如果，允许用户在第一个网络请求未返回之前重新点击button，并发起网络请求的话，那么这两个请求的时序性是不一定的，因此，一定要做好保护措施，保证时序性的问题。快速复用view代码的方式：当我们遇到之前的一个view，需要把它移植到 cell 中等情况。那么有一个备选的方案就是 直接在cell 中 addSubview ，将这个view添加进去。这样的代价最小。但是逻辑不是非常清晰。随机字符串生成指南：char data[NUMBER_OF_CHARS];for (int x=0;x&lt;NUMBER_OF_CHARS;data[x++] = (char)('A' + (arc4random_uniform(26))));return [[NSString alloc] initWithBytes:data length:NUMBER_OF_CHARS encoding:NSUTF8StringEncoding];这个函数可以生成随机长度和内容的字符串，只需要修改 NUMBER_OF_CHARS 这个宏即可。轻量级数据存储：轻量级数据请使用NSUserDefaults来存取按钮频繁点击互斥方法：对于按钮来说，假设其功能为点击后发起网络请求，那我们一般希望在上一次网络请求返回前，重复点击按钮不要再次发起请求。此时我们有两种方法来实现互斥和等待：考虑将 button.userInteractionEnable = NO ,然后在请求返回后再将其置为 YES 。即可确保不会重复发起请求。按钮置灰方式更适用于单个按钮发起请求时。可以采用传统的标志位方式。标志位方式更适用于一组按钮发起同一个请求时。调起控制台事件：调起控制台事件会导致app resignActivity ，但是app不会因此停止运行，app依然运行正常，包括后台线程以及主线程都可以正常运行。iOS覆盖安装问题：必须采用同一个证书打的包，并且采用相同的bundelIdentifer 才会产生覆盖安装。其他情况均会同时安装成两个不同的app。iPad分屏开发：在iPad上，只有两个app都支持分屏操作时，才能完成分屏。在iPad上，当有任何一方不支持分屏时，只能从右侧调出一个1/4的小窗操作，且不能同时操作，其类似于控制中心的性质。当两个app都支持时，才能完成分屏操作。ios关于枚举值的定义和使用方式：有三种方式：enum \ NS_ENUM \ NS_OPTIONS。注意的是，无名enum里的内容，也是可以使用的！这一点与我之前的认知不同。typedef enum [name] {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…… } [name];typedef NS_ENUM( type , name ){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…… };typedef NS_OPTIONS( type , name ){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…… };参考博客:http://blog.csdn.net/annkie/article/details/9877643关于&nbsp;&nbsp;NS_OPTIONS&nbsp;&nbsp;的复杂用法：下面的值可以是上面的值的 | 组合结果，依次来表示可知的组合情况。例如：typedef NS_OPTIONS(NSUInteger, YYNetworkTrafficType) {&nbsp;&nbsp;&nbsp;&nbsp; YYNetworkTrafficTypeWWANSent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS面试笔记归总]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0%E5%BD%92%E6%80%BB%2F</url>
      <content type="text"><![CDATA[iOS面试笔记归总基础概念问答：Q:KVO，NSNotification，delegate及block区别 A:KVO就是cocoa框架实现的观察者模式，一般同KVC搭配使用，通过KVO可以监测一个值的变化，比如View的高度变化。是一对多的关系，一个值的变化会通知所有的观察者。 A:NSNotification是通知，也是一对多的使用场景。在某些情况下，KVO和NSNotification是一样的，都是状态变化之后告知对方。NSNotification的特点，就是需要被观察者先主动发出通知，然后观察者注册监听后再来进行响应，比KVO多了发送通知的一步，但是其优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，使用也更灵活。 delegate是代理，就是我不想做的事情交给别人做。比如狗需要吃饭，就通过delegate通知主人，主人就会给他做饭、盛饭、倒水，这些操作，这些狗都不需要关心，只需要调用delegate（代理人）就可以了，由其他类完成所需要的操作。所以delegate是一对一关系。 block是delegate的另一种形式，是函数式编程的一种形式。使用场景跟delegate一样，相比delegate更灵活，而且代理的实现更直观。 KVO一般的使用场景是数据，需求是数据变化，比如股票价格变化，我们一般使用KVO（观察者模式）。delegate一般的使用场景是行为，需求是需要别人帮我做一件事情，比如买卖股票，我们一般使用delegate。 Notification一般是进行全局通知，比如利好消息一出，通知大家去买入。delegate是强关联，就是委托和代理双方互相知道，你委托别人买股票你就需要知道经纪人，经纪人也不要知道自己的顾客。Notification是弱关联，利好消息发出，你不需要知道是谁发的也可以做出相应的反应，同理发消息的人也不需要知道接收的人也可以正常发出消息。 KVC是键值编码，可以对属性或者是变量进行赋值的方法。 参考文章：http://www.tuicool.com/articles/2aYfy2Q:将一个函数跑到主线程中执行有哪几种方法A:将一个函数在主线程执行的4种方法 1.GCD方法，通过向主线程队列发送一个block块，使block里的方法可以在主线程中执行。 dispatch_async(dispatch_get_main_queue(), ^{ //需要执行的方法 }); 2.NSOperation 方法 NSOperationQueue mainQueue = [NSOperationQueue mainQueue]; //主队列 NSBlockOperation operation = [NSBlockOperation blockOperationWithBlock:^{ //需要执行的方法 }]; [mainQueue addOperation:operation]; NSThread 方法 [self performSelector:@selector(method) onThread:[NSThread mainThread] withObject:nil waitUntilDone:YES modes:nil]; 3.performSelector方法：[self performSelectorOnMainThread:@selector(method) withObject:nil waitUntilDone:YES]; [[NSThread mainThread] performSelector:@selector(method) withObject:nil]; 4.RunLoop方法 [[NSRunLoop mainRunLoop] performSelector:@selector(method) withObject:nil];Q:如何让计时器调用一个类方法A:计时器只能调用实例方法，但是可以在这个实例方法里面调用静态方法。 使用计时器需要注意，计时器一定要加入RunLoop中，并且选好model才能运行。scheduledTimerWithTimeInterval方法创建一个计时器并加入到RunLoop中所以可以直接使用。 如果计时器的repeats选择YES说明这个计时器会重复执行，一定要在合适的时机调用计时器的invalid。不能在dealloc中调用，因为一旦设置为repeats 为yes，计时器会强持有self，导致dealloc永远不会被调用，这个类就永远无法被释放。比如可以在viewDidDisappear中调用，这样当类需要被回收的时候就可以正常进入dealloc中了。 [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerMethod) userInfo:nil repeats:YES]; -(void)timerMethod { //调用类方法 [[self class] staticMethod]; } -(void)invalid { [timer invalid]; timer = nil; }Q:如何重写类方法A:1、在子类中实现一个同基类名字一样的静态方法 2、在调用的时候不要使用类名调用，而是使用[self class]的方式调用。原理，用类名调用是早绑定，在编译期绑定，用[self class]是晚绑定，在运行时决定调用哪个方法。Q:NSTimer创建后，会在哪个线程运行A:用scheduledTimerWithTimeInterval创建的，在哪个线程创建就会被加入哪个线程的RunLoop中就运行在哪个线程 自己创建的Timer，加入到哪个线程的RunLoop中就运行在哪个线程。Q:id和NSObject＊的区别A:id是一个 objc_object 结构体指针，定义是 typedef struct objc_object *id。 id可以理解为指向对象的指针。所有oc的对象id都可以指向，编译器不会做类型检查，id调用任何存在的方法（必须是编译器已知的存在的方法）都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。NSObject *指向的必须是NSObject的子类，调用的也只能是NSObjec里面的方法否则就要做强制类型转换。不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。著名iOS面试题：上篇：http://www.cocoachina.com/ios/20160414/15918.html?sukey=fa67fe3435f5c4bec4809ce4c499e05b85d4c26f4443605cebf14791b882ab25b669fb48c4d21ffe302ac6220b5b7b9a要点解析：（仅提供大纲级别的讲解，详情请参考文章细节）iOS crash解析： crash的分类： 违反iOS系统规则导致的crash：内存报警闪退，请使用Allocations 和 Leaks 工具检测响应超时，watchdog机制会kill进程并生成一份crash报告。主要由于applicationDelegate中的一些生命周期方法阻塞过久：application:didFinishLaunchingWithOptions: 完成启动applicationWillResignActive: 放弃活动状态applicationDidEnterBackground: 进入后台applicationWillEnterForeground: 进入前台applicationDidBecomeActive: 进入活动状态applicationWillTerminate: 程序正常退出用户强制结束app：双击HOME键然后kill掉进程一般不会产生crashLog。因为此时所有进程都处于后台状态，iOS随时可以关闭后台应用，而不会产生crashLog。主要是长按电源键，等出现关机界面后，再按Home键即可终止当前程序。此时应用仍然处于前台状态。App代码逻辑BUG导致的crash：SEGV：（Segmentation Violation，段违例），无效内存地址，比如空指针，未初始化指针，栈溢出等SIGABRT：收到Abort信号，可能自身调用abort()或者收到外部发送过来的信号SIGBUS：总线错误。与SIGSEGV不同的是，SIGSEGV访问的是无效地址（比如虚存映射不到物理内存），而SIGBUS访问的是有效地址，但总线访问异常（比如地址对齐问题SIGILL：尝试执行非法的指令，可能不被识别或者没有权限SIGFPE：Floating Point Error，数学计算相关问题（可能不限于浮点计算），比如除零操作SIGPIPE：管道另一端没有进程接手数据常见的crash收集框架crashLog分析方法Run Loop解析：定义：Run Loop是一让线程能随时处理事件但不退出的机制。RunLoop 实际上是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。Runloop Mode分类：kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用RunLoop的作用：使程序一直接受用户输入决定程序在何时应该处理哪些Event调用解耦节省CPU时间主线程的run loop默认是启动的。对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动。驱动辅助线程的RunLoop:BOOL isRunning = NO; do { isRunning = [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDatedistantFuture]];} while (isRunning);Run loop同时也负责autorelease pool的创建和释放:Run loop就为我们做了这样的工作，每当一个运行循环结束的时候，它都会释放一次autorelease pool，同时pool中的所有自动释放类型变量都会被释放掉.线程和进程： 进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。线程可以有效地提高系统的执行效率，但并不是在所有计算机系统中都是适用的，如某些很少做进程调度和切换的实时系统。使用线程的好处是有多个任务需要处理机处理时，减少处理机的切换时间；而且，线程的创建和结束所需要的系统开销也比进程的创建和结束要小得多。最适用使用线程的系统是多处理机系统和网络系统或分布式系统。iOS多线程编程的技术共有四种技术：NSThread，NSOperation，GCD（全称：Grand Central Dispatch）,pthread。使用 GCD时，在当前线程上 使用 dispatch_sync 至当前线程（包括依赖树关系 set_target） 会导致死锁。SQL调优常用的动画库：Facebook 开源动画库 Pop：是一个「动画引擎。Pop 则是对 Core Animation（以及 UIDynamics）的再实现。Canvas 项目：是一个「动画合集」。Canvas 的目的是「Animate in Xcode Without Code」。开发者可以通过在 Storyboard 中指定 User Defined Runtime Attributes 来实现一些 Canvas 中预设的动画，也就是他网站上能看到的那些。但是除了更改动画的 delay 和 duration 基本上不能调整其他的参数。服务端Restful架构SDWebImage的原理中篇：http://www.cocoachina.com/ios/20160415/15930.html?sukey=fa67fe3435f5c4be1405835f6dad58cf6418c5f3267a51eae77ede79422f04971ce60f36b822c7766841684df32120ff要点解析：（仅提供大纲级别的讲解，详情请参考文章细节）翻转二叉树： 递归实现深度遍历（基于stack数据结构，可以采用OC数组来模拟）广度遍历（基于queue的数据结构，可以采用OC数组来模拟）单例写法：dispatch_onceiOS应用生命周期主要涉及对象：UIApplication (由系统创建)、appDelegate常见的生命周期函数以及它们的调用时机后台任务调用语句：（需要在 applicationDidEnterBackground 中调用） [application beginBackgroundTaskWithExpirationHandler:^{ NSLog(@"begin Background Task With Expiration Handler"); }]; 程序进入后台立即终止的条件：iOS 4.0以前的系统 或者 app是基于iOS4.0以前系统开发的在Info.plist文件中，程序包含了 UIApplicationExitsOnSuspend 键系统常常是为其他app启动时由于内存不足而回收内存最后需要终止应用程序，但有时也会是由于app很长时间才响应而终止。如果app当时运行在后台并且没有暂停，系统会在应用程序终止之前调用app的代理的方法 - (void)applicationWillTerminate:(UIApplication *)application，这样可以让你可以做一些清理工作。你可以保存一些数据或app的状态。这个方法也有5秒钟的限制。超时后方法会返回程序从内存中清除集成支付宝SDK的方法远程推送下篇：http://www.jianshu.com/p/5178204a58d6要点解析：Runtime：runtime使用指南关于copy这一块的内容不准确NSTimer加入到那个线程的RunLoop就在哪个线程执行。通知Post所在的是哪个线程， 就在哪个线程同步执行。如何让NSTimer、Notification回调到类方法：在回调的成员方法中，再调用特定的类方法即可。load 和 initialize 的区别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS符号表文件]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[iOS符号表文件 符号表文件：即存有当前app的符号信息的文件，符号信息包括 各种常量（字符串、数字等）、可视化的语句信息等。 三种取到符号表文件的渠道： IPA包：IPA包解压后，里面会有一个同名的无后缀可执行文件，那里面就含有符号表信息。（但要注意，从App Store中下载的文件不能取到符号表，因为苹果做了额外的加密操作） Product文件夹：代码直接build到模拟器或者设备后，在Product文件夹下面会有相应的app存在，显示包内容，其内部就存在一个同名的符号表文件。 xrchiver文件：里面的dsym文件 和 app文件都可以取到符号表文件。 关于app中的符号表文件和dsym中的符号表文件的差异： app：该文件中含有更多的是机器码信息，当我们archive时，关于可视化语句的符号信息会被抽离到dsym中，但是常量和机器码信息会被残留下来。如果使用build方式的话，那么常量和可视化函数名信息都保留在其中。 dsym：里面只是单纯的保留了 可视化语句的函数信息与包偏移地址的对应关系，机器码和常量等都被剥离出来。 使用 Hopper Disassembler可以帮助我们分析符号表文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS通知相关内容【远程与本地】]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E9%80%9A%E7%9F%A5%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E3%80%90%E8%BF%9C%E7%A8%8B%E4%B8%8E%E6%9C%AC%E5%9C%B0%E3%80%91%2F</url>
      <content type="text"><![CDATA[iOS通知相关内容【远程与本地】接受到通知的不同场景处理逻辑：当收到通知时，应用处于未启动状态：根据注册的UINotofication的displaying alerts, playing sounds, and badging app icons设置来展示相应内容。【如果通知仅badging app icons，那么用户点击图标启动应用时不会带有通知的key】用户点击通知，那么会启动应用，在application:didFinishLaunchingWithOptions: 中传入的UserInfo中会包含UIApplicationLaunchOptionsLocalNotificationKey【本地通知】 / UIApplicationLaunchOptionsRemoteNotificationKey 【远程通知】，读取这两个字段判断是什么通知，并取到具体的value。本地通知可以获取到一个UILocalNotification 对象，而远程通知可以获取到一个字典【没有对应的通知对象类型】。当收到通知时，应用处于前台状态时：本地通知：- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification。远程通知：- (void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary*)userInfo当收到通知时，应用处于后台状态：根据注册的UINotofication的displaying alerts, playing sounds, and badging app icons设置来展示相应内容。当用户点击通知框后：本地通知回调：- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification。远程通知回调：- (void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary*)userInfo当用户收到通知时，执行了具体的按钮处理：如果应用没有启动，那么将在后台启动应用。在后台调用 - (void)application:(UIApplication *)application handleActionWithIdentifier:(NSString *)identifier forLocalNotification:(UILocalNotification *)notification completionHandler:(void (^)(void))completionHandler;【注意】：错误的执行completionHandler将导致应用被终端杀死。接受到通知应该做的处理：设置UIApplication的applicationIconBadgeNumber 为0.生成通知推送证书的步骤：http://saeapns.sinaapp.com/doc.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[project.pbxproj结构解析]]></title>
      <url>%2F2017%2F02%2F09%2Fproject.pbxproj%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[project.pbxproj结构解析 基本概念： 注释方式：/* xxx */ 之间的内容作为注释，整篇文档拥有非常完善的注释，有苹果自动生成。 pbxproj也是一个Property list文件，但是所采用的是NextStep公司开发的早期类XML格式，现在已经被废弃，估计只有苹果一家在用了。 基础语法： 数组：，使用“（）”大括号包裹，内部使用“,”划分。 字典：，使用“{}”花括号包裹字典，内部键值对采用 key = value 的形式组织，每一组键值对之间使用 “;”划分。 其他字段都是单一值字段 文件基本结构： 最主要的内容放在 objects 中 进阶概念： 当生成一个Target时，xcode会自动为这个Target分配一个ID，这个ID在之后只要这个Target存在，就不会再改变。 objects下主要的section划分： PBXBuildFile：是文件类，被PBXBuildPhase等作为文件包含或被引用的资源。其中isa跟Objc中的对象的isa指针一样,指向的是它的类,而fileRef则指向的是一个PBXFileReference对象。PBXBuildFile中的对象是编译时候需要使用到的文件和资源的集合（不一定是被编译，可能是复制）。 PBXFileReference：用于跟踪项目引用的每一个外部文件，比如源代码文件、资源文件、库文件、生成目标文件等。 PBXGroup：用于组文件，或者嵌套组。通过唯一标识符组装,每个PBXGroup对象都有一个children属性,里面可以是任何一种类的对象。但是这时候的PBXGroup指的是Xcode里面组织的分组结构,和实际文件系统中的结构并不相同。 指的注意的是,children中的每个文件对象都属于PBXFileReference类,而不是PBXBuildFile类 PBXNativeTarget：就是工程中的target,如果工程中有多个target,都会在这个section中有所体现。我们都知道每个target都有Compile Sources、Copy Bundle Resources、Link Binary With Libiaries这三个需要在编译时确定的内容。 而在PBXNativeTarget中通过buildPhases属性可以找到对应的内容。 PBXSourcesBuildPhase：用于构建阶段中编译源文件。 PBXResourcesBuildPhase：用于构建阶段需要复制的资源文件。 PBXProject：标识着整个工程,由根元素的rootObject引入，该对象记录着targets、mainGroup等重要信息,甚至每个target在创建时候的Xcode版本都会记录在其中。 XCConfigurationList：记录工程配置信息。 XCBuildConfiguration：记录工程编译配置信息。 常用的操作库： Ruby:Xcodeproj，这个库是CocoaPods用于操作pbxproj的库。【读写最优】 Python：mod_pbxproj，强大的 Python 解析库，支持一定的修改操作，可输出 OpenStep 格式，但是顺序和注释内容无法完美还原，有些鸡肋。但是修改后，可能导致注释顺序发生变化。目前CI打包平台用的是这个库来修改配置文件的。 watch target误删监控： 经过试验得知，当新建一个target时，会在PBXNativeTarget 中增加一个target对象，而且会在PBXProject 中增加关于这个Target的信息。 mod_pbxproj则中有一个接口get_target_by_name（ name ）通过对PBXNativeTarget 中所有对象的遍历可以获取到指定name的target，如果获取不到就会会返回None。 mod_pbxproj库的地址：https://github.com/kronenthaler/mod-pbxproj#installation 安装其实直接使用这个文件即可，pip和setup.py都太慢了。 使用时，直接导入语句：from mod_pbxproj import XcodeProject 即可。 如下即实现了一个target查询的操作： from mod_pbxproj import XcodeProject project = XcodeProject.Load('/Users/chengjianfeng/Desktop/sample.pbxproj') mainTarget = project.get_target_by_name("TestProject1") if mainTarget: print "exist"else: print "not exist" 示例文档： double.pbxprojdelete.pbxprojsample.pbxproj sample：最开始只有一个target的工程 double：添加了watch target的工程 delete：直接删除watch target的工程 参考文章： 结构分析：http://www.cnblogs.com/gongyuhonglou/p/5570864.html 字段详解：http://www.cocoachina.com/ios/20161008/17689.html?utm_source=tuicool&amp;utm_medium=referral 解析工具推荐：http://www.aiweibang.com/yuedu/155382255.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用NSInputStream完成分步数据读入]]></title>
      <url>%2F2017%2F02%2F09%2F%E4%BD%BF%E7%94%A8NSInputStream%E5%AE%8C%E6%88%90%E5%88%86%E6%AD%A5%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%85%A5%2F</url>
      <content type="text"><![CDATA[使用NSInputStream完成分步数据读入//文章中的代码在线程并发处理上存在问题，请参考自己封装的CJFFileReader.参考文章：http://www.android100.org/html/201502/15/119120.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YYKit学习笔记:YYCategories]]></title>
      <url>%2F2017%2F02%2F09%2FYYKit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%3AYYCategories%2F</url>
      <content type="text"><![CDATA[YYKit学习笔记:YYCategoriesYYKitMacro： 宏定义相对于内联函数的好处： 变量的作用域是共享的，不需要考虑传参和返回值这些问题 __typeof__(var) 是gcc对C语言的一个扩展保留字，用于声明变量类型,var可以是数据类型（int， char*..),也可以是变量表达式。 - 使用do{ } while(0)的好处： 替代{},实现局部作用域.在一些C的实现里也可以用. 避免使用GOTO,用break做跳出。当你执行一段代码到一半，想跳过剩下的一半的时候，如果你正处于do while循环中，则能用break达到这个目的. extern “C” ：用于声明这个函数使用C语言方法编译和定义，那么，编译器不会对函数名做出修改。参考文章：http://www.jianshu.com/p/5d2eeeb93590。 在静态lib中引入分类的隐患： 官方解释：https://developer.apple.com/library/mac/qa/qa1490/_index.html。需要在 other link flag 中添加 -Objc/-force_load/-all_load，来确保这些分类会被正确的link到可执行文件中，但这会引起可执行文件变大，且有很多不必要的收集，因此其默认是关闭的。 关于不同等级的配置参数 -Objc、-force_load、-all_load 的具体差别，可以参考文章：https://my.oschina.net/u/728866/blog/194741 在YY中提出一种新方案：在每个实现文件.m引入假类（使用宏定义生成，并没有实际作用），假类的存在导致link会链接这个文件（但 -Objc标志依然需要添加 ），从而分类函数被顺利的加载进去。 使用 pthread_main_np()判断是不是主线程，是最为有效的，如果返回值大于0，就表示是主线程。 宏定义尽量限制范围，局部宏定义要在出去前使用 #undef 取消该宏定义。 苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为nonnull，因此我们只需要去指定那些nullable的指针。 NSobject+YYAdd: C语言可变参数的使用方法：（OC是C的严格超集） 使用 … 表示可变参数。 va_list 本身就是一个指针类型，用于获取指向变参的开始地址的指针 va_start(ap, param)：对ap 进行初始化，让它指向可变参数表里面的第一个参数。宏的第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“...”之前的那个参数； va_arg(ap, type)：它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置。 va_end(ap)：获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。、 使用示例： 关于在MRC下启用 __weak 标识的方法：http://stackoverflow.com/questions/36147625/xcode-7-3-cannot-create-weak-reference-in-file-using-manual-reference-counting 手动方法调配技术（有性能问题，不适合频繁调用）： 消息转发中的方法调配技术：runtime使用指南 方法调配技术中 sig里的参数类型分类：http://blog.csdn.net/dean19900504/article/details/8737862 手动实现完整的方法调配的代码：请直接参考NSObject+YYAdd的 performSelectorXXX方法。 使用 NSKeyedArchiver 和 NSKeyedUnarchiver 的归档技术，来实现对象的 deepCopy。但是这两个方法依赖于我们自己的对象实现 NSCoding 协议，这个协议有两个方法：-(void)encodeWithCoder:(NSCoder *)encoder 和 -(id)initWithCoder:(NSCoder *)decoder。 NSObject+YYAddForKVO: KVO &amp;&amp; KVC 教程 __FLT_EPSILON__: 表示最小的浮点数，大小约为1.192092896e-07F 。 可以用于判断一个浮点数是否非0. NSString+YYAdd: 将string转化为C字符数组的方法： API : - (void)getCharacters:(unichar *)buffer range:(NSRange)range; 用法示例： //注意，NSString 统一采用 unicode编码，所以需要使用 unichar 来承载unichar *buf = malloc(sizeof(unichar) * hexStr.length);if (!buf) return nil;[hexStr getCharacters:buf range:NSMakeRange(0, hexStr.length)]; 对于ASCII码中的字符，他们在 unicode 中的编码数值并没有发生变化。 unicode是一个字符集，他决定了字符的编码值是多少。 UTF-8是一个编码方式，它决定具体的编码值如何采用字节来表示。 将C字符串转化为string的方法： 各种初始化方法很多 需要注意的是，要根据 unichar 和 char 的不同去使用不同的函数初始化。 UUID： UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。 计算标准：按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。 实现效果：一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。 NSThread+YYAdd: threadDictionary:用于存储一些指定的线程数据 实现非reatin方式的CFMutableArray ： 参考文章：http://www.cnblogs.com/lilfqq-IOS/archive/2012/04/20/2458990.html 主要步骤：在 CFArrayCreateMutable 新建时，对于 callBack 字段的结构体，传入 retain 和 release 被赋值的结果。 主线程的runloop上会有 autoreleasePool自动管理，即每一次runloop状态切换时，都会清理一次pool，释放临时变量。而在次线程上，autoreleasepool则需要我们自己管理。而且，这个pool，一定要做成 栈模型。 需要监视的runloop活动：（可以想见，系统的主线程也是在模式切换时进行autoreleasePool的释放,可以参见NSAutoReleasePool Reference） kCFRunLoopEntry：在runloop进入某个模式前调用（这一对组合在整个runloop生命周期中会多次调用），与kCFRunLoopExit成对出现，最明显的例子就是在scroolView滚动开始前调用一次exit和entry，然后在结束时会再调用一次exit和entry。此时，我们开启一个pool。优先级最高。 kCFRunLoopBeforeWaiting：在runloop进入休眠前调用。此时我们关闭一个最近的pool，并开启一个新的pool。优先级最低。 kCFRunLoopExit：在runloop退出某个模式之前调用。此时我们关闭一个pool。优先级最低。 上面的优先级考虑很有意义，充分考虑到了autoreleasePool的作用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS外部条件触发调试技巧]]></title>
      <url>%2F2017%2F02%2F09%2FiOS%E5%A4%96%E9%83%A8%E6%9D%A1%E4%BB%B6%E8%A7%A6%E5%8F%91%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[iOS外部条件触发调试技巧适用场景：静默推送唤醒watch消息唤醒调试方式：Xcode调试方式（适用于设备及模拟器）：在 Scheme -> Run -> &nbsp;&nbsp;Info 中，将 Launch 方式改为 Wait for executable to be launched。这个改动将使设备等待外部条件去触发app运行，而不是主动启动app。默认是Automatically。log打印方式（适用于设备）：适用NSLog输出，在Xcode -&gt; Devices -&gt; 中选中相应的设备，可以看到它的控制台，然后可以查看输出。日志文件记录：将输出记录在本地文件，然后再读取。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基本Crash编程指南]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%9F%BA%E6%9C%ACCrash%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[基本Crash编程指南ios崩溃分类：【两大类】NSException:程序抛出的异常，没有被捕获造成的。分类：NSGenericException：一般性异常。比如迭代器错误。NSRangeException：范围异常，通常发生在数组越界上。NSInvalidArgumentException：无效参数错误，比如消息转发出错，把一个消息转发给一个无法处理这则消息的对象：unrecognized selector sent to instance 0x1756f5f0。NSInternalInconsistencyException：内部不一致异常。可能发生在Main.storyboard配置出错，以及UITableView的数据源和你插入或者删除的操作不一致等地方。NSFileHandleOperationException：文件操作相关的异常。NSObjectNotAvailableExceptionNSDestinationInvalidExceptionNSPortReceiveExceptionNSInconsistentArchiveExceptionNSFileHandleOperationException…...参考资料：https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Exceptions/Concepts/PredefinedExceptions.html#//apple_ref/doc/uid/20000057-BCIGHECASignal：各种其他类型的异常。分类：SEGV:无效内存地址，比如空指针，未初始化指针，栈溢出，zombie对象访问等SIGBUS：总线错误。与SIGSEGV不同的是，SIGSEGV访问的是无效地址（比如虚存映射不到物理内存），而SIGBUS访问的是有效地址，但总线访问异常（比如地址对齐问题）SIGABRT：收到Abort信号，可能自身调用abort()或者收到外部发送过来的信号SIGILL：尝试执行非法的指令，可能不被识别或者没有权限SIGFPE：Floating Point Error,数学计算相关问题,比如除零操作SIGPIPE：管道另一端没有进程接手数据参考资料：signal函数：http://en.cppreference.com/w/c/program/signal signal handler详解：www.cnblogs.com/clover-toeic/p/4126594.html在【Linux】上若信号与硬件故障(如SIGBUS/SIGFPE/SIGILL/SIGSEGV)或定时器超时相关，该信号会发往引起该事件的线程。其它信号除非显式指定目标线程，否则通常发往主线程(哪怕信号处理函数由其他线程注册)，仅当主线程屏蔽该信号时才发往某个具有处理能力的线程。【UNIX -&gt; BSD\Linux\FreeBSD -&gt; Mac OS】区别对比：信号由操作系统发出，更为底层，与程序的执行是异步的，由特殊的处理函数进行异步处理（signal / signaction），与程序语言之间几乎没有集成，处理难度更大。（编程语言）异常则由程序语言和运行时提供，是一种可控的、同步激发处理、被语言和运行时支持的、可进行结构化处理的流程控制机制（与 return 和 if else for while 等没有本质区别）。总的来说，后者处理过程由于是语言直接支持的，难度较小，资源管理较容易，是一种比较「高级」的机制。后者是可以基于前者实现（也可以完全无关）。除非环境明确要求，一般的程序流程控制只涉及后者；如果环境支持，可能会将 OS 发出的信号包装成对应的异常交给应用处理。NSException与NSError内容：基础知识：ARC在默认情况下NSException不是线程安全的，具体来说就是如果抛出异常，那么本应在作用域尾释放的对象现在却不会自动释放了。如果想生成异常安全代码，那么需要添加额外的编译标志： -fobjc-arc-exceptions，但是一旦添加，在未抛出异常时也会执行这段代码，使程序显得臃肿，效率下降。对此IOS的异常使用策略是：只在极其极端的情况下才抛出异常，异常一旦抛出就无需考虑恢复问题，而且程序此时应该退出。（俗称crash）对于出现不那么严重的错误，我们通常可以返回 nil，或者 通过NSError**返回NSError对象来描述异常。 前者通常用于带有返回值的函数调用中。后者通常用于 delegate回调 以及普通函数调用中。当文件处于 objective-C++模式时，编译器会自动把 -fobjc-arc-exceptions 打开。NSError对象探究：（可以参考P87）其有三大主要参数：Error domain (错误范围，字符串)、Error code（错误类型，整数型）、User Info(用户信息，字典)。具体内部用法和外部用法可以参考P87try-catch-finally的执行顺序探究：（尽量不要使用，因为NSException 存在资源管理问题或者效率问题）使用 try-catch-finally来捕获异常。在三段式的结构中，如果发生什么，finally中的语句都将被执行。（即使是在 catch中再次抛出异常，需要打断当前函数执行，进入上一层异常处理时，也是需要先执行finally再执行上层语句的）如果异常不能被当前的函数捕获，那么当前函数的执行将立即被打断，并将异常向上一级传递处理。具体可以参考文中代码实验。参考文章：http://www.cocoachina.com/ios/20141229/10787.html附加：使用assert语句判断正确：在assert（ 表达式 ），当表达式结果为NO时，abort。单个crash文件解析方案：（所需文件： xxx.app xxx.app.dsym xxx.crash ）export DEVELOPER_DIR="/Applications/XCode.app/Contents/Developer"/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash Jdipad.crash Jdipad.app.dSYM &gt;crash.txt单条crash语句解析方案：atos的语法： atos -arch &lt;体系架构&gt; -o &lt;符号表文件&gt; -l &lt;0x程序基地址&gt; &lt;0x语句地址&gt; =&gt; 选取方案atos -arch &lt;体系架构&gt; -o &lt;符号表文件&gt; &lt;0x偏移地址&gt;地址： 获取到该crash语句的 基地址（即Jdipad程序的object_addr） 和 语句符号地址 （即Jdipad程序的symbol_addr）。注意需要转换到16进制地址，且例如 0x12412314124,注意 前缀是必须的。一个符号表文件的程序开始位置不一定是0，每个符号表可能是不同的，一般是0x1000或者0x4000，体系架构：获取发生该崩溃的机器的体系结构（armv7\armv7s\arm64）。注意，这个体系结构是设备向下兼容体系，即如果一台armv7s的设备，但包没有armv7s的体系结构只有armv7和arm64的体系结构，那么该设备将运行在 armv7 的体系结构代码上。符号表文件：将 dSYM 文件 或者是 .app 文件放在同一目录下： 使用 dSYM文件是一定可以解析成功的，里面包含所有的符号表信息：使用语句 atos -arch &lt;armxxx&gt; -o Jdipad.app.dSYM/Contents/Resources/DWARF/Jdipad -l &lt;baseaddr&gt; &lt;symboladdr&gt;使用 .app文件解析也是可以的，但是要求.app在编译时将 strip style 选为 all symbols，并且 strip debug symbols during copy 选为 YES，此时.app内的二进制文件是可以接受解析的，否则是无效的。具体使用语句：atos -arch &lt;armxxx&gt; -o Jdipad.app/Jdipad -l &lt;0x baseaddr&gt; &lt;0x symboladdr&gt;如果找不到symbolicatecrash，可以使用 find /Applications/Xcode.app -name symbolicatecrash -type f 来查找。参考文章：http://blog.csdn.net/mkhgg/article/details/17247673KSCrash上报中的字段： baseaddr + symboladdr 能解析出的是函数调用者的起始行代码baseaddr + instructionaddr 能解析出的是 函数具体行的代码atos可以一次性解析多个数据：【这样可以显著提升速度】atos -o /BuildProducts/Release/Sketch.app/Contents/MacOS/Sketch -arch x86_64 -l 0x10acde000 0x10acea1d3 0x10ace4bea 0x10ace4b7a-[SKTGraphicView drawRect:] (in Sketch) (SKTGraphicView.m:445)-[SKTGraphic drawHandlesInView:] (in Sketch) (NSGeometry.h:110)-[SKTGraphic drawHandleInView:atPoint:] (in Sketch) (SKTGraphic.m:490)在符号表中，同一行代码调用在不同的arch中都是在同一个偏移位置的，因此必须在 atos 中指明 -arch 才能正确的解析数据。release版本crash调试方案：使用数据线连接上设备选中相应的设备，然后点击下方的箭头条以此可以调出设备的控制台其上会输出设备的控制台输出，此时，app如果有nslog，会选择输出到此处的控制台。基础crash上报方案：Apple Developer文章：https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012-BAJGFBFB基础crash捕捉机制： 使用try-carch机制捕获crash：http://www.cocoachina.com/ios/20141229/10787.html使用信号量和异常回调函数捕捉crash：http://www.xuebuyuan.com/1593344.html方案评价： 该方案针对 NSException引起的crash，可以完美的捕捉到，并且根据崩溃的线程打印出crash线程的stack信息。但是针对 signal引起的crash，将统一回调到主线程处理，打印主线程的调用栈信息。此时的信息是无效的。具体实现： 如果是NSException的异常，可以获取到以下完整信息： [exception name]: 独一无二的exception编号[exception reason]: 具体崩溃的原因[exception callStackSymbols]: 是一个数组，返回了发生崩溃所在的线程的调用栈信息（注意，仅针对发生崩溃的线程）。我们使用 【arr description】即可转化为 string并上报。如果是signal异常： 可以使用 backtrack（xx,xx） 和 backtrace_symbols( xx,xx )：获取到当前线程的调用栈。旧版本crash修复操作：参考文章：http://www.cocoawithlove.com/2010/05/handling-unhandled-exceptions-and.html续命方法：收集到数据后，将exception push到主线程2.重启主线程的runloop代价：这将导致异常线程使用的堆栈内存被永久的泄露，且崩溃函数永远无法返回。同时只能应对较为简单的崩溃。缺陷：有可能会失败，只能应对简单的crash。Mac机上获取Symbol：文件主路径：~/Library/Developer/Xcode/iOS DeviceSupport，该目录以系统作为划分依据。具体子目录：Symbols/System/Library/Frameworks：公有框架，每个框架文件里的同名文件，就是符号表文件。比如 xxx.framework/xxx需要注意的是，框架可能还会有自己引用的framework和dylib，可以考虑递归获取。Symbols/System/Library/PrivateFrameworks：公有框架，每个框架文件里的同名文件，就是符号表文件。比如 xxx.framework/xxx需要注意的是，框架可能还会有自己引用的framework和dylib，可以考虑递归获取。Symbol/usr/lib:下面有很多 dylib框架Symbol/usr/lib/system:下面有很多 dylib框架脚本文件：search_bin.sh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode宏、关键字与常用函数]]></title>
      <url>%2F2017%2F02%2F09%2FXcode%E5%AE%8F%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[Xcode宏、关键字与常用函数最基础的宏：硬件相关宏：【可以参见文件 TargetConditionals.h . 】 __ppc__：表示32位PowerPC架构__ppc64__：表示64位PowerPC架构__i386__：表示32位x86架构__x86_64__：表示64位x86架构__arm__：表示32位ARM架构，即AArch32__arm64__：表示64位ARM架构，即AArch64__ARM_VFPV4__：表示支持VFPv4特性的ARM处理器__FMA__：表示处理器支持硬件FMA计算__LP64__：表示指针长度为64位，即地址长度以64位长度来表示项目配置预编译宏：在 Target -&gt; Build Setting 中的Preprocessor Macro 中添加。默认会有一个 DEBUG = 1 的宏定义。但在JD工程中已被删除。自定义宏及用法：对于变量宏来说，一共有两种定义方式： 专用于编译时判断的宏，其只需要定义 #define name 即可不需要对于赋值。其也只能用于 #ifdef xxx 、 #ifndef xxx 和 defined( xxx ) 中。可用于任何情况的宏，其需要严格遵守与 #define name value。 其即可以参与实际代码的常量定义，也可以作为预编译时的判断。其在覆盖上述用法的同时，还可以用于 #if 等判断。对于函数宏 来说，记住在最外围带上括号定义即可。宏定义集合 与 条件判断语句 ：http://blog.sina.com.cn/s/blog_a573f7990101eazl.html基础关键字：IBOutlet : 其实等同于void，但是是用于标示该属性或者方法与 xib 或者 storyBoard相关联。__weak：用于声明一个 weak实例变量。__strong ：用于声明一个 strong实例变量。__typeof( ):用于在编译时确认一个对象的类型。注意，这个动作在编译时就已经完成了。（好在OC也没有动态对象）__Nonnull : 不允许参数为 nilnullable ： 允许参数为nil@encode( 内部表示量 ) ，可以将 各种类型（内置类型、类类型、C语言结构等） 转化为其名字的 char *字符串。使用 strcmp( x1 , x2 )，使用上一步得到的字符串可以动态的比较类型是否相同。__cmd：当前OC方法的SEL。可以参见文件 NSObjcRuntime.h.其中这几个宏比较常用： NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为nonnull，因此我们只需要去指定那些nullable的指针。FOUNDATION_EXPORT 和 FOUNDATION_IMPORT 可以用于表示该函数或者是变量框架内共享。打印关键字：宏说明__func__打印当前函数或方法，c字符串__LINE__打印当前行号，整数__FILE__打印当前文件路径，c字符串__PRETTY_FUNCTION__打印当前函数或方法（在C++中会包含参数类型），c字符串高级关键字以及宏应用：## ：在宏定义中，表示连接作用。比如：#define LRWeakSelf(type) __weak typeof(type) weak##type = type; 这一句话中，##在预处理阶段将把weak和type连接起来，形成一个新的标识符。# ：在宏定义的内容中，表示 “” 作用。可以将一个表达式，转化为C字符串。如果使用@#，那么就可以变为OC字符串。比如： #define LRToast(str) [NSString stringWithFormat:@"%@",@#str]//这个宏需要这样写LRToast(温馨提示);//正常运行, 打印不会报错NSLog(@"%@",LRToast(温馨提示));/ ：用于多行宏定义。需要注意的是 /的右边不能再存在任何字符，连空格和注释都不行。全部构造函数和全局析构函数：（以下函数存在多个也可以正常执行，且第三方库中也可以正常预先加载并执行【亲身试验过】） C中在main函数开始前之前执行的构造函数（修饰前缀）： __attribute__((constructor)) 函数定义C中在main函数退出后执行的析构函数（修饰前缀）： __attribute__((destructor)) 函数定义注意，该函数在+load()函数之后调用，相对更加安全。但是更安全的是直接写在main.m函数中。OC转化相关函数：NSStringFromSelector：SEL -&gt; stringNSSelectorFromString: string -&gt; SELNSStringFromClass: Class -&gt; stringNSClassFromString : string -&gt; ClassNSStringFromProtocol: Protocol -&gt; stringNSProtocolFromString string -&gt; Protocol@selector(xxxx)：比如@selector(test) 将会生成名为test的SEL。栈信息相关：-[NSException callStackSymbols] 获取当前错误的栈，是一个NSArry，包含堆栈中所有函数名 [NSThread callStackSymbols]获取当前线程的栈，是一个NSArry，包含堆栈中所有函数名设置自己工程的常用宏代码：#include &lt;TargetConditionals.h&gt;//定义自己的平台宏#define CJF_HOST_IOS TARGET_OS_IOS#define CJF_HOST_TV TARGET_OS_TV#define CJF_HOST_WATCH TARGET_OS_WATCH#define CJF_HOST_MAC (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH))//UIKIT相关宏#if CJF_HOST_IOS || CJF_HOST_TV#define CJF_HAS_UIKIT 1#else#define CJF_HAS_UIKIT 0#endif//thread API相关宏#if CJF_HOST_MAC || CJF_HOST_IOS || CJF_HOST_TV#define CJF_HAS_THREADS_API 1#else#define CJF_HAS_THREADS_API 0#endif//reachability相关宏#if CJF_HOST_MAC || CJF_HOST_IOS || CJF_HOST_TV#define CJF_HAS_REACHABILITY 1#else#define CJF_HAS_REACHABILITY 0#endif]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apple设备型号]]></title>
      <url>%2F2017%2F02%2F09%2FApple%E8%AE%BE%E5%A4%87%E5%9E%8B%E5%8F%B7%2F</url>
      <content type="text"><![CDATA[Apple设备型号获取代码：获取系统信息的通用代码：#include &lt;sys/sysctl.h&gt;//以下为获取系统信息的通用代码#define CHECK_SYSCTL_NAME(TYPE, CALL) \if(0 != (CALL)) \{ \ NSLog("Could not get %s value for %s: %s", \ #CALL, name, strerror(errno)); \ return 0; \}size_t kssysctl_stringForName(const char* const name, char* const value, const size_t maxSize){ size_t size = value == NULL ? 0 : maxSize; CHECK_SYSCTL_NAME(string, sysctlbyname(name, value, &amp;size, NULL, 0)); return size;}+ (NSString*) stringSysctl:(NSString*) name{ NSString* str = nil; size_t size = kssysctl_stringForName([name cStringUsingEncoding:NSUTF8StringEncoding], NULL, 0); if(size &lt;= 0) { return @""; } NSMutableData* value = [NSMutableData dataWithLength:size]; if(kssysctl_stringForName([name cStringUsingEncoding:NSUTF8StringEncoding], value.mutableBytes, size) != 0) { str = [NSString stringWithCString:value.mutableBytes encoding:NSUTF8StringEncoding]; } return str;}获取设备型号的代码： 【【self class】 stringSysctl ：@"hw.machine"】iPad设备型号：参考文档：https://en.wikipedia.org/wiki/IPad【Apple官方维护，信息更新及时】 里面并没有iPad设备型号，但是可以知道有哪些iPad版本，以及每个iPad版本有多少细分版本。如果希望获取的是A1219这样的序列号，可以直接从wiki上面获取。iPad 1.x: 【iPad1】iPad(wifi)=iPad1,1A1219 iPad(GSM)=iPad1,2A1337iPad 2.x: 【iPad2】iPad2(wifi)=iPad2,1A1395 iPad2(GSM)=iPad2,2A1396 iPad2(GSM+CDMA)=iPad2,3A1397 iPad2(new wifi)=iPad2,4A1395【iPad mini】iPad mini(wifi)=iPad2,5A1432 iPad mini(GSM)=iPad2,6A1454 iPad mini(GSM+CDMA)=iPad2,7A1455iPad 3.x: 【The New iPad】iPad3](wifi)=iPad3,1A1416 iPad3(CDMA)=iPad3,2A1403 iPad3(GSM)=iPad3,3A1430 【iPad4】iPad4(wifi)=iPad3,4A1458 iPad4(GSM)=iPad3,5A1459 iPad4(GSM+CDMA)=iPad3,6A1460iPad 4.x： 【iPad Air】iPad Air(wifi)=iPad4,1A1474 iPad Air(GSM+CDMA)=iPad4,2A1475 iPad Air(GSM+TD)=iPad4,3A1476【iPad mini2】iPad mini2(wifi)=iPad4,4A1489 iPad mini2(GSM+CDMA)=iPad4,5A1490 iPad mini2(GSM+TD)=iPad4,6A1491【iPad mini3】iPad mini3(wifi)=iPad4,7A1599 iPad mini3(GSM+CDMA)=iPad4,8A1600 iPad mini3(GSM+TD)=iPad4,9A1601iPad 5.x: 【iPad mini4】iPad min4(wifi) = iPad5,1A1538 iPad mini4 (Cellular)= iPad5,2A1550 【iPad Air2】iPad Air2(wifi) = iPad5,3A1566 iPad Air2( Cellular) = iPad5,4A1567iPad 6.x: 【iPad Pro 12'9】iPad Pro(wifi) = iPad6,7A1584 iPad Pro(Cellular ) = iPad6,8A1652【iPad Pro 9'7】iPad Pro(wifi) =A1673 iPad Pro(Cellular ) =A1674，A1675iPhone设备型号列表：参考文章：https://en.wikipedia.org/wiki/IPhone不如iPad的wiki直观，设备信息分散，体验不佳iPhone 1.x: iPhone 2G (A1203) = iPhone 1,1iPhone 3G (A1241/A1324) = iPhone 1,2iPhone 2.x:iPhone 3GS (A1303/A1325) = iPhone 2,1iPhone 3.x:iPhone 4 (A1332) = iPhone 3,1iPhone 4 (A1333) = iPhone 3,2iPhone 4 (A1349) = iPhone 3,3iPhone 4.x:iPhone 4S (A1387/A1431) = iPhone 4,1iPhone 5.x:iPhone 5 (A1428) = iPhone 5,1iPhone 5 (A1429/A1442) = iPhone 5,2iPhone 5c (A1456/A1532) = iPhone 5,3iPhone 5c (A1507/A1516/A1526/A1529) = iPhone 5,4iPhone 6.x:iPhone 5s (A1453/A1533) = iPhone 6,1iPhone 5s (A1457/A1518/A1528/A1530) = iPhone 6,2iPhone 7.x:iPhone 6 Plus (A1522/A1524) = iPhone 7,1iPhone 6 (A1549/A1586) = iPhone 7,2iPhone 8.x:iPhone 6s(A1633) = iPhone 8,1iPhone 6s Plus (A1634 ) = iPhone 8,2 iPhoneSE【疑似，时间点接近】iPhone 9.x:iPhone 7(A1660) = iPhone 9,1iPhone 7 Plus (A1661) = iPhone 9,2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基本容器collection对象性能分析]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%9F%BA%E6%9C%AC%E5%AE%B9%E5%99%A8collection%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[基本容器collection对象性能分析 文章要点： 介绍了主流的collection 分析了各个collection的优缺点 主要分析各个collection的性能 参考博客：http://www.cocoachina.com/industry/20140122/7735.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[KSCrash翻译版]]></title>
      <url>%2F2017%2F02%2F09%2FKSCrash%E7%BF%BB%E8%AF%91%E7%89%88%2F</url>
      <content type="text"><![CDATA[KSCrash翻译版KSCrashKSCrash功能简介：以下是KSCrash的一些主要特点：崩溃记录相关：跟踪未捕获的C ++异常的真正原因。处理只能在Mach级被捕获的错误，如堆栈溢出。处理在KSCrash本身（或在用户崩溃处理程序回调）的崩溃。崩溃上报相关：生成完整的苹果格式的报告，但有很多额外信息无法上报。记录大量额外的信息，使用JSON格式上报。它的可插拔的服务器报告架构可以很容易地适应任何API服务。提供用户可操作接口，用于提供额外的数据上报（在崩溃发生之前和崩溃中执行）。额外功能：支持32位和64位模式。记录僵尸（释放的）对象，并在需要的时候访问尝试它。恢复在僵尸对象或内存操作中被释放的NSException消息。On-device symbolication 在某种情况下支持离线re-symbolication（必要的IOS版本有许多功能已被删节）。在寄存器和堆栈上的自省对象（C String和Objective-C Object，包括变量）。提取额外的对象信息给exception参考（such as "unrecognized selector sent to instance 0xa26d9a0"等）转储堆栈内容。诊断崩溃原因（Crash Doctor）。KSCrash可以处理以下类型的崩溃：Mach kernel exceptionsFatal signalsC++ exceptionsObjective-C exceptionsMain thread deadlock (实验性质)Custom crashes (e.g. from scripting languages)KSCrash支持发送以下服务器的报告：HockeyQuincyKitVictoryEmail报告格式示例：下面是它可以生成报告的一些例子。新特性简介：C ++异常处理一般来说，如果您的应用程序终止由于未捕获的C ++异常，你得到的是这样的：normalThread&nbsp;&nbsp;0&nbsp;&nbsp;name:&nbsp;&nbsp; Dispatch&nbsp;&nbsp;queue:&nbsp;&nbsp;com.apple.main-thread Thread&nbsp;&nbsp;0&nbsp;&nbsp;Crashed: 0&nbsp;&nbsp;&nbsp;&nbsp;libsystem_kernel.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x9750ea6a&nbsp;&nbsp;0x974fa000&nbsp;&nbsp;+&nbsp;&nbsp;84586&nbsp;&nbsp;(__pthread_kill&nbsp;&nbsp;+&nbsp;&nbsp;10) 1&nbsp;&nbsp;&nbsp;&nbsp;libsystem_sim_c.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04d56578&nbsp;&nbsp;0x4d0f000&nbsp;&nbsp;+&nbsp;&nbsp;292216&nbsp;&nbsp;(abort&nbsp;&nbsp;+&nbsp;&nbsp;137) 2&nbsp;&nbsp;&nbsp;&nbsp;libc++abi.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04ed6f78&nbsp;&nbsp;0x4ed4000&nbsp;&nbsp;+&nbsp;&nbsp;12152&nbsp;&nbsp;(abort_message&nbsp;&nbsp;+&nbsp;&nbsp;102) 3&nbsp;&nbsp;&nbsp;&nbsp;libc++abi.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04ed4a20&nbsp;&nbsp;0x4ed4000&nbsp;&nbsp;+&nbsp;&nbsp;2592&nbsp;&nbsp;(_ZL17default_terminatev&nbsp;&nbsp;+&nbsp;&nbsp;29) 4&nbsp;&nbsp;&nbsp;&nbsp;libobjc.A.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x013110d0&nbsp;&nbsp;0x130b000&nbsp;&nbsp;+&nbsp;&nbsp;24784&nbsp;&nbsp;(_ZL15_objc_terminatev&nbsp;&nbsp;+&nbsp;&nbsp;109) 5&nbsp;&nbsp;&nbsp;&nbsp;libc++abi.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04ed4a60&nbsp;&nbsp;0x4ed4000&nbsp;&nbsp;+&nbsp;&nbsp;2656&nbsp;&nbsp;(_ZL19safe_handler_callerPFvvE&nbsp;&nbsp;+&nbsp;&nbsp;8) 6&nbsp;&nbsp;&nbsp;&nbsp;libc++abi.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04ed4ac8&nbsp;&nbsp;0x4ed4000&nbsp;&nbsp;+&nbsp;&nbsp;2760&nbsp;&nbsp;(_ZSt9terminatev&nbsp;&nbsp;+&nbsp;&nbsp;18) 7&nbsp;&nbsp;&nbsp;&nbsp;libc++abi.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04ed5c48&nbsp;&nbsp;0x4ed4000&nbsp;&nbsp;+&nbsp;&nbsp;7240&nbsp;&nbsp;(__cxa_rethrow&nbsp;&nbsp;+&nbsp;&nbsp;77) 8&nbsp;&nbsp;&nbsp;&nbsp;libobjc.A.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01310fb8&nbsp;&nbsp;0x130b000&nbsp;&nbsp;+&nbsp;&nbsp;24504&nbsp;&nbsp;(objc_exception_rethrow&nbsp;&nbsp;+&nbsp;&nbsp;42) 9&nbsp;&nbsp;&nbsp;&nbsp;CoreFoundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01f2af98&nbsp;&nbsp;0x1ef9000&nbsp;&nbsp;+&nbsp;&nbsp;204696&nbsp;&nbsp;(CFRunLoopRunSpecific&nbsp;&nbsp;+&nbsp;&nbsp;360) ...没办法追踪这个exception是什么或者它是从哪里抛出的。现在有了KSCrash，你将得到捕获的异常类型，描述，以及它抛出的位置：normalApplication&nbsp;&nbsp;Specific&nbsp;&nbsp;Information: ***&nbsp;&nbsp;Terminating&nbsp;&nbsp;app&nbsp;&nbsp;due&nbsp;&nbsp;to&nbsp;&nbsp;uncaught&nbsp;&nbsp;exception&nbsp;&nbsp;'MyException',&nbsp;&nbsp;reason:&nbsp;&nbsp;'Something&nbsp;&nbsp;bad&nbsp;&nbsp;happened...' Thread&nbsp;&nbsp;0&nbsp;&nbsp;name:&nbsp;&nbsp; Dispatch&nbsp;&nbsp;queue:&nbsp;&nbsp;com.apple.main-thread Thread&nbsp;&nbsp;0&nbsp;&nbsp;Crashed: 0&nbsp;&nbsp;&nbsp;&nbsp;Crash-Tester&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000ad80&nbsp;&nbsp;0x1000&nbsp;&nbsp;+&nbsp;&nbsp;40320&nbsp;&nbsp;(-[Crasher&nbsp;&nbsp;throwUncaughtCPPException]&nbsp;&nbsp;+&nbsp;&nbsp;0) 1&nbsp;&nbsp;&nbsp;&nbsp;Crash-Tester&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000842e&nbsp;&nbsp;0x1000&nbsp;&nbsp;+&nbsp;&nbsp;29742&nbsp;&nbsp;(__32-[AppDelegate(UI)&nbsp;&nbsp;crashCommands]_block_invoke343&nbsp;&nbsp;+&nbsp;&nbsp;78) 2&nbsp;&nbsp;&nbsp;&nbsp;Crash-Tester&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00009523&nbsp;&nbsp;0x1000&nbsp;&nbsp;+&nbsp;&nbsp;34083&nbsp;&nbsp;(-[CommandEntry&nbsp;&nbsp;executeWithViewController:]&nbsp;&nbsp;+&nbsp;&nbsp;67) 3&nbsp;&nbsp;&nbsp;&nbsp;Crash-Tester&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00009c0a&nbsp;&nbsp;0x1000&nbsp;&nbsp;+&nbsp;&nbsp;35850&nbsp;&nbsp;(-[CommandTVC&nbsp;&nbsp;tableView:didSelectRowAtIndexPath:]&nbsp;&nbsp;+&nbsp;&nbsp;154) 4&nbsp;&nbsp;&nbsp;&nbsp;UIKit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0016f285&nbsp;&nbsp;0xb4000&nbsp;&nbsp;+&nbsp;&nbsp;766597&nbsp;&nbsp;(-[UITableView&nbsp;&nbsp;_selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:]&nbsp;&nbsp;+&nbsp;&nbsp;1194) 5&nbsp;&nbsp;&nbsp;&nbsp;UIKit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0016f4ed&nbsp;&nbsp;0xb4000&nbsp;&nbsp;+&nbsp;&nbsp;767213&nbsp;&nbsp;(-[UITableView&nbsp;&nbsp;_userSelectRowAtPendingSelectionIndexPath:]&nbsp;&nbsp;+&nbsp;&nbsp;201) 6&nbsp;&nbsp;&nbsp;&nbsp;Foundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00b795b3&nbsp;&nbsp;0xb6e000&nbsp;&nbsp;+&nbsp;&nbsp;46515&nbsp;&nbsp;(__NSFireDelayedPerform&nbsp;&nbsp;+&nbsp;&nbsp;380) 7&nbsp;&nbsp;&nbsp;&nbsp;CoreFoundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01f45376&nbsp;&nbsp;0x1efa000&nbsp;&nbsp;+&nbsp;&nbsp;308086&nbsp;&nbsp;(__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__&nbsp;&nbsp;+&nbsp;&nbsp;22) 8&nbsp;&nbsp;&nbsp;&nbsp;CoreFoundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01f44e06&nbsp;&nbsp;0x1efa000&nbsp;&nbsp;+&nbsp;&nbsp;306694&nbsp;&nbsp;(__CFRunLoopDoTimer&nbsp;&nbsp;+&nbsp;&nbsp;534) 9&nbsp;&nbsp;&nbsp;&nbsp;CoreFoundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01f2ca82&nbsp;&nbsp;0x1efa000&nbsp;&nbsp;+&nbsp;&nbsp;207490&nbsp;&nbsp;(__CFRunLoopRun&nbsp;&nbsp;+&nbsp;&nbsp;1810) 10&nbsp;&nbsp; CoreFoundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01f2bf44&nbsp;&nbsp;0x1efa000&nbsp;&nbsp;+&nbsp;&nbsp;204612&nbsp;&nbsp;(CFRunLoopRunSpecific&nbsp;&nbsp;+&nbsp;&nbsp;276) ...方便的C ++开发帮手如果您打开跟踪打印：[KSCrash sharedInstance ] .printTraceToStdout = YES ;它会打印正确的堆栈跟踪到标准输出，只要你的应用程序抛出一个未捕获C ++异常！否则，调试器只会导致你在异常被重新抛出。自定义崩溃和堆栈跟踪现在，您可以自己定制的崩溃和堆栈跟踪（例如对于脚本语言的崩溃）：- (void) reportUserException:(NSString*) name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reason:(NSString*) reason &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lineOfCode:(NSString*) lineOfCode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stackTrace:(NSArray*) stackTrace &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terminateProgram:(BOOL) terminateProgram; 见KSCrash.h了解详情。不稳定的特点以下功能应被视为“不稳定”，默认情况下被禁用：死锁检测如何导入KSCrash打开ios.workspace。选择KSCrash Scheme。Build或者Archiver项目。然后，你像使用任何其他框架一样使用它。如何使用KSCrash将该框架添加到项目中（或添加KSCrash项目作为依赖）下面的系统框架和库添加到您的项目：libc++.dyliblibz.dylibMessageUI.framework&nbsp;&nbsp;【iOS only】SystemConfiguration.frameworkFoundation.frameworkCoreGraphics.frameworkUIKit.framework【iOS only】添加 "-ObjC" 标示到&nbsp;&nbsp; Build Setting - Other Linker Flags 中.【加载分类数据】【可选】如果希望自己定制化KSCrash内容，那么可以将以下内容添加到你的[application：didFinishLaunchingWithOptions：] 方法中：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KSCrash *ksCrash = [KSCrash sharedInstance];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ksCrash.catchZombies = YES;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ksCrash.introspectMemory = YES;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ksCrash install];&nbsp;&nbsp;【可选】如果希望使用KSCrash的上报服务器，那么可以将以下内容添加到你的[application：didFinishLaunchingWithOptions：] 方法中：【如果希望定制化KSCrash的属性，那么应该通过修改源码实现】#import &lt;KSCrash/KSCrash.h&gt;// Include to use the standard reporter.#import &lt;KSCrash/KSCrashInstallationStandard.h&gt;// Include to use Quincy or Hockey.#import &lt;KSCrash/KSCrashInstallationQuincyHockey.h&gt;// Include to use the email reporter.#import &lt;KSCrash/KSCrashInstallationEmail.h&gt;// Include to use Victory.#import &lt;KSCrash/KSCrashInstallationVictory.h&gt;- (BOOL)application:(UIApplication*) application didFinishLaunchingWithOptions:(NSDictionary*) launchOptions{KSCrashInstallationStandard* installation = [KSCrashInstallationStandard sharedInstance];installation.url = [NSURL URLWithString:@"http://put.your.url.here"];// OR:KSCrashInstallationQuincy* installation = [KSCrashInstallationQuincy sharedInstance];installation.url = [NSURL URLWithString:@"http://put.your.url.here"];// OR:KSCrashInstallationHockey* installation = [KSCrashInstallationHockey sharedInstance];installation.appIdentifier = @"PUT_YOUR_HOCKEY_APP_ID_HERE";// OR:KSCrashInstallationEmail* installation = [KSCrashInstallationEmail sharedInstance];installation.recipients = @[@"some@email.address"];// Optional (Email): Send Apple-style reports instead of JSON[installation setReportStyle:KSCrashEmailReportStyleApple useDefaultFilenameFormat:YES];// Optional: Add an alert confirmation (recommended for email installation)[installation addConditionalAlertWithTitle:@"Crash Detected"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message:@"The app crashed last time it was launched. Send a crash report?" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yesAnswer:@"Sure!" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noAnswer:@"No thanks"]; // OR:KSCrashInstallationVictory* installation = [KSCrashInstallationVictory sharedInstance];installation.url = [NSURL URLWithString:@"https://put.your.url.here/api/v1/crash/&lt;application key&gt;"];[installation install];&nbsp;&nbsp;&nbsp;&nbsp; … }以上操作，将安装崩溃监视系统（拦截崩溃并存储报告到磁盘）。请注意，有可能要为具体的设备设置其他属性。【可选】如果你使用KSCrashInstallation安装KSCrash，一旦你准备好发送任务，那么可以调用以下方法发送崩溃数据：[installation sendAllReportsWithCompletion:^(NSArray *filteredReports, BOOL completed, NSError *error){&nbsp;&nbsp;// Stuff to do when report sending is complete}];推荐阅读如果可能的话，你应该阅读下面的头文件，充分了解哪些功能KSCrash了，以及如何使用它们：KSCrash.hKSCrashInstallation.hKSCrashInstallation(SPECIFIC TYPE).hArchitecture.md高级用法启用On-Device symbolicationOn-device symbolication需要基本符号存在于最终程序中。为了实现这一目标，我们需要设置 Build Setting - Strip Style 为 Debugging Symbol。如果这样做将会使你的最终二进制文件大小增加约5％，，但你将获得On-device symbolication的能力。启用高级功能：KSCrash拥有先进的功能，对于研究用户上报的崩溃报告时会非常有用。一些功能涉及到取舍，所以大部分都是默认禁用。自定义用户数据（userInfo in KSCrash.h）您可以通过操作KSCrash的 userInfo 属性&nbsp;&nbsp;，设置自定义的用户数据到下一个崩溃报告中。僵尸跟踪（zombieCacheSize in KSCrash.h）KSCrash具有检测僵尸实例（指向已释放的对象的野指针）的能力。它通过记录被释放的任何对象的 Address 和 Class 做到这一点。它在高速缓存中存储这些值，key是被释放对象的Address，value是被释放对象的Class。同时这个高速缓存的大小可以由你设置，但是缓存越小，就意味着越有可能发生散列碰撞，这将导致你失去先前已存储的释放对象的内容。当僵尸跟踪启用时，KSCrash还将记录最后一个NSException的内容并放到崩溃报告中。某些种类的内存损坏或堆栈损的坏崩溃会导致NSException被提前释放，这个功能可以提供关于元凶的真实信息，所以这个功能有时可能很方便。权衡：跟踪僵尸会在对象dealloc时增加非常轻微的开销，以及有一些内存占用。死锁检测（deadlockWatchdogInterval in KSCrash.h）警告警告警告警告警告警告警告此功能是不稳定的！它可能会错误判定并且主动使您的应用程序崩溃！如果你的主线程死锁，您的用户界面会变得反应迟钝，用户必须手动关闭应用程序（对此不会有崩溃报告）。随着死锁检测启用，为看门狗定时器设置一个时间阈值，如果有任何函数在主线程上的持续时间超过看门狗定时器的阈值，KSCrash将主动关闭应用程序，并且为主线程生成一个堆栈跟踪。这是美好的，但你必须小心：特别是应用程序初始化一般发生在主线程，如果你的初始化代码比看门狗定时器需要更长的时间，你的应用程序将被强制在启动时关机！如果启用此功能，您必须确保您正常运行的代码，无持有主线程比看门狗的阈值长！同时，你要定时器设置为一个足够低的值，赶在用户没有变得不耐烦之前触发看门狗触发手动关闭应用程序！权衡：死锁检测，但你一定要多多小心什么主线程上运行！内存内省（introspectMemory in KSCrash.h）当一个应用程序崩溃，通常在堆栈、寄存器甚至异常消息中会有一些对象和字符串的引用。启用内存内省后，KSCrash将会去尝试读取这些内存地址上的内容【Type、Value、ivars、Address、last_dealloc_obj等信息】，并将其记录到报告中。我们可以将不需要内省的类设置到KSCrash.doNotIntrospectClasses&nbsp;&nbsp;属性【列表】中。记录后，这些类的对象将只记录class name。自定义崩溃处理代码（onCrash in KSCrash.h）如果你想要在崩溃发生后做一些额外的处理（也许是为了增加更多的上下文数据报告），你可以设置这个属性，它是一个函数指针【非block】。但是，你必须确保你只使用异步安全的代码，并且确保不在这一段代码中调用OC代码【C和C++还是可以的】！虽然在很多情况下，你可以不必这样做，但在某些类别的崩溃中，编写不符合上述规定的程序代码会导致崩溃处理block崩溃！请注意，如果发生这种情况，KSCrash会检测到它，继续写一个完整的报告，尽管自定义处理程序代码可能没有完全运行。权衡：自定义崩溃处理代码，但是你必须要小心的编写它！KSCrash日志重定向这会将所有的KSCrash的输出被打印到控制台，或者将其写入一个文件来代替。主要是用这个来调试KSCrash本身，而是它可能还有其他用途，所以我开放它的API。示例工作区包括一些示例应用程序，这表明普通KSCrash用法。请看看AppDelegate.m在每个应用程序的顶部是做什么的说明。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GCD使用方式与效果总结]]></title>
      <url>%2F2017%2F02%2F09%2FGCD%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%95%88%E6%9E%9C%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[GCD使用方式与效果总结理论知识请参考： Effective Objective-C 2.0读书笔记：块与大中枢派发基本GCD使用方法总结： 调度执行方法：（只选择block方式执行的，不考虑使用 context+function方式的用法） void dispatch_async( dispatch_queue_t queue, dispatch_block_t block ): 将block加入到queue中异步执行（可能同步/异步，取决于queue的性质），当前调用者不等待。 void dispatch_sync( dispatch_queue_t queue, dispatch_block_t block ): 将block加入到queue中同步执行（可能同步/异步，取决于queue的性质） ，当前调用者阻塞等待。 void dispatch_apply( size_t itertions , dispatch_queue_t queue , void(^block)(size_t)) : 将block（该block与上面的不同，其带有入参size_t）加入queue中多次执行，itertions指明了需要执行多少次，可以用这个方法来对collection进行遍历。需要注意的是，该方法是同步执行的（即调用者需要阻塞等待）。而且该方法可能会并发执行（取决与queue的性质），必要的话，我们需要在内部做好数据的同步保护机制。 void dispatch_after( dispatch_time_t when , dispatch_queue_t queue,dispatch_block_t block ): 该方法将block加入到queue中，并延后 when时间后执行。此函数是异步执行的，调用者不等待。dispatch_time_t 我们一般使用 dispatch_time （DISPATCH_TIME_NOW, xxx * NSEC_PER_SEC）生成延迟时间。 void dispatch_barrier_async( dispatch_queue_t queue,dispatch_block_t block ): 主要用于在并发队列中，加入互斥标记，使采用此方法执行的block不会并发执行（在同一个队列中，有且只有一个标记，所有采用此类方法加入的block，都需要互斥执行代码） 。同时这是个异步调用，调用者不等待。 void dispatch_barrier_sync( dispatch_queue_t queue,dispatch_block_t block ): 主要用于在并发队列中，加入互斥标记，使采用此方法执行的block不会并发执行（在同一个队列中，有且只有一个标记，所有采用此类方法加入的block，都需要互斥执行代码）。同时这是个同步调用，调用者阻塞等待其执行完毕。 获取当前queue（建议废弃）：dispatch_queue_t dispatch_get_current_queue() : 获取代码块当前执行所在的queue。该函数以被废弃，且无法避免target设置所带来的死锁问题，建议不要使用。 创建/获取可执行的queue： dispatch_queue_t dispatch_get_mian_queue( ) : 返回主线程执行的queue。 dispatch_queue_t dispatch_get_global_queue（long identifier, unsigned long flags）：返回全局的并发执行的queue。它的第一个参数是全局的queue的优先级，（全局queue有多个队列，每个队列有不同的优先级，共有四种：DISPATCH_QUEUE_PRIORITY_HIGH、DISPATCH_QUEUE_PRIORITY_DEFAULT 、DISPATCH_QUEUE_PRIORITY_LOW 、DISPATCH_QUEUE_PRIORITY_BACKGROUND ），第二个参数是个保留字，传0即可。 dispatch_queue_t dispatch_queue_create( const char* label , dispatch_queue_attr_t attr ):创建一个指定名字的串行队列（注意，不可创建并行队列）。第一个参数是队列的名字（一般使用反域名的形式命名），第二个参数一般传NULL。该queue在使用完毕之后，需要使用 dispatch_release( dispatch_queue_t queue )去释放它（由于其是C对象，ARC无法接管其生命周期）。 获取queue的label：const char* dispatch_queue_get_label( dispatch_queue_t queue ) ，该函数可以获取指定queue的名字。 设置queue的优先级或者是target关系：void dispatch_set_target_queue( dispatch_object_t object , dispatch_queue_t queue ), 第一个参数是自定义queue，第二个参数可以自定义或者系统queue。其可以将前者的优先级设置为和后者一致，且设置他们之间的target关系。即前者的block将在后者的线程中执行调用。 设置/获取关联标记： void dispatch_queue_set_specific( dispatch_queue_t queue, const void *key, void *context,dispatch_function_t destructor ):设置一个queue的关联标记，设置方式类似与关联对象，其key和value都是void*指针，最后一个参数是value的析构函数，用于防止内存泄露。详情请参考P183. void* dispatch_queue_get_specific( dispatch_queue_t queue, const void *key ) ：用于获取指定queue上的关联标记。可向上回溯到target关系中的queue的设置。 void* dispatch_get_specific( const void *key ) : 用于获取当前正在执行的queue上的指定key的value。可向上回溯到target关系中的queue的设置。 GCD Group组使用方法： 用于多线程同步。 dispatch_group_t dispatch_group_create() : 创建一个group组。 使用方式分为两种： Block使用方式：void dispatch_group_async( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block )：以异步调用的形式将代码加入 queue中执行，并加此任务在group中标记。注意，加入组中的任务只能是异步调用的，否则就失去了使用group的意义。 手动管理方式：使用 进入前调用void dispatch_group_enter( dispatch_group_t group ) + 异步线程中调用void dispatch_group_leave( dispatch_group_t group ) 这两个函数实现，其效果与上方的类似，但是其更适用于在别人掌控的多线程中调用。可以参见网站：http://stackoverflow.com/questions/10643797/wait-until-multiple-networking-requests-have-all-executed-including-their-comp/10644282#10644282 完成通知方式有两种： 阻塞等待方式：long dispatch_group_wait( dispatch_group_t group, dispatch_time_t timeout )，调用此语句，可以原线程等待 group执行完成。同时，我们可以指定最长的 等待时间 timeout，其中timeout设置为 DISPATCH_TIME_FOREVER 则表示永不过期。 异步通知回调方式： void dispatch_group_notify( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block )，可以在group内任务执行完成后，在指定的queue中回调这个block。 主要作用：group主要用于协调多项并发任务，获知其并发任务的结束时间。 GCD Semaphore使用： 创建信号量：dispatch_semaphore_t dispatch_semaphore_create( long value ) ：创建一个信号量，value的值表示信号量资源池内初始的资源数量。如果为0，那么调用wait时含义立即等待，如果小于0，那么将返回NULL，如果大于0，表示有多余资源可用。 等待信号量操作：long dispatch_semaphore_wait（dispatch_semaphore_t dsema, dispatch_time_t timeout）,等待并获取一个信号量资源，设置一个最长等待时间（可设置为DISPATCH_TIME_FOREVER ，表示永不过期 ）。如果超时前成功获取那么就返回0，否则返回超时时间。 增加信号量资源操作：long dispatch_semaphore_signal（dispatch_semaphore_t dsema）,增加一个信号量资源，如果有一个线程因此苏醒，那么返回值大于0，否则返回值为0. 主要作用：semaphore主要用于单项异步任务的协调，及时获取该异步任务的进度。（我们可以用这个函数把一个异步任务变成同步任务，这对于系统函数block回调行为很有用） GCD Barrier使用：【屏障】作用：主要是对并发GCD队列使用，可以使一个并发GCD队列内的任务在执行时存在依赖关系。参考文章：http://blog.csdn.net/u013046795/article/details/47057585主要函数：void dispatch_barrier_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block):函数会同步等待代码块内的任务执行完成后【它执行的前提是之前提交的block都执行完成】，才继续调用函数的执行。void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)：只是单纯的设置屏障关系，立即返回调用函数继续执行。 附注内容： 关于dispatch_time_t 的时间描述，他有两种时间生成方式： dispatch_time_t dispatch_time( dispatch_time_t when , int64_t delta ): 表示的是绝对时间戳，其实格林尼治时间1970开始计算的绝对时间，不会随着系统时间设置的改变而改变。我们一般采用这个生成延迟时间。 dispatch_time_t dispatch_walltime( const struct timespec *when , int64_t delta ):表示的系统时钟时间，可以被用户自由更改。 采用设置/获取关联标记的方法，我们可以代替 dispatch_get_current_queue（) ，更加明确当前queue的target关系。 dispatch_queue_t 对象的内存管理方式：（由于是C语言对象，需要我们自己管理内存） dispatch_retain( dispatch_object_t object ) dispatch_release( dispatch_object_t object ) 参考文章： 书本内容：《Effeective Objective-C 2.0》 GCD分析博客: http://www.cnblogs.com/sunfrog/p/3313424.html (系列文章)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IOS动态库与静态库指南]]></title>
      <url>%2F2017%2F02%2F09%2FIOS%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[IOS动态库与静态库指南.Framework和.a的区别：参考文章：http://blog.csdn.net/lvxiangan/article/details/43115131用户可以打出动态库，但是iOS8之后苹果才允许程序加载动态库，但是所有动态库必须预先放置在Bundle中。程序库可以分为静态库和动态库： 静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。动态库：链接时不复制，程序运行开始时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。【如果是自己的动态库，那么需要加到程序文件中才行】iOS静态库的格式：.a 和 .framework（用户生成的framework）iOS动态库的格式：.dylib 和 .framework（系统提供的framework） 这类库用户自己无法生成，不在讨论范围内。只要修改库Project - Build Setting - Mach-O Type，即可更改静态库或者动态库属性。静态库中.a 和 .framework 的区别： .a 是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。.a 文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用（整个都打包在其中）。.a + .h + sourceFile = .framework。使用静态库的注意点： 注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。 关于不同等级的配置参数：-Objc、-force_load、-all_load 参考文章：https://my.oschina.net/u/728866/blog/194741如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把这个.h暴露出来就可以了。使用差别： Embed Binaries：在动态库使用时，有时会发现必须要将整个库Embed Binaries到项目中，否则会出现 链接数据不正常，或者 ipatool Error: xxxx dylib search path not exist在使用静态库时，不允许将整个库Embed Binaries到项目中，否则会出现error: warning: Found an unexpected Mach-O header code: 0x72613c21的错误。第三方库依赖： 动态库因为是完全动态的，所以可以自己链接，相对来说，主工程就不需要再额外添加framework依赖。静态库需要添加上所有的依赖。程序加载自己的动态库时的操作： 动态库一定要作为Embed Binaries中的一项添加到项目中，否则，在导出ipa时会提示找不到dylib的地址。头文件设置：在Xcode中打包库时，可以配置头文件可见性的方式：参考链接：https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/Setting%20the%20Role%20of%20a%20Header%20File.html具体的设置路径：Build Phases —&gt; Headers，将头文件 + 到其中，并放入到某一个具体的分组即可。关于这个文件夹下三个分组的不同之处： public：完全公开的头文件，客户端可以任何的使用和读取。private：理论上是私有头文件，但是在打包时还是一起暴露在外了。但是会放在一个单独的深层级目录中。客户端应该避免使用这些头文件中的内容。project：完全私有的头文件，不对客户端做暴露。打包流程：（示例流程）需要新建一个Target，将 Builid Setting的Valid Architectures 设置为 arm7、arm7s（可不选）、arm64、i386（用于32位模拟器）、x86_64（用于64位模拟器）。【可选】使用 Aggregate 为工程添加一个 target，并在该target中设置 dependency，目标为之前的那个库target。且这个traget的 Builid Setting的Valid Architectures 设置为 arm7、arm7s（可不选）、arm64、i386（用于32位模拟器）、x86_64（用于64位模拟器）. 因为最终还是由脚本提供所有功能，Aggregate只是为了提供一个可视化的操作环境以及脚本中的环境变量。创建一个新的运行脚本，framework 和 .a 是两种不同的脚本。具体可以在 ownerSpace中找到。【可选，任意切换】将 scheme 中 RUN 和 Archive 的配置改为 Release状态。选中 Aggregate 这个Target， 使用 Build 构建库，并在 Product 目录下获取到相应文件下的产物。打包脚本需要完成的工作：删除 Build_Dir 下的旧文件使用 xcodebuild 按照当前Target的 configuration 进行编译。通用编译指令如下： xcodeproject使用方法：xcodebuild -target &lt;项目文件所在的位置&gt; -configuration ${CONFIGURATION} -sdk iphoneos/iphonesimulator clean buildworkspace 使用方法：xcodebuild -workspace &lt;项目文件所在的位置&gt; -scheme xxxx -configuration ${CONFIGURATION} -sdk iphoneos/iphonesimulator clean build创建universal文件夹使用 lipo -create xxx xxx -o xxx ，将模拟器和真机的库合并到一起，输出合并库。将头文件copy到universal文件夹下。指令集合：使用 lipo -info 文件名 可以校验该文件支持的平台架构。可以支持验证dsym支持的架构类型。使用 lipo -create &lt;源文件1.a&gt; &lt;源文件2.a&gt; -o 最终文件.a动态库打包脚本示例：# Sets the target folders and the final framework product.FMK_NAME=${PROJECT_NAME}# Install dir will be the final output to the framework.# The following line create it in the root folder of the current project.INSTALL_DIR=${SRCROOT}/Products/${FMK_NAME}.framework# Working dir will be deleted after the framework creation.WRK_DIR=buildDEVICE_DIR=${WRK_DIR}/Release-iphoneos/${FMK_NAME}.frameworkSIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework# -configuration ${CONFIGURATION}# Clean and Building both architectures.xcodebuild -configuration ${CONFIGURATION} -target "${FMK_NAME}" -sdk iphoneos clean buildxcodebuild -configuration ${CONFIGURATION} -target "${FMK_NAME}" -sdk iphonesimulator clean build# Cleaning the oldest.if [ -d "${INSTALL_DIR}" ]thenrm -rf "${INSTALL_DIR}"fimkdir -p "${INSTALL_DIR}"cp -R "${DEVICE_DIR}/" "${INSTALL_DIR}/"# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.lipo -create "${DEVICE_DIR}/${FMK_NAME}" "${SIMULATOR_DIR}/${FMK_NAME}" -output "${INSTALL_DIR}/${FMK_NAME}"# open framework exist directoryopen "${INSTALL_DIR}/.."rm -r "${WRK_DIR}"静态库打包脚本示例：# remove old build firstrm -rf $(BUILD_DIR)/${CONFIGURATION}-universalrm -rf $(BUILD_DIR)/${CONFIGURATION}-iphoneosrm -rf $(BUILD_DIR)/${CONFIGURATION}-iphonesimulator# define output folder environment variableUNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal# Step 1. Build Device and Simulator versionsxcodebuild -workspace iOS.xcworkspace -scheme KSCrashLib -configuration ${CONFIGURATION} -sdk iphoneos clean buildxcodebuild -workspace iOS.xcworkspace -scheme KSCrashLib -configuration ${CONFIGURATION} -sdk iphonesimulator clean build# make sure the output directory existsmkdir -p "${UNIVERSAL_OUTPUTFOLDER}"# Step 2. Create universal binary file using lipolipo -create -output "${UNIVERSAL_OUTPUTFOLDER}/libKSCrashLib.a" "${BUILD_DIR}/${CONFIGURATION}-iphoneos/libKSCrashLib.a" "${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/libKSCrashLib.a"# Last touch. copy the header files. Just for conveniencecp -R "${BUILD_DIR}/${CONFIGURATION}-iphoneos/include" "${UNIVERSAL_OUTPUTFOLDER}/"cp -R "${BUILD_DIR}/${CONFIGURATION}-iphoneos/usr" "${UNIVERSAL_OUTPUTFOLDER}/"watch静态库脚本打开示例：WRK_DIR=build# remove old build firstrm -rf $(WRK_DIR)/${CONFIGURATION}-universalrm -rf $(WRK_DIR)/${CONFIGURATION}-watchosrm -rf $(WRK_DIR)/${CONFIGURATION}-watchsimulator# define output folder environment variableUNIVERSAL_OUTPUTFOLDER=${WRK_DIR}/${CONFIGURATION}-universal# Step 1. Build Device and Simulator versionsxcodebuild -target TestWatchFramework -configuration ${CONFIGURATION} -sdk watchos clean buildxcodebuild -target TestWatchFramework -configuration ${CONFIGURATION} -sdk watchsimulator clean build# make sure the output directory existsmkdir -p "${UNIVERSAL_OUTPUTFOLDER}"# Step 2. Create universal binary file using lipolipo -create -output "${UNIVERSAL_OUTPUTFOLDER}/libTestWatchFramework.a" "${WRK_DIR}/${CONFIGURATION}-watchos/libTestWatchFramework.a" "${WRK_DIR}/${CONFIGURATION}-watchsimulator/libTestWatchFramework.a"# Last touch. copy the header files. Just for conveniencecp -R "${WRK_DIR}/${CONFIGURATION}-watchos/include" "${UNIVERSAL_OUTPUTFOLDER}/"cp -R "${WRK_DIR}/${CONFIGURATION}-watchos/usr" "${UNIVERSAL_OUTPUTFOLDER}/"# open diropen "${UNIVERSAL_OUTPUTFOLDER}"参考文章：http://www.cocoachina.com/industry/20140613/8810.html（制作和加载动态库的方法）加载方式：在编译时添加引用关系，包将放入bundle中，在需要是被调用。从远端下载库到Document中，使用代码从 Document中加载代码参考文章：https://yq.aliyun.com/articles/3024#9]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[横竖屏适配经验]]></title>
      <url>%2F2017%2F02%2F09%2F%E6%A8%AA%E7%AB%96%E5%B1%8F%E9%80%82%E9%85%8D%E7%BB%8F%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[横竖屏适配经验autoresizingmask使用心得：UIViewAutoresizingFlexibleBottomMargin 等单独使用时，是自动调整名字端的距离，维持对端的距离不变（完全不变），但本身大小维持不变。 UIViewAutoresizingFlexibleBottomMargin | UIViewAutoresizingFlexibleTopMargin等对端组合使用时，可以让两边的边距等比例变化，锚点所处的绝对位置比例固定（适用于居中型的label），但本身大小不变。UIViewAutoresizingFlexibleWidth等 当父视图变化时，其宽度随着父视图宽度的变化。变化规律是父视图增长或缩小多少，本身就增长或缩小多少。从而维持了左右间距不变。 UIViewAutoresizingFlexibleBottomMargin | UIViewAutoresizingFlexibleTopMargin｜UIViewAutoresizingFlexibleHeight 这样才能做到在横向上的等比例变化。 其他组合情况，都可以由上述几种组合方式推导出来。注意，autoresizingmask是针对父视图的变化而变化的机制，同时，父视图拥有关闭子视图响应变化的autoresizingSubview开关机制autoresizingmask这一属性不会被自动继承，对于每一个view都需要单独设置。横竖屏区分方式：如果是VC，那么可以通过self.interfaceOrientation 去判断当前的具体方向。（至少需要在ViewDidLoad时及之后使用，否则方向为unknown ）该方法扩展一下，就是如果你的app拥有一个全局唯一的最底层VC，那么这个VC可以用于全局的任何地方的方向判断。比如Jdipad 中的 appdelegate.mainCtrl 。如果是View的话，可以通过判断某个view的bounds大小去判断横竖屏（注意，一定不能取frame，否则会出错）ios7上：windows的大小不会改变，但是他的坐标系计算方式发生变化。这导致vc.view.frame也不会发生变化。但是vc.view.frame的bounds会改变，这将导致下层view的布局可以发生变化。 ios8上：windows和vc.view.frame都发生变化，与普通的view变化一致。可以直接使用vc.view.bounds的大小来判断横竖屏。该大小无论在哪个系统下都会旋转。[uiscreen mainscreen]的bounds.size.width/height来判断方向。但要注意，这个大小可能会包含系统状态栏，同时这个值在ios7上不会变的.无论旋转与否。但是旋转会导致左边发生变化。在ios8上旋转会导致长宽值互换。采用状态栏的朝向来确定位置：【【UIApplication sharedApplication】 statusBarOrientation】，其值的类型是 UIInterfaceOrientation。（推荐）使用设备 [UIDevice currentDevice].orientation 来判断方向，其值是一个UIDeviceOrientation device的方向可能会经常出现unknow的情况，比如设备处于斜置状态或者设备刚刚启动等情况。关于UIDevice的使用前提，generatesDeviceOrientationNotifications 是一个属性，他通过 beginGeneratingDeviceOrientationNotifications 开启，请确保在代码中开启它。最好在初始化的时候即完成。具体可以参考：http://foggry.com/blog/2014/08/08/ping-mu-xuan-zhuan-xue-xi-bi-ji/但我更加推荐使用 VC.interfaceOrientation 。转屏处理方式：方案一：willRotateToInterfaceOrentation:dutation 以及 willAnimateRotateToInterfaceOrentation:dutation，但这两个方法在 iOS9上被废除了。方案二：viewWillTransitionToSize:WithTransitionCoordinator： 需要在ios8开始可用最有效的方式是支持两个版本的写法：（不需要我们自己担心系统兼容性的问题，如果同时实现了两个函数，那么高版本系统上会只会回调viewWillTransitionToSize:WithTransitionCoordinator，而在低版本上只会回调willAnimateRotateToInterfaceOrentation:duration ，但我们一定要保证两个函数都实现了）方案三：如果是在UIView中需要对转屏做处理，可以注册通知 UIApplicationWillChangeStatusBarOrientationNotification ,当收到该通知时，就做转屏处理方案细节对比：willRotateToInterfaceOrentation:duration ：此函数在VC不是顶部VC时（即其界面没有展示在屏幕上个），是不会被调用的。因此，我们需要在 viewWillAppear 中处理从上一个界面回退时的情况。此函数调用时，VC.view已经处于转屏后的大小。（其相应的设置了约束的view也都已经变成了合适的大小），此时，我们可以利用转屏后的frame进行手工布局。viewWillTransitionToSize:WithTransitionCoordinator ：此函数只要该VC属于 rootViewController 的VC链中，其就可以被回调到。而且回调的顺序是：从 rootViewController 开始，一直回调到 叶子VC。（即当前页面是最后回调的）。因此使用这个函数时，不需要考虑回退时的界面布局问题。此函数调用时，VC.view维持在旧的大小没变，如果此时按照老的写法来妄图按照此时的frame进行手工布局，必将导致错误。注意，在 viewWillAppear 时， vc,view的大小已经被为之后的值了，但是，其 subView上的约束还未生效。那些view的大小都是不合适的。注意事项：在转屏时，tableView的contentOffset 是会发生变化的。但这种变化并不是以动画的方式展现的，而是直接移动过去的。在转屏完成时，该定位就已经完成了。如果转屏后，下方的大小足够支撑当前的 contentOffset （即 contentOffset + tableView.height ＞＝ contentSize）,那么转屏后，contentOffset维持不变。如果转屏后，下方的大小不足以支撑当前的 contentOffset （即 contentOffset + tableView.height &lt; contentSize ）,那么转屏后，contOffset将会发生变化。（目前未找到变化的规律，但是大致是定位到 首部（view连一屏都撑不满时） 或者是 定位到 中间位置（view还是比较长的））。假如我们在 willRotateToInterfaceOrentation:duration 或者 viewWillTransitionToSize:WithTransitionCoordinator 中对 contentOffset 进行修改，那么转屏完成时将直接定位到相应的位置，而不会有任何的动画效果和感知。对我们来说这一切仿佛是透明的。当转屏时，我们需要手动旋转坐标系的话：（在iOS7上对直接添加到window上的view做旋转操作即可确保下面的view都正常展示）CGAffineTransform at;UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;if (orientation == UIInterfaceOrientationLandscapeLeft){ at =CGAffineTransformMakeRotation(M_PI*3/2);}else if(orientation == UIInterfaceOrientationLandscapeRight){ at =CGAffineTransformMakeRotation(M_PI/2);}else if ( orientation == UIInterfaceOrientationPortraitUpsideDown ){ at =CGAffineTransformMakeRotation(-M_PI);}view.transform = at;详细代码展示： View直接添加到windows的转屏处理方式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[类的初始化方法使用指南]]></title>
      <url>%2F2017%2F02%2F09%2F%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[类的初始化方法使用指南类有两个初始化方法，分别为：load 和 initalizeload方法简介:该方法对于加入运行期的每个类及分类来说，如果有实现此方法，必定会调用此方法，而且仅调用一次（如果未实现，并不会调用父类方法，这是它最特殊的地方）。如果分类和主类都实现了此方法，那么先调用主类的，再调用分类的。在runtime加载类时即开始执行此方法，时间非常早，且确定。load方法时，runtime还处于脆弱期，因为并非所有的类都已经load完成。且load虽然会将超类预先加载，但是同一个库中的兄弟类是无法预知先后顺序的。建议不要使用load方法来实现类的数据初始化，考虑采用 initialize实现。load方法应仅用于调试程序打印使用。该方法如果需要调用父类的load，需要显示调用。initialize方法简介：该方法是惰性加载的，仅在该类第一次使用时才加载。运行期系统可以保证initialize的线程安全性，只有执行initialize的线程可以操作类实例。该方法会自动调用父类的initialize，不需要显示调用。即可能会被多次调用，所以慎用。如果一个类未实现initialize方法，那么将自动调用父类的。（与普通方法一致）由于initialize方法的执行线程是由系统决定的，那么建议不要在内部做耗时操作，否则可能引发UI线程阻塞（碰巧UI线程成为initialize执行线程时）。类的初始化数据等操作，建议放在initialize中完成。initialize方法应仅用于设置内部数据（比如动态对象类型的静态数据），不应该在其中调用其他方法，更不应该涉及与其他类相关的语句。（因为可能出现循环初始化，从而出现类使用时，并没有initialize完的类直接投入使用） +(void)load+(void)initialize执行时机在程序运行后立即执行在类的方法第一次被调时执行若自身未定义，是否沿用父类的方法否是类别中的定义全都执行，但后于主类中的方法覆盖类中的方法，只执行一个执行顺序问题：【一般顺序】load &gt; __attribute__((constructor)) &gt; main&gt; 【 initalize】如果在load里面只使用基础库的功能【分类的都不行】，以及自己类的内容，那么是安全的，除此之外，都是危险的。__attribute__((constructor)) 是最适合用于初始化的地方。当在load中调用一个类的成员方法时，那么那个类的initalize也会在此时被调用。即initalize不一定是在前三项全部完成后执行的，可能会在和load同期的时候执行。注意事项：虽然说分类在主类后面执行，这是一个确定的顺序。但是，分类并不是紧接着主类执行的。load的加载过程以库为单位进行，基础库先进行加载，然后再到我们自己的代码。而在一个库文件内部，load的加载顺序与文件在build phase 中的排列顺序一致【永远不要依赖这一点】举个例子，我们写了一个NSObject的分类Swizzle，然后在同一个库中的TestObj类的load方法中，使用了分类中的方法。但是这个时候，其实分类Swizzle可能没有被加载，那么就有可能导致程序崩溃发生。另外需要注意的是，即使一个类或者一个分类没有完成load,但是它的函数还是可以被调用的【Xcode断点可能无法调试到】。参考文章：博客介绍：http://www.cnblogs.com/ider/archive/2012/09/29/objective_c_load_vs_initialize.html 书籍介绍：《Effective Objective-C 2.0》P200]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[KVO && KVC 教程]]></title>
      <url>%2F2017%2F02%2F09%2FKVO%20%26%26%20KVC%20%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[KVO &amp;&amp; KVC 教程KVC基础教程：在采用KVC协议时，需要实现以下几个方法，这些也是KVC的直接可使用接口，而不是内嵌支持接口：（设关键字为 xxx） 相应的存取方法。（使用属性声明时，可自动完成）&nbsp;&nbsp;如果key为集合元素，则需要实现额外的操作层方法： &nbsp;&nbsp;–(NSUInteger) countOfxxx;&nbsp;&nbsp;–(id) objectInxxxAtIndex : (NSUInteger) idx;–(id) objectInxxxAtIndex : (NSIndexSet*) idx;–(void) getxxx: (id[]) aBuffer range : (NSRange) aRange;【可选】–(void) insertObject: (id)anobject inxxxAtIndex : (NSUInteger) idx;【可变】-(void) insertxxx : (NSArray*) array atIndexes: (NSUInteger) idx;【可变】–(void) removeObjectFromxxxAtIndex : (NSInteger) idx;【可变】-(void) removexxxAtIndexes : (NSIndexSet *) idx;【可变】–(void) reolaceObjectInxxxAtIndex : (NSUInteger) index withObject : (id) obj;-(void) replacexxxAtIndexes : (NSUIndexSet*) indexes withxxx : (NSArray*) arr; 【可变，可选】如果要支持一对多关系使用运算符，还需要看对象是否支持每种运算符的运算函数。KVO基础教程：KVC是使用KVO的基础，因此只有符合KVC协议的属性，才能作为KVO的关键字。KVO中按照对象作用不同，可以划分为 观察者 和 被观察者。 观察者：监视某个对象的属性的变化的角色。被观察者：被观察的属性的归属者。采用KVO编程机制时，回调函数的执行与被观察对象的键值改变是发生在一个线程中【与通知类似，在抛出通知的线程上执行】。即当被观察的键值被改变时，就会去调用监视者的回调函数，等到回调函数执行完后，再继续执行键值改变后的流程。 而对于采用代理的方式而言，代理函数的调用可能发生在另外一个线程中。被观察者：模型对象自己添加观察者到自己的属性上（可以不是属性，但需要实现手动通知方法），使该属性变化时，自动调用关联的函数。 示例：[stockForKVO&nbsp;&nbsp;addObserver:self&nbsp;&nbsp;forKeyPath:@"price"&nbsp;&nbsp;options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld&nbsp;&nbsp;context:nil];注意，new 和 old 传入的均为变化前和变化后的指向对象（即还是以指针为单位传入的）。第三个参数是可选项，可以传入一个受监控的上下文环境。观察者：添加的KVO的回调函数（这是观察者唯一需要做的事）&nbsp;&nbsp;-(void)observeValueForKeyPath:(NSString&nbsp;&nbsp;*)keyPath&nbsp;&nbsp;ofObject:(id)object&nbsp;&nbsp;change:(NSDictionary&nbsp;&nbsp;*)change&nbsp;&nbsp;context:(void&nbsp;&nbsp;*)context&nbsp;&nbsp; 都是同一个，但会额外传入一个KeyPath作为区分。 keyPath：KVO监视的路径object：KVO监视的对象change：对象KVO通知触发时，所附加的数据。附加哪些数据，则由 addobserver 时通过 option指定。KVO按照通知方式的不同： 自动通知：只能对属性/实例变量使用。而且只能监视指针值的变化。可以参见自动通知key值要求：http://www.cnblogs.com/pengyingh/articles/2383629.html。 当对属性使用时，只要直接按照正常属性的使用方式使用即可。当对实例变量使用时，一定要使用 setValue: forKey： 的方式调用，否则无法触发通知。手动通知：灵活性较大，但需要实现一个附加函数，以及手动的触发通知。可以对属性或者是实例变量，甚至是一个不存在的值使用。 附加函数：+&nbsp;&nbsp;(BOOL)automaticallyNotifiesObserversForKey:(NSString*)key，对于需要实现手动发送的key返回NO，其余则调用super。手动触发：在property的值改变之前由被观察者调用 willChangeValueForKey: ，在值改变之后由被观察者调用 didChangeValueForKey: 。如果一个操作造成了多个key的值的改变，则willChangeValueForKey:和didChangeValueForKey:必须嵌套着调用。对成员变量使用KVO（自动通知方式）： 被观察的成员变量，可以是一个属性或者只是一个成员变量，且可以不是 NSObject的对象，可以只是内置的数据类型。虽然使用 setValue:forKey:的时候，只能使用id作为第二个参数，但是，系统会帮我们自动做好转换工作。（但不建议这么做）成员变量默认是 protected类型，无法在外部直接访问。但可以通过KVC方式赋值。setValue:forKey: 是运行时错误，在编译时不会报错。KVO自动监视（手动监视由我们自己决定）的本质是 ，监视该对象路径下的，指针是否变化。如果是对象本身的内容发生变化，是不会被监视到的。举个例子，如果一个数组被观察着，如果这个数组是mutable的，那么当他addObject的时候，其内容变化了，但是指针没有发生变化，那么是无法被观察到并回调的。只有当直接使用等号，对该路径的指针变量赋值时，才会触发回调函数。参考资料： 基础教学（非常棒）：http://www.jianshu.com/p/d104daf7a062关于KVO的 key 需要满足的条件关于KVO需要涉及到的方法关于KVO的change字典相关内容以及其关键字的意义&nbsp;&nbsp;主动通知和手动通知以及示例：http://www.cnblogs.com/pengyingh/articles/2383629.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IOS方法调配技术]]></title>
      <url>%2F2017%2F02%2F09%2FIOS%E6%96%B9%E6%B3%95%E8%B0%83%E9%85%8D%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[IOS方法调配技术 基础知识： 相关头文件：&lt;objc/runtime.h&gt;、&lt;objc/message.h&gt; 基础数据结构： SEL：是一个结构体指针，它表示的是一个消息的名字。使用它可以快速的定位到方法。 具体定义： typedef struct objc_selector *SEL; 主要作用：可以使用SEL找到具体的方法和方法实现。 IMP：是一个的函数指针。 具体定义： typedef id (*IMP)(id, SEL, ...); 前两个参数是必须的。 主要作用：最终具体的函数代码入口是由这个指针指明的。 Method：是一个结构体指针，它表示一个具体方法的全部信息。 具体定义： - typedef struct method_t *Method; - struct method_t { - SEL name; //方法的名字 - const char *types; //方法的参数以及返回值类型情况 - IMP imp; //方法的具体实现函数指针 //内部函数 - struct SortBySELAddress : - public std::binary_function&lt;const method_t&amp;, - const method_t&amp;, bool&gt; - { bool operator() (const method_t&amp; lhs, - const method_t&amp; rhs) - { return lhs.name &lt; rhs.name; } - }; }; 具体作用：这是一个类中某一个方法的所有信息。关于方法的所有信息最终都是以Method对象的形式，存储在某一个具体的类对象中的。 注意事项：它可以被方法响应链递归查找到，但是它的归属永远都只属于一个类，而且仅有一个实例存在，一旦发生替换，将对查找到该Method的所有响应都产生作用。举例来说，在子类中交换了方法实现，如果子类中的原方法是从父类中继承来的，那么，实际上交换的就是父类原方法和新方法，最后，导致效果就是不仅子类对象的实现被交换，连父类对象的实现也被交换。 注意的是，Method是归属于某一个具体的类的，但是在方法查找时会向父类递归，最终定位到正确的方法。 相关方法：（只列举非常相关的函数） Method相关： Method class_getInstanceMethod(Class cls, SEL name)：：获取实例方法，会递归查找获取。 Method class_getClassMethod(Class cls, SEL name)：获取类方法。会递归查找获取。 Method *class_copyMethodList(Class cls, unsigned int *outCount) ：获取所有方法列表，只包含自己类的Method，父类的Method不包含。 BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) ：为当前类添加一个Method，如果当前类没有这个名字的Method（父类有但是子类没有也是可以成功添加的），那么可以成功添加。否则什么也不做并返回false。 IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) ：替换当前类中名字为SEL的Method的IMP，会递归到父类中替换。 IMP相关： IMP class_getMethodImplementation(Class cls, SEL name) ：获取某个方法的具体实现。 IMP method_getImplementation(Method m) ：获取Method的IMP const char *method_getTypeEncoding(Method m) ：获取Method的参数以及返回值情况 unsigned int method_getNumberOfArguments(Method m)：获取Method的参数个数 char *method_copyReturnType(Method m) ：获取Method的返回值类型 IMP method_setImplementation(Method m, IMP imp) ：设置某个Method的具体实现。 NSObject的类方法： - (IMP)methodForSelector:(SEL)aSelector; + (IMP)instanceMethodForSelector:(SEL)aSelector; 转化函数： NSStringFromSelector：SEL -&gt; string NSSelectorFromString: string -&gt; SEL NSStringFromClass: Class -&gt; string NSClassFromString : string -&gt; Class NSStringFromProtocol: Protocol -&gt; string NSProtocolFromString string -&gt; Protocol 其他： class_respondsToSelector(Class cls, SEL sel) ：判断一个cls类的实例对象能否响应sel方法。 void method_exchangeImplementations(Method m1, Method m2) ：交换两个Method的具体实现。 方法交换的具体代码：（分别为实例方法交换和类方法交换） + (BOOL)swizzleInstanceMethod:(SEL)originalSel with:(SEL)newSel { Method originalMethod = class_getInstanceMethod(self, originalSel); Method newMethod = class_getInstanceMethod(self, newSel); if (!originalMethod || !newMethod) return NO; //该方法允许重复添加方法到class中，只不过此时会返回NO。 //为了确保class中存在该方法，所以做一次添加操作 //当对一个方法进行交换时，一定要确保只将交换局限在当前类中，不要波及到它的父类和子类 //因此，在此处，我们对当前类强制添加这两种方法 //然后使他们交换，这样可以获取到一个安全的结果。确保不会影响到父类的代码 class_addMethod(self, originalSel, class_getMethodImplementation(self, originalSel), method_getTypeEncoding(originalMethod)); class_addMethod(self, newSel, class_getMethodImplementation(self, newSel), method_getTypeEncoding(newMethod)); method_exchangeImplementations(class_getInstanceMethod(self, originalSel), class_getInstanceMethod(self, newSel)); return YES; } //与前者唯一的区别在于刚开始把对象切换到了元类对象上 + (BOOL)swizzleClassMethod:(SEL)originalSel with:(SEL)newSel { //得到的是原类对象 //类对象也是一个对象，它所能调用的方法应该是归属于其meta class的实例方法 Class class = object_getClass(self); Method originalMethod = class_getInstanceMethod(class, originalSel); Method newMethod = class_getInstanceMethod(class, newSel); if (!originalMethod || !newMethod) return NO; class_addMethod(class, originalSel, class_getMethodImplementation(class, originalSel), method_getTypeEncoding(originalMethod)); class_addMethod(class, newSel, class_getMethodImplementation(class, newSel), method_getTypeEncoding(newMethod)); method_exchangeImplementations(class_getInstanceMethod(class, originalSel), class_getInstanceMethod(class, newSel)); return YES; } 使用Blokc形式的简便代码交换方法： 关键方法： IMP imp_implementationWithBlock(id block)，该代码要求 block必须符合以下形式： method_return_type ^(id self, method_args...). ，即第一个参数必须是self。 具体代码： //使用block替换原方法的实现 +(BOOL)replaceInstanceMethod:(SEL)origSEL andNew:(SEL)newSEL withBlock:(id)block{ //与前者唯一的区别在于刚开始把对象切换到了元类对象上 Method origMethod = class_getInstanceMethod(self, origSEL); IMP impl = imp_implementationWithBlock(block); //添加新方法 if (!class_addMethod(self, newSEL, impl, method_getTypeEncoding(origMethod))) { return NO; }else { [self swizzleInstanceMethod:origSEL with:newSEL]; } return YES; } +(BOOL)replaceClassMethod:(SEL)origSEL andNew:(SEL)newSEL withBlock:(id)block{ Class class = object_getClass([self class]); Method origMethod = class_getInstanceMethod(class, origSEL); IMP impl = imp_implementationWithBlock(block); //添加新方法 if (!class_addMethod(class, newSEL, impl, method_getTypeEncoding(origMethod))) { return NO; }else { [self swizzleClassMethod:origSEL with:newSEL]; } return YES; } 如果希望实现对block中对于旧方法的调用，可以使用如下代码： SEL oldSEL = NSSelectorFromString(@"testName"); SEL newSEL = NSSelectorFromString(@"CJF_testName"); [[TestObject2 class] replaceClassMethod:oldSEL andNew:newSEL withBlock:(NSString*)^(id _self){ ((NSString* ( *)(id, SEL))objc_msgSend)(_self, newSEL); NSLog(@"CJF_TestObject"); return @"CJF_TestObject"; }]; 参考文章： 1.Method swizzling解析：http://www.cocoachina.com/ios/20141002/9819.html 2.关于IOS动态获取类的属性和属性类型的方法：http://www.2cto.com/kf/201504/395369.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IOS设备分辨率及常见控件的尺寸]]></title>
      <url>%2F2017%2F02%2F09%2FIOS%E8%AE%BE%E5%A4%87%E5%88%86%E8%BE%A8%E7%8E%87%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%B0%BA%E5%AF%B8%2F</url>
      <content type="text"><![CDATA[IOS设备分辨率及常见控件的尺寸iPhone尺寸标记：设备iPhone宽Width高Height对角线Diagonal逻辑分辨率(point)Scale Factor设备分辨率(pixel)PPI3GS2.4 inches (62.1 mm)4.5 inches (115.5 mm)3.5-inch 320x480@1x320x4801634(s)2.31 inches (58.6 mm)4.5 inches (115.2 mm)3.5-inch320x480@2x640x9603265c2.33 inches (59.2 mm)4.90 inches (124.4 mm)4-inch320x568@2x640x11363265(s)2.31 inches (58.6 mm)4.87 inches (123.8 mm)4-inch320x568@2x640x113632662.64 inches (67.0 mm)5.44 inches (138.1 mm)4.7-inch375x667@2x750x13343266+3.06 inches (77.8 mm)6.22 inches (158.1 mm)5.5-inch414x736@3x(1242x2208-&gt;)1080x1920401参考文章：http://blog.csdn.net/phunxm/article/details/42174937对于@1x、@2x、@3x的像素分辨率关系为：1:2:3。iPad设备尺寸：iPad屏幕尺寸：（开发尺寸）1024 * 768图片使用尺寸：【iPad/iPad mini/iPad Pro 9'7】非Retina：1x Retina: 2x【iPad Pro 12’9】使用@3x图基础空间高度：编程须知：ios7开始使用全屏布局，导航栏与状态栏混为一体（否则较难通过苹果审核），总高度计算为64。在没有使用Navigation布局的时候，需要在布局的时候计算进去。导航栏:在纵向模式下导航栏为44像素高，在横向模式下为32像素高，导航栏提供了一个很少用的提示模式，该模式将高度扩展了30像素，在纵向模式下为320*74像素，在横向模式下为480*74像素。参考文章：http://blog.csdn.net/li198847/article/details/50780265交互指南：在iOS开发中，44这个数字比较特殊。iOS界面指南写着，人类的手指有一定大小，点击区域低于44个点的时候，就难以点中。44的两倍就是88。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apple Watch开发总结]]></title>
      <url>%2F2017%2F02%2F09%2FApple%20Watch%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Apple Watch开发总结基本概念：在watch中，我们目前可以选择基于 ios的代码运行机制（watchOS1.0），也可以选择基于 watchOS的运行机制（watchOS2.0）。这一点在 Build Setting - Architectures - Base SDK 中设置。Build Setting - Architectures - Architecture ,在debug时设为YES可以加快编译速度，在release是需要设为NO，以确保各个版本都能安装成功。这一个选项是说是否仅生成当前版本可运行的二进制。Build Setting - Architectures - Valid Architecture ，需要配置成支持 armv7 arm64 armv7s.Build Setting - Deployment 中， ios Deployment Target 决定了什么版本的ios可以安装此watch，而 watchOS Deployment Target 决定了什么版本的watchOS可以支持该软件。在基于 watchOS的 SKD中，很多库都是不支持的，需要进行强制变更。编译体系类型问题：http://www.cocoachina.com/ios/20140915/9620.htmlwatchKit编程概览：http://www.cocoachina.com/ios/20141121/10282.html，其内主要包含三方面内容：app、glance、notification。对于这类小众平台，请以官方文档作为开发标准，其他任何地方都可能是误导。关于watch setting上的显示字段的差异： 对于watchOS1.0来说，名字读取的是 主app 的 Info.plist里的 Bundle Name对于watchOS2.0来说，名字读取的是 Bundle Display Name.(发生了变化！！！)在watch收到通知时，为了快速的启动响应app，会在后台默认启动app（即 appdidFinishWithLaunch -&gt; 第一个界面被初始化，但是不会有applicationDidBecomeActive 。如果后续在通知界面直接点击进去app，那么会先触发 handleActionWithIdentifier:forRemoteNotification:,然后再触发applicationDidBecomeActive）。在watchOS2中，wacth app和watch extension Bundle ID设置问题： watch app bundle ID：可以任意取，与主app没有任何关系watch extension bundle identify : 【watch app bundle ID】.watchkitextension 等价于：【watch app bundle identify】.watchkitextension、可能出现的报错：原因： 因为以前 watch extension是作为手机的 extension存在的，运行在手机上，所以前缀只要是手机bundle id就可以了（之前是 com.360buy.jdmobile.jdAppleWatchExtension ）。但是现在，watch extension 作为watch app的extension (目前来看实现原理是这样的)，就必须要求前缀是 watch的 bundle id（也就是 com.360buy.jdmobile.jdAppleWatch.watchkitextension ）。watchOS1中的设置：extension是作为主app的extension存在的，因此只需要extension的bundle ID前缀为主 app的bundle ID即可。watch提交APP Store审核：图片和iCon要求： icon需要一张，图片需要5张【42mm截图】。直接截图可能不符合要求，因为不能含有Alpha通道，将图片转换为JPG可以去除Alpha通道。基础编程：如果希望更改controller左侧上方的标题的颜色，那么就需要在 storyboard 中任意一个controller的File Inspect 的 Interface Builder Document - Global Tint 改为相应的颜色。目前watch的颜色为 FF2E11。WCSession在使用过程中发现有以下特点： 使用applicationContext可以传递一些固定类型的更新数据（使用的是后台更新方式）： 在输出过程中，如果数据一直堆积没有被提交，那么只会更新最后的数据并提交相同的数据在传输前会先与之前已传输的数据做校验，如果相同，那么就不会传输数据。如果当前app处于关闭状态或者未链接状态，那么会等到app启动时，再进行数据传输。如果删除掉watch上的app，那么堆积的未传递消息将不会再传送过去。且之前保存在本地固化的数据也会消失。等 receive app处于后台运行时，也是可以被交付的。需要做好保护工作。使用 userInfo 传递信息时： 所有传递的信息都会按序排队，并最终传递到配对的app中每一条数据都会引发一次回调等 receive app处于后台运行时，也是可以被交付的。需要做好保护工作。Watch中与 UIApplication 地位一致的全局应用管理对象是 WKExtension ，分别需要实现的协议方式是 UIApplicationDelegate 和 WKExtensionDelegate 方法。视图开发指南：watch分为两套屏幕大小适配： 38mm：272px*340px【4：5】42mm：312px*390px【4：5】状态栏大小：20pt，即40pxwatch上的布局方式： 只能采用group进行相对布局，默认来说，除了group以外，所有元素都是不可重叠的，只能作为leaf元素存在。button是一个比较特殊的容器，它有一个属性可以在text 和 group之间切换，即它可以变成一个 group 去进行布局。watch在同一片区域上，不允许同级关系的元素存在，只允许父子关系。且非根节点只能是 group 或者是 group形态的button。 这就导致了非叶节点的透明度设置，一定会影响到它的叶节点，应该要注意这个特点是否符合预期。如果不符合，则需要设计出图支持。group是一个类似于 CSS 中 盒模式的一种布局容器，其拥有以下几个重要特性： 方向：默认是横向布局Inset：group内的内容的边框大小spacing：内容之间的间距元素frame设置： width和height可以分为三种情况设置： 自适应内容相对于容器的大小，可微调。固定pt大小size分为x和y各有三种情况：（无法指定一个具体的位置） x0：left、center、righty0：top、center、bottom基本上所有的元素属性设置都分为 通用版、38MM 和 42MM，只有在特定屏幕类型不指定时，才会使用通用版。WKInterfaceTable: 这个类一旦成为某一个controller的property，那么它的delegate就自动成为这个controller。interfaceController中只有以下几个delegate方法： - (void)table:(WKInterfaceTable *)table didSelectRowAtIndex:(NSInteger)rowIndex;- (nullable id)contextForSegueWithIdentifier:(NSString *)segueIdentifier inTable:(WKInterfaceTable *)table rowIndex:(NSInteger)rowIndex;- (nullable NSArray *)contextsForSegueWithIdentifier:(NSString *)segueIdentifier inTable:(WKInterfaceTable *)table rowIndex:(NSInteger)rowIndex;WKInterfaceTable datasource是不存的，需要我们自己手动为其赋值，并为每一行设置界面。一般来说分为以下步骤： 在storyboard中画出各种不同的table row，并为每一个table row添加一个管理器类（继承与NSObject）。绘制时，可以设置row的高度、selectable可选中性等。在interfaceController 中，WKInterfaceTable setRowType: 或者是 setRowNumber:withType: 来设置row。再通过 WKInterfaceTable rowControllerWithIndex: 获取每一个的rowController，并通过它设置每一个row的界面布局。当row的高度大于等于一屏时，将导致table是可滚动的，此时可以把高度改为 size to fit content，来使height尽可能的小。当应该要确保布局是从上而下进行的。当设置WKInterfaceTable setRowType: 或者是 setRowNumber:withType: 参数为空数组或者0时，列表中无row数据。常见错误：在使用本地文件测试消息push时，如果发生 apns json语法错误，那么会报 SPErrorUnknownMessage的错误。watch常见的二进制包不存在问题：http://stackoverflow.com/questions/29972534/failed-to-install-app-error-invalid-bundle-no-apple-watch-binarywatch OS1 和 OS2 在主app中包含的方式是不同的，在配置了 Target Dependency 后 ，OS1 是在 Embed Extension App 中添加二进制代码，而 OS2是在 Embed Watch Content 中添加二进制代码。需要维持它们的info.plist 中 Excutable File 都是${EXECUTABLE_NAME}，否则可能会出错。ios Deployment Target设置的 和 主app的版本不一致。也有一种说法是说这是 watchOS1 自带的bug。watch单独编译是没有意义的，一定要先在xcode上运行手机Target，然后再切换到手表target，这样才能正确的获取到最新的watch代码编译程序。WatchConnectivity框架使用：关于watch中几个状态变量的描述： paired: 判断是否配对，这个变量只有在 session activation 后才可以正常使用。并不是表示手机和手表是否处于实时连接状态，只是表示手机是否有相应配对的手表。install: 判断手表app是否安装，这个变量只有在 session activation 后才可以正常使用。这个变量在手表和手机断开实时连接后，会默认变为NO。reachable: 判断手机app和手表app是否处于实时可通信状态。这个变量只有在 session activation 后才可以正常使用。只有这个值为YES的时候才可以使用 sendMessage 发送实时消息。两边的判断依据是不一样的： In your WatchKit extension, the value of this property is YES when a matching session is active on the user’s iPhone and the device is within range so that communication may occur.On iOS, the value is YES when a paired and active Apple Watch is in range and the associated Watch app is running in the foreground. In all other cases, the value is NO.activationState: 表示当前session的 activation 状态。当发起实时连接时，如果配对的手机app没有启动，那么将在后台被唤醒（且一定可以被唤醒）。被唤醒时的主要函数调用为： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions- (void)session:(nonnull WCSession *)session didReceiveMessage:(nonnull NSDictionary&lt;NSString *,id&gt; *)message replyHandler:(nonnull void (^)(NSDictionary&lt;NSString *,id&gt; * __nonnull))replyHandler当使用实时消息唤醒iPhone App时，在 application:didFinishLaunchingWithOptions: 中传入的 launchOptions 为 nil，与用户手动点击的状态一致。但是可以区分的是，当用户手动点击启动时，在这个函数中，applicationState 状态是UIApplicationStateInactive，但是当后台唤醒时，applicationState 状态是UIApplicationStateBackground，且不会再进入- (void)applicationDidEnterBackground:(UIApplication *)application 函数。由此可以用来设置标志位，标记到底是源于什么原因的启动。当蓝牙断开重连后，大概需要30s的时间，去建立一个稳定的session链接，在30s内，任何消息的发送（特别是实时消息）都有可能会失败。且比较诡异的事是，稳定的网络链接，将比稳定的session链接更早的建立（一重连完成就建立了）。tableView界面不刷新问题： 发生时机：当页面不是界面栈的栈顶，即非展示页面时，对该页面的tableView进行UI刷新，会发现操作无法生效。原因：系统bug导致。解决方案：在页面willActive时，对页面进行刷新操作。【可以增加附加条件，控制刷新数量】WatchOS2.0开发笔记：watchOS的基础架构发生了变化，target请使用以下设置：watchOS可以引用的系统库急剧减少，请依次check后再添加。App Group 在watchOS2.0时不可用。watch2.0中，通知的生命周期如下：（这也将意味着 自定义通知展示时，后台是默认打开了app了） watch notification controller 的以下两个函数之一： - (void)didReceiveRemoteNotification:(NSDictionary *)remoteNotification withCompletion:(void(^)(WKUserNotificationInterfaceType interface)) completionHandler;- (void)didReceiveLocalNotification:(UILocalNotification *)localNotification withCompletion:(void(^)(WKUserNotificationInterfaceType interface)) completionHandler; 将会最先先被调用。然后是 watch notification controller 的 willActive 生命周期函数被调用。注意，watch notification controller 的 awakeContext 函数不会被调用！接着是 watch appdelegate 的 appDidFinishWithLaunch 函数被调用，接下去的流程与正常打开app一致。然后就是在后台正常的加载 第一个 Interface Controller。watchOS2.0 第三方库打包方式：最好使用单独的watch framework设置，在生成target时可以单独选择第三方库必须包含架构armv7k，且supported platforms必须是watchOS,base sdk选为 latest watchOS。（如果使用watch framework target设置，那么这些都是默认设置）。 否则会出现警告:building for watchOS simulator, but linking in object file built for iOS, for architecture i386.watch framework必须支持bitcode设置，因此，我们需要在 Other linker flag 、 Other C flag 和 Other C++ flag 中添加 -fembed-bitcode 参数。 watch设置详情：http://stackoverflow.com/questions/32868297/compiling-ios-library-with-bitcode-enabled参数具体含义解析：http://stackoverflow.com/questions/31233395/ios-library-to-bitcode在 build setting 中 正确的设置 ios Deployment target 和 watch Deploment target 两个选项。watch可以使用静态库，也可以使用动态库。但推荐使用静态库。参考文章：iPhone开发同事配置Watch target的建议.docxwatchTarget配置要点.docx苹果消息测试总结.docxWatch开发分享.pptx]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS核心动画高级编程：读书笔记]]></title>
      <url>%2F2017%2F02%2F08%2FiOS%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[iOS核心动画高级编程：读书笔记 iOS设备图形显示架构： ios设备情况概览：http://iosres.com/ 示例演示代码：CoreAnimationTest-master.zip CALayer基础属性： 每一个layer都可以分为 背景层 + 寄宿图层（content层） CALayer并不支持自动大小和自动布局。 layer的坐标系相关属性： layer的坐标系以左上角为原点的。 主要属性：frame、bounds、postion、 anchorPoint、transform frame：由其它几个变量经过计算后得出，直接改变它的值，可以影响 view 的 size和postion。frame的位置基准点永远都是左上角的点。 bounds：决定layer 的 size。 postion：它指明了锚点相对于父图层的位置，从而可以影响layer的位置。 anchorPoint：以锚点为基准点，确定layer的位置。锚点还是layer做图形变换时的支点。 transform：可以决定矩形变换原则。可以在position不变的情况下，改变layer的位置等。 坐标属性之间的相互关系： layer的size影响：bounds 和 frame layer的position影响：anchorPoint 和 position 和 frame（frame本质上是通过改变） 即frame决定了该layer在 superLayer中的位置，而 bounds决定了其 本地坐标系，该坐标系将决定其 subLayer的布局。而本地坐标系的定位，就是相当于 layer的 bounds.origin 在本地坐标系的相应位置，然后反推出原点位置即可。 view的布局其实就是layer布局的一层封装，最后直接取的是layer中的值。 layer的寄宿图有两种生成方式： layer的content赋值 直接对content属性进行赋值 layer的delegate的- (void)displayLayer:(CALayer *)layer中对layer的content进行赋值。 使用Custom Drawing绘制： UIView的drawRect函数就是对自己封装的layer的一次绘制。 layer的delegate的- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx 就是对layer的一次绘制。 这种方式存在性能问题： 一旦你实现了 CALayerDelegate 协议中的 -drawLayer:inContext: 方法或者 UIView 中的 -drawRect: 方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽*图层高*4字节，宽高的单位均为像素。对于一个在Retina iPad上的全屏图层来说，这个内存量就是 2048*1526*4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配. 绘制一般需要使用Core Graphics，而软件绘制的效率远不如硬件对图像处理的速度来的快。最好使用一些专用的layer子类，去实现硬件加速，完成性能优化。 layer的内容相关属性： contentGravity：content的放置方式。（与UIview的contentMode类似） contentScale：寄宿图像素与点的比例关系。（即[UIScreen mainScreen].scale），因为CGImage没有scale的概念，因此如果layer的这个值设置不正确的话，图像可能会模糊展示。因此，最好手动设置为当前屏幕的scale。 maskToBounds:截断边界展示。 contentRect：一个相对的Rect值，表示展示content中的哪个区域的内容 contentCenter：一个相对的Rect值。九宫格划分，表示content拉伸时，哪个区域是不可拉伸的。可以在xib上直接设置（stretching栏） layer的视觉效果属性： 圆角效果：connerRadius，设置的是圆角半径。一般只影响背景而不影响寄宿图和子图层。需要配合maskToBounds才能对content产生截断效果。 图形边框：borderWidth 和 borderColor。 边框是绘制在图层边界里面的（确保不会被maskToBounds截断）,而且在所有子内容之前,也在子图层之前（会覆盖在所有子图层上方）。 阴影效果： shadowOpacity：阴影透明度【0.0，1.0】 shadowColor：阴影颜色，CGColorRef shadowOffset：阴影的偏移方向，CGSize值。（+x向右，+y向下）。苹果更倾向于阴影是垂直向下的。 shadowRadius：阴影的模糊度，即它与边界的分割清晰度。为0时有明确的分割，越大越模糊。 shadowPath：指定任意阴影的形状，这可以加快阴影的绘制速度，并达到定制化的效果。（建议添加） 需要注意的是，阴影是根据content内容的外形来计算阴影的，而不是layer的大小或者是content的大小。 阴影是不计算在边界大小内的，如果它超出边界范围，那么就可能会被 maskToBounds阶段。可以用两个图层解决这个问题：一个只画阴影的空的外图 层,和一个用 masksToBounds 裁剪内容的内图层。 图层蒙版：mask，可以设置一个layer作为蒙版，只展示两个图层实心重叠的部分。 mask 图层的 Color 属性是无关紧要的,真正重要的是图层的轮廓。 mask 属性就像是一个饼干切割机, mask 图层实心的部分会被保留下来,其他的则会被抛弃。 CALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为 mask 属性,这意味着你的蒙板可以通过代码甚至是动画实时生成。 拉伸过滤：minificationFilter（缩小过滤器）和 magnificationFilter（放大过滤器）。 重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容,放大或是缩小的需求等这些因素。 CALayer 为此提供了三种拉伸过滤方法,他们是: kCAFilterLinear （默认） kCAFilterNearest kCAFilterTrilinear（效果与默认相近） 对于比较小的图或者是差异特别明显,极少斜线的大图,最近过滤算法会保留这种差异明显的特质以现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说,最近过滤算法会导致更差的结果。换句话说,线性过滤保留了形状,最近过滤则保留了像素的差异。 组透明：使用 shouldRasterize来实现整个layer图层统一透明度。 layer的变换属性： CGAffineTransform：仿射变换，适用于2D坐标变换。 主要分为三大模块：Rotation（旋转，弧度单位，顺时针为正）、Scale（缩放）、Translation（平移） 这些效果是可以叠加使用的，只要在同一个CGAffineTransform对象上变换即可。 CGAffineTransform对象的生成和变换全部有现成的函数可以使用。 混合变换顺序问题： 产生原因：当使用同一个CGAffineTransform 对象完成多种变换时，变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。 具体现象：先添加的变换，将影响之后的变换的值。最明显的例子就是：先平移200，再缩放0.5的话，200的平移量是可以被确保的。但是先缩放0.5，再平移200的话，平移的量就只有100了。 CATransform3D：3D变换，适用于3D坐标变换。 主要分为三大模块：Rotation（旋转，弧度单位，以某个坐标轴为旋转轴旋转）、Scale（缩放，x,y,z均可缩放）、Translation（平移，x,y,z均可平移） 这些效果是可以叠加使用的，只要在同一个CATransform3D 对象上变换即可。 3D成像透视效果的关键： 灭点：当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。在现实中，这个点通常是视图的中心，于是为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。 实现3D对象统一灭点的方案：在包含所有3D对象的父图层上，设置它的sublayerTransform属性，之后，我们就可以根据postion和frame自由的设置3D对象的位置了。具体代码示例如下： //apply perspective transform to container CATransform3D perspective = CATransform3DIdentity; perspective.m34 = - 1.0 / 500.0; self.containerView.layer.sublayerTransform = perspective; m34的取值大小：1/( 500 - 1000) 就很不错了，分母的值代表透视的距离。减少距离可以增强透视效果，一个非常大的值将失去透视效果。 3D旋转的叠加效应： 现象：绕Z轴旋转时，实际上就是2D旋转，其效应是可以抵消的（即父图层上的正向变换和子图层上的反向变换，将导致子图层复原）。但是，绕X轴和Y轴旋转，是一种3D旋转，它是不会产生抵消效应的。 原因：这是由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在同一个3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。 解决方案：如果希望一些3D对象共享一个3D空间，可以使用CATransformLayer，这是个特殊的CALayer子类，他可以使它的子图层处于同一个3D空间上。 zPostion修改展示顺序：修改zPostion可以调整图层在父图层中的展示顺序。添加到父图层中的顺序决定了图层树中的顺序，而图层树中的顺序决定了事件响应的顺序。当我们通过修改视图的zPostion改变显示的优先级，但这不会改变事件响应的顺序。这就可能出现，视图展示在最前面，但是事件被后面的视图劫走了，因此，当我们修改zPostion时应该要小心这一点。 CALayer Custom Drawing绘制方式：（详解） 我们绘制的内容最终会转化为一个CGImage对象，传给CALayer使用。即其实CALayer只支持显示一种 content ====&gt; CGImage对象。 有两种方式可以实现对图层的自定义绘制，绘制内容利用原生的Core Graphics方法实现的，具体实现如下： 当使用系统原生的layer时： 设置该layer的delegate，并在该delegate对象中实现CALayerDelegate中的 drawLayer:(CALayer*)layer inContext:(CGComtextRef)ctx 函数。（不需要声明实现CALayerDelegate 协议，因为在NSObject中已经默认实现了） drawLayer:(CALayer*)layer inContext:(CGComtextRef)ctx 中完成绘制工作。 -(void)drawInContext:(CGContextRef)ctx{ UIImage *image=[UIImage imageNamed:@"luhan.jpg"]; CGContextDrawImage(ctx, CGRectMake(0, 0, 200, 200), image.CGImage); } 当使用自己实现的CALayer子类时，我们可以实现 -drawInContext: 方法来实现绘制。 在这里顺带可以说一下CALayer的几个关键函数： display : 用于更新layer的content内容（绘制内容也是content内容的一种）。首先，判断是否有delegate实现 了 displayLayer: 方法，有的话就直接返回相应的数；否则生成 context，并且在内部调用 drawInContext ，然后更新 layer的content属性。不要直接调用这个函数。 drawInContext ：当delegate没有实现 了 displayLayer: 方法时，会被调用。调用后，会在内部调用delegate的 drawLayer:(CALayer*)layer inContext:(CGComtextRef)ctx 方法。 seetNeedDisplay: 表示layer需要更新内容，并在合适的时候更新layer。 displayeIfNeeded：表示立即更新layer。 嵌入CALayer生命周期中的delegate方法： - (void)displayLayer:(CALayer *)layer：如果定义了这个方法，那么将在layer的 -display 方法中调用。它应该实现全部的display的流程，典型的就是设置layer的content属性。 - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx：如果定义了这个方法，那么将在layer的 -drawInContext: 中调用。 - (void)layoutSublayersOfLayer:(CALayer *)layer：在 -layoutSublayers 中被调用，且在 layer manager 被检查之前。如果delegate的方法正在被调用，那么 manager将被忽略。 - (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event：如果定义了这个方法，那么将在 -actionForKey: 中被调用。这个方法应该返回一个实现了 CAAction 协议的对象。如果delegate没有为某一个event指定行为，那么可以返回nil。返回一个[NSNull null]对象，可以明确的表示不再进行进一步的搜索。 CALayer的子类划分： CAShapeLayer：形状绘制图层。所有可以用CGPath表示的形状，都可以用CAShapeLayer来绘制。当然，我们也可以用Custom Drawing+Core Graphics来完成绘制和展示。 CAShapeLayer有以下优点： 渲染快速，有硬件加速支持。 高效使用内存，不像CALayer创建同等大小的寄宿图用于绘制，它无论多大，都不会占用很大的内存。 不会被图层边界裁剪掉。 不会出现像素化。 你可以控制一些属性比如 lineWith （线宽，用点表示单位）， lineCap （线条结尾的样子），和 lineJoin （线条之间的结合点的样子）；但是在图层层面你只有一次机会设置这些属性（需要在绘制前设置）。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。 代码示例： UIBezierPath *path = [[UIBezierPath alloc] init]; [path moveToPoint:CGPointMake(175, 100)]; [path addArcWithCenter:CGPointMake(150, 100) radius:25 startAngle:0 endAngle:[path moveToPoint:CGPointMake(150, 125)]; [path addLineToPoint:CGPointMake(150, 175)]; [path addLineToPoint:CGPointMake(125, 225)]; [path moveToPoint:CGPointMake(150, 175)]; [path addLineToPoint:CGPointMake(175, 225)]; [path moveToPoint:CGPointMake(100, 150)]; [path addLineToPoint:CGPointMake(200, 150)]; //create shape layer CAShapeLayer *shapeLayer = [CAShapeLayer layer]; shapeLayer.strokeColor = [UIColor redColor].CGColor; shapeLayer.fillColor = [UIColor clearColor].CGColor; shapeLayer.lineWidth = 5; shapeLayer.lineJoin = kCALineJoinRound; shapeLayer.lineCap = kCALineCapRound; shapeLayer.path = path.CGPath; //add it to our view [self.containerView.layer addSublayer:shapeLayer]; CATextLayer：文件展示图层。使用Core Text引擎渲染，效率高于UILabel。如果希望开发效率高些，可以使用Text Kit。综合来说： 简单且性能要求高的：CATextLayer 复杂且性能要求高的：Text Kit 简单无性能要去的：UILabel CATransformLayer：3D对象空间共享图层，是一个容器图层，可以使加入其中的子图层共享一个3D空间。方便做统一的3D变换。 CAGradientLayer：渐变色图层。使用硬件加速，性能好。 指定位置渐变代码示例： //create gradient layer and add it to our container view CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.frame = self.containerView.bounds; [self.containerView.layer addSublayer:gradientLayer]; //set gradient colors gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge //set locations gradientLayer.locations = @[@0.0, @0.25, @0.5]; //set gradient start and end points gradientLayer.startPoint = CGPointMake(0, 0); colos：决定了有几种颜色参与渐变 locations:决定了每种颜色结束的位置。但是即使设为0或者1，那种颜色还是会参与边缘渐变 startPoint和endPoint：决定了渐变开始和结束的位置，提供了一个向量方向。但是没有在这个范围里的内容，将使用单色填充。 简单渐变代码示例： //create gradient layer and add it to our container view CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.frame = self.containerView.bounds; [self.containerView.layer addSublayer:gradientLayer]; //set gradient colors gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge //set gradient start and end points gradientLayer.startPoint = CGPointMake(0, 0); CAReplicatorLayer：迭代变换对象图层。 这个图层在复制子图层时，连子图层的动画效果等都可以原封不动的copy过去，而且还可以设置copy图层的时间间隔。拷贝时的属性变化时直接作用于当时子图层的实际属性上的。 代码示例： //create a replicator layer and add it to our view CAReplicatorLayer *replicator = [CAReplicatorLayer layer]; replicator.frame = self.containerView.bounds; [self.containerView.layer addSublayer:replicator]; //configure the replicator replicator.instanceCount = 10; //apply a transform for each instance CATransform3D transform = CATransform3DIdentity; transform = CATransform3DTranslate(transform, 0, 200, 0); transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1); transform = CATransform3DTranslate(transform, 0, -200, 0); replicator.instanceTransform = transform; //apply a color shift for each instance replicator.instanceBlueOffset = -0.1; replicator.instanceGreenOffset = -0.1; //create a sublayer and place it inside the replicator CALayer *layer = [CALayer layer]; layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f); layer.backgroundColor = [UIColor whiteColor].CGColor; [replicator addSublayer:layer]; 效果示例： 适合使用的场景：反射（它可以对加入的多个子layer，做相同的变换）、轨迹变化等 CAScrollLayer：滑动图层。UIScrollView 并没有用 CAScrollLayer ，事实上，就是简单的通过直接操作图层边界来实现滑动。 CATiledLayer：大图分步载入图层。CATiledLayer 为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。 操作步骤： 将大图分割为小图，分成不同文件保存。 设置CATiledLayer的大小为图片的大小。 设置CATiledLayer的delegate，实现分步加载图片。 代码示例如下： - (void)viewDidLoad { [super viewDidLoad]; //add the tiled layer CATiledLayer *tileLayer = [CATiledLayer layer]; tileLayer.frame = CGRectMake(0, 0, 2048, 2048); tileLayer.delegate = self; [self.scrollView.layer addSublayer:tileLayer]; //configure the scroll view self.scrollView.contentSize = tileLayer.frame.size; //draw layer [tileLayer setNeedsDisplay]; } - (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx { //determine tile coordinate CGRect bounds = CGContextGetClipBoundingBox(ctx); NSInteger x = floor(bounds.origin.x / layer.tileSize.width); NSInteger y = floor(bounds.origin.y / layer.tileSize.height); //load tile image NSString *imageName = [NSString stringWithFormat: @"Snowman_%02i_%02i", NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName]; UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath]; //draw tile UIGraphicsPushContext(ctx); [tileImage drawInRect:bounds]; UIGraphicsPopContext(); } CAEmitterLayer：粒子效果图层。 CAEAGLLayer：OpenGL展示图层。 AVPlayerLayer：视频播放图层。AVPlayerLayer 是用来在iOS上播放视频的。他是高级接口例如 MPMoivePlayer 的底层实现，提供了显示视频的底层控制。 AVPlayerLayer 的使用相当简单：你可以用 +playerLayerWithPlayer: 方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用 player 属性绑定一个 AVPlayer 实例。 准备工作：我们需要添加AVFoundation到我们的项目中。 代码示例： //get video URL NSURL *URL = [[NSBundle mainBundle] URLForResource:@"Ship" withExtension:@"//create player and player layer AVPlayer *player = [AVPlayer playerWithURL:URL]; AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player]; //set player layer frame and attach it to our view playerLayer.frame = self.containerView.bounds; [self.containerView.layer addSublayer:playerLayer]; //play the video [player play]; 可以用于实现动画的方式： 隐式动画，仅能作用于单一属性。 基本属性动画：CABasicAnimation，仅能作用于单一属性。 关键帧动画：CAKeyFrameAnimation，仅能作用于单一属性。 动画组：CAAnimationGroup，可以包含CABasicAnimation 和 CAKeyFrameAnimation 过渡动画：CATransition，用于图层大范围动画变化。 UIView提供的动画组接口、关键帧动画接口和过渡动画接口。 NSTimer/CADispalyLink实现的关键帧动画 CALayer隐式动画：（隐式动画是CABasicAnimation的一种） CALayer的基本属性几乎都是支持隐式动画的，直接修改这些属性值，都会引发默认的隐式动画。动画默认时长为0.25s。 UIView对CALayer做了一次封装，它实现了CALayerDelegate中的 - (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event 的代理方法，针对隐式动画的操作，全部都返回nil。只有UIView的显示动画，才会返回正确的action对象，去执行动画。（注意，属性值的改变不是在这一步做的，这一步只是动画） 这个代理方法其实是在 layer的 actionForKey 这个函数中被调用。它的具体步骤如下： 图层首先检测它是否有委托,并且是否实现 CALayerDelegate 协议指定的 - actionForLayer:forKey 方法。如果有,直接调用并返回结果。 如果没有委托,或者委托没有实现 方法,图层接 着检查包含属性名称对应行为映射的 字典。（但在这一步可以返回[NSNull null]对象，提前结束搜索） 如果 actions字典 没有包含对应的属性,那么图层接着在它的 style 字典接 着搜索属性名。 最后,如果在 style 里面也找不到对应的行为,那么图层将会直接调用定义 了每个属性的标准行为的 -defaultActionForKey: 方法。 所以一轮完整的搜索结束之后, 要么返回空(这种情况下将不 会有动画发生),要么是 协议对应的对象,最后 CALayer 拿这个结果 去对先前和当前的值做动画。 在动画执行过程中，图层属性值保存的是动画结束后的值（即最终值），当前图层的属性其实是保存在一个 presentationLayer中的，我们如果想知道当前屏幕上layer的实时信息的话，获取这个 presentationLayer 的属性才是正确的值。 从上面可以知道，我们的显示层级可以分为：图层树 -&gt; 呈现数 -&gt; 渲染树（后面提及） CATransaction的常用方法： 【CATransaction begin】 + 【CATransaction commit】：用于组成一个事务，动画的执行是以事务为单位执行的。run loop 会自动把一次 run loop周期内的隐式动画打包成一个事务来执行。 【CATransaction setDuration:】:设置即将执行的下一个事务的持续时间。只作用于下一个事务。不设置的话，默认为0.25s。 【CATransaction setDisableActions：】：默认为NO，设置为YES后，下一个隐式动画的事务提交时，将不会执行动画，而是立即发生变化。注意，有效期只有一次。 我们可以针对某一个具体的属性值，设置自定义动画，以覆盖默认的隐式动画，达到定制化的效果。 步骤：只需要生成一个 符合CAAction协议的对象后，将它作为一个键值对添加到 layer.actions 这个字典中去就好了。 CALayer 显式动画： 显式动画：可以对一些指定的属性做自定义动画，或者是完成非线性的变化操作。 显式动画不会真正的改变layer的属性值，它带来的只是动画上的变化。如果我们希望在显示动画完成后，同时修改界面的值，那么请在 addAnimation 后，再直接修改属性的值。（建议可以立即执行） 修改属性值，必须关闭隐式动画，否则将会产生两个动画效果。 具体操作步骤：创建一个事务【CATransaction begin】，设置【CATransaction setDisableActions：YES】，然后修改属性值，最后提交这个事务【CATransaction commit】。 公有属性设置： duration：持续时间 由于CAAnimation对象是支持KVC的，所以我们可以使用 【layer_var setValue:xxx forKey:xxx】来完成附加自定义变量。（比如我们可以把对象的layer绑定到animation对象上，[animation setValue:handView forKey:@"handView"]; 这样就可以在回调发生是，非常简单的获取到layer了） 添加或者删除操作： 添加一个动画到CALayer,anim传入后会进行一次深拷贝，最后回调中出现的对象也是深拷贝后的对象（无法靠比较指针来判断是哪个动画），因此建议传入key值，然后通过 animationForKey： 判断是哪个动画。 - (void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key; 移除layer上已经添加的所有animation - (void)removeAllAnimations; 移除layer上指定key的animation - (void)removeAnimationForKey:(NSString *)key; 返回一个数组包含所有当前已加入layer的animation的key。需要注意的是，当一个动画执行结束后，它就自动被移除了。 - (nullable NSArray&lt;NSString *&gt; *)animationKeys; 返回一个指定key值的animation对象 - (nullable CAAnimation *)animationForKey:(NSString *)key; 显式动画的分类： 隐式动画：CABasicAnimation，作用于单一属性。属性动画的一种。 keyPath：决定了需要设置的属性对象key值 toValue：绝对值赋值 byValue：相对值赋值 关键帧动画：CAKeyFrameAnimation，作用于单一属性。属性动画的一种。 keyPath：决定了需要设置的属性对象key值 由于动画在开始时会突然从原有的属性值变到第一帧的值，然后在结束时会从最后一帧的值突然变回属性值。因此，建议第一帧和最后一帧的动画帧值要与当时的属性值保持一致。 需要注意的是，整个动画是以一个恒定的速度在变化的，并没有在缓冲区时减速/加速，这会导致看起来比较奇怪。因此，我们将使用在以后的章节对它做出改变。 values：普通属性的关键桢变化 path：点属性的变化路线 rotationMode：表示变化过程中元素的朝向（不变或者是沿着曲线切边） 显示动画组：CAAnimationGroup 可以把属性动画和关键帧动画组合在一起。(CABasicAnimation 和 CAKeyframeAnimation 仅仅作用于单独的属性) animations：显示动画数组 加入到动画组的动画如果不指定duration，那么将使用动画组的duration。当然也可以指定duration，那么将优先使用各个动画自己的duration。 过渡动画： CATransition，用于完成属性动画无法设置的一些变化。比如 layer 的 content 变化，整个图层的remove 和 add 操作等。 type：决定了动画的显示效果。 kCATransitionFade 默认的过渡类型 ，当你在改变图层属性之后，就创建了一个平滑的淡入淡出效果。 kCATransitionPush ，它创建了一个新的图层，从边缘的一侧滑动进来，把旧图层从另一侧推出去的效果。 kCATransitionMoveIn 实现了一个定向滑动的动画,从顶部滑动进入，但不像推送动画那样把老土层推走。 kCATransitionReveal 也实现了一个定向滑动的动画，但是有一些细微的不同，kCATransitionReveal 把原始的图层滑动出去来显示新的外观，而不是把新的图层滑动进入。 subtype：决定了动画的进入方向。（后面三种type有subtype这个选项） kCATransitionFromRight kCATransitionFromLeft kCATransitionFromTop kCATransitionFromBottom 注意：对于指定的图层，一次只能添加一个 CATransition 动画。（而属性动画一次是可以添加多个的）。添加一次，动画效果将在下次图层变化时生效，有效期只有一次。 CATransision 可以对图层任何变化平滑过渡的事实使得它成为那些不好做动画的属性图层行为的理想候选。苹果当然意识到了这点，并且当设置了 CALayer 的 content 属性的时候， CATransition 的确是默认的行为。但是被视图包裹的图层这一特性也是被禁用的。 使用技巧：要确保 CATransition 添加到的图层在过渡动画发生时不会在树状结构中被移除，否则 CATransition 将会和图层一起被移除。一般来说，你只需要将动画添加到被影响图层的 superlayer 。 UIView层级的封装：是苹果通过 UIView +transitionFromView:toView:duration:options:completion: 和 +transitionWithView:duration:options:animations: 方法提供了Core Animation的过渡特性。但是这里的可用的过渡选项和 CATransition 的 type 属性提供的常量完全不同。 虚拟属性赋值：CAAnimation在做动画时是支持虚拟属性设置的。 比如你不可以直接设置 transform.rotation 或者 transform.scale ，他们不能被 直接使用。当你对他们做动画时，Core Animation自动地根据通 过 CAValueFunction 来计算的值来更新 transform 属性。 CAValueFunction 用于把我们赋给虚拟的 transform.rotation 简单浮点值转 换成真正的用于摆放图层的 CATransform3D 矩阵值。你可以通过设 置 CAPropertyAnimation 的 valueFunction 属性来改变，于是你设置的函数将 会覆盖默认的函数。 因此，我们可以设置值 ：（目前已知的是transform.rotation 和 transform.scale 可用） CABasicAnimation *animation = [CABasicAnimation animation]; animation.keyPath = @"transform.rotation"; animation.duration = 2.0; animation.byValue = @(M_PI * 2); [shipLayer addAnimation:animation forKey:nil]; 这一种设置值的方式，对于 transform 属性非常有用。 回调函数： 当动画开始执行签被调用 - (void)animationDidStart:(CAAnimation *)anim; 当动画完成或者被绑定的对象移除时，都会被调用。当动画完成后被调用时，flag是true，否则为false。 - (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag; 动画增删操作： 显示动画一旦被移除（隐式动画无法移除），图层的外观就立刻更新到当前的模型图层（是model层，而不是呈现presentation层）的值。一般说来，动画在结束之后被自动移除，除非设置 removedOnCompletion 为 NO ，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。 所有的动画在执行过程中添加新的动画的话，他们会一起生效的。 动画持久化的方式： 方式一：在动画add会立即修改 layer的属性。此时 frame 属性已经变化。 方式二：removedOnCompletion 为 NO，此时frame属性没有变化。 CAMediaTiming协议：（利用时间操纵动画的方式） CoreAnimation有一个全局时间的概念，也就是所谓的马赫时间。马赫时间在设备上所有进程都是全局的--但是在不同设备上并不是全局的--不过这已经足够对动画的参考点提供便利了，你可以使用 CACurrentMediaTime 函数来访问马赫时间。注意当设备 休眠的时候马赫时间会暂停，也就是所有的 CAAnimations （基于马赫时间）同样也会暂停。 每个layer还有自己的一个本地时间概念： 动画也存在层级关系： 一个是通过 CALayer的图层树确定的层级关系（所有作用于一个layer上的动画都是这个layer的子动画）。 一个是通过CAAnimation的group完成的动画组。 CALayer和CAAnimation都实现了 CAMediaTiming协议，该协议可以使动画对象和图层对象自由的控制他们的动画（包括子动画）的时间属性。 协议的具体参数： beginTime:设置动画的延迟执行时间。（可以影响子动画）默认是0。 duration：单次正向动画的预期执行时间。（与实际执行时间还要参考其它因素） speed：动画的执行速度，默认是1。它和duration决定了动画 的真正执行时间。越大则速度越快，实际执行时间越短，否则反之。（可以影响子动画）。为0 的时候可以暂停动画的执行，负值时，可以反向执行动画。speed 可以影响duration和beginTime,但是无法影响 timeoffset.（例如：当speed=2.0时，一个duration=1.0的动画，将在0.5s内就执行完成） timeOffset：表示动画执行的起点在整个动画的偏移时间位置和结束位置。默认是0.（可以影响子动画）使用这个属性和speed可以控制动画的播放效果。或者将动画暂停，由其控制图层展示到动画的某一帧的状态。值范围在【0,duration/speed】之间，超出大小将进行取余数操作。当变更起点后，图层会执行动画，最后回到起点状态。（即动画的实际执行时间不变） repeatCount:重复次数。设置为 INFINITY 表示无限循环。 repeatDuration：重复时间。其与repeatCount不能一起设置，否则会产生未定义行为。设置为 INFINITY 表示无限循环。 fillMode：表示动画开始前和动画结束后的图层状态。默认为kCAfILLModeRemoved。 kCAFillModeForwards ：动画开始前的状态是动画第一帧的效果。 kCAFillModeBackwards ：动画结束后的状态是动画最后一帧的效果。要求我们把animation.removeOnCompleted=NO（默认为YES，会在完成后移除）。但在之后，我们需要自己手动把动画从layer中移除，否则会引起内存泄露。 kCAFillModeBoth kCAFillModeRemoved 动画的暂停、倒退和快进操作： 暂停：使speed=0即可让动画暂停。由于无法改变已经添加到layer上的动画对象的属性，所以，我们可以改变layer的speed属性来达成这一目的。且由于layer的层级继承关系，在将会对其sublayer上的所有动画产生效果。（如果想要让application的所有动画都暂停或者减速，可以修改 window.layer.speed= 0） 慢放：设置一个[0,1]之间的speed，可以达到慢放的效果。 倒退：设置一个负值的speed，可以使动画反向执行。（正负影响方向，绝对值影响速度） 快进：设置一个大于0的speed可以达到快进的效果。 手工动画： 方法：timeOffset 一个很有用的功能在于你可以它可以让你手动控制动画进程，通过设置 speed 为0，可以禁用动画的自动播放，然后来使用 timeOffset 来来回显示动画序列。 场景：这对于一些复杂的组合图层变化来说，比如说关键帧这样更加复杂的情况，或者有多个图层的动画组，相对于实时计算每个图层的属性而言，这就显得方便的多了。 UIView动画接口： @interface UIView(UIViewAnimationWithBlocks) 属性动画接口（隐式动画、动画组等） + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); + (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); // delay = 0.0, options = 0 + (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations NS_AVAILABLE_IOS(4_0); // delay = 0.0, options = 0, completion = NULL /* Performs `animations` using a timing curve described by the motion of a spring. When `dampingRatio` is 1, the animation will smoothly decelerate to its final model values without oscillating. Damping ratios less than 1 will oscillate more and more before coming to a complete stop. You can use the initial spring velocity to specify how fast the object at the end of the simulated spring was moving before it was attached. It's a unit coordinate system, where 1 is defined as travelling the total animation distance in a second. So if you're changing an object's position by 200pt in this animation, and you want the animation to behave as if the object was moving at 100pt/s before the animation started, you'd pass 0.5. You'll typically want to pass 0 for the velocity. */ + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0); 过渡动画接口 + (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); + (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); // toView added to fromView.superview, fromView removed from its superview /* Performs the requested system-provided animation on one or more views. Specify addtional animations in the parallelAnimations block. These additional animations will run alongside the system animation with the same timing and duration that the system animation defines/inherits. Additional animations should not modify properties of the view on which the system animation is being performed. Not all system animations honor all available options. */ + (void)performSystemAnimation:(UISystemAnimation)animation onViews:(NSArray&lt;__kindof UIView *&gt; *)views options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))parallelAnimations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0); @end @interface UIView (UIViewKeyframeAnimations) 关键帧动画接口 + (void)animateKeyframesWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewKeyframeAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0); + (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations NS_AVAILABLE_IOS(7_0); // start time and duration are values between 0.0 and 1.0 specifying time and duration relative to the overall time of the keyframe animation @end 动画缓冲：（即动画的变化速度控制） CALayer设置动画变化属性：创建 CAMediaTimingFunction ，最简单的方式是调用 +timingFunctionWithName: 的构造方法，内置类型如下： kCAMediaTimingFunctionLinear ：该选项创建了一个线性的计时函数，同样也是 显示动画的 timingFunction 属性为空时候的默认函数。线性步调对于那些立即加速并且保持匀速到达终点的场景会有意义。 kCAMediaTimingFunctionEaseIn：创建了一个慢慢加速然后突然停止的方法。 kCAMediaTimingFunctionEaseOut：以一个全速开始，然后慢慢减速停止。 kCAMediaTimingFunctionEaseInEaseOut：创建了一个慢慢加速然后再慢慢减速的过程。这是现实世界大多数物体移动的方式，也是大多数动画来说最好的选择。 kCAMediaTimingFunctionDefault（效果与EaseInEaseOut几乎没有区别）：是隐式动画的默认方式，但不是显示动画的默认方式。 UIKit的动画也同样支持这些缓冲方法的使用，尽管语法和常量有些不同: UIViewAnimationOptionCurveEaseInOut ：默认值。 UIViewAnimationOptionCurveEaseIn UIViewAnimationOptionCurveEaseOut UIViewAnimationOptionCurveLinear 对动画设置指定的缓冲方式： 隐式动画：如果想改变隐式动画的计时函数，同样也可以使用 CATransaction 的 +setAnimationTimingFunction: 方法。 显式动画：需要设置 CAAnimation 的 timingFunction 属性，是 CAMediaTimingFunction 类的一个对象。 关键帧动画：CAKeyframeAnimation 有一个 NSArray 类型的 timingFunctions 属性，我们可以用它来对每次动画的步骤指定不同的计时函数。但是指定函数的个数一定要等于 keyframes 数组的元素个数减一，因为它是描述每一帧之间动画速度的函数。 自定义缓冲函数：（简单的缓冲变化可以用此方法实现） 缓冲函数的数学表示：三次贝塞尔曲线。 一个三次贝塞尔曲线通过四个点来定义，第一个和最后一个点代表了曲线的起点和终点，剩下中间两个点叫做控制点，因为它们控制了曲线的形状，贝塞尔曲线的控制点其实是位于曲线之外的点，也就是说曲线并不一定要穿过它们。你可以把它们想象成吸引经过它们曲线的磁铁。 使用函数：一个有四个浮点参数的 +functionWithControlPoints:::: 。 代码示例： CAMediaTimingFunction* function = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; function = [CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1]; float cp1[2]; float cp2[2]; [function getControlPointAtIndex:1 values:cp1]; [function getControlPointAtIndex:2 values:cp2]; UIBezierPath* bpath = [[UIBezierPath alloc] init]; [bpath moveToPoint:CGPointZero]; [bpath addCurveToPoint:CGPointMake(1, 1) controlPoint1:CGPointMake(cp1[0], cp1[1]) controlPoint2:CGPointMake(cp2[0], cp2[1])]; [bpath applyTransform:CGAffineTransformMakeScale(200, 200)]; CAShapeLayer* shl = [CAShapeLayer layer]; shl.position = CGPointMake(100, 500); shl.strokeColor = [UIColor redColor].CGColor; shl.fillColor = [UIColor clearColor].CGColor; shl.lineWidth = 4.0f; shl.path = bpath.CGPath; shl.geometryFlipped = YES; [self.view.layer addSublayer:shl]; 复杂的缓冲变化方式： 例如： 实现方式： 用 CAKeyframeAnimation 创建一个动画，然后分割成几个步骤，每个小步骤使用自己的计时函数，这里大致有两种方式： 自己划分的关键帧，然后填充每一段关键帧之间的缓冲函数。 使用自动化流程采集海量关键帧（数量在 60*duration左右），直接使用关键帧完成整个动画。 要求我们必须有相应动画的缓冲函数，这个可以在网站 复杂的速度变化曲线：https://github.com/warrenm/AHEasing（C语言实现），可以用于自动提取关键帧动画。 有了这个函数后，我们只要封装一个函数，传入formValue 和 toValue ，以及 time，即可返回相应的中间态数据，然后将这个数据添加到关键帧动画的 values 中即可。 使用定时器逐帧更新实现动画（见第11章，“基于定时器的动画”）。 使用定时器实现关键帧动画： CADisplayLink 是CoreAnimation提供的另一个类似于 NSTimer 的类，它总是在屏幕完成一次更新之前启动，它的接口设计的和 NSTimer 很类似，所以它实际上就是一个内置实现的替代，但是和 timeInterval 以秒为单位不同， CADisplayLink 有一个整型的 frameInterval 属性，指定了间隔多少帧之后才执行。默认值是1，意味着每次屏幕更新之前都会执行一次。 CADisplayLink 会保证帧率足够连续，使得动画看起来更加平滑，但即使 CADisplayLink 也不能保证每一帧都按计划执行，一些失去控制的离散的任务或者事件（例如资源紧张的后台程序）可能会导致动画偶尔地丢帧。当使用 NSTimer 的时候，一旦有机会计时器就会开启（一定会补偿执行），但是 CADisplayLink 却不一样：如果它丢失了帧，就会直接忽略它们，然后在下一次更新的时候接着运行。 基于第二点特性，我们在刷新时，应该计算的是实际的刷新间隔，而不是使用固定的时间间隔去累加。计算实际时间间隔可以使用CACurrentMediaTime()多次获取时间然后取差值得到。 使用示例： CADisplayLink和NSTimer一样，可以被加入多个不同模式的定时器： 软件绘图（Core Graphics）： 软件绘图不仅效率低，还会消耗可观的内存。 内存消耗的体现：一旦你实现了 CALayerDelegate 协议中的 -drawLayer:inContext: 方法或者 UIView 中的 -drawRect: 方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽*图层高*4字节，宽高的单位均为像素。对于一个在Retina iPad上的全屏图层来说，这个内存量就是 2048*1526*4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配. 用Core Graphics来绘图的一个通常原因就是只是用图片或是图层效果不能轻易地绘制出矢量图形。矢量图形包括： 任意多边形（不仅仅是一个矩形） 斜线或曲线 文本 渐变 性能优化基本方案：提高绘制性能（采用异步绘制、专门的layer类），以及减少绘制数量（脏矩形） Core Animation为这些矢量图形类型的绘制提供了专门的类，并给他们提供硬件支持（如果可以满足要求，建议使用Core Animation代替Core Graphics），这些总体上都比Core Graphics更快，同时他们也避免了创造一个寄宿图。具体如下： CAShapeLayer ：可以绘制多边形，直线和曲线。 CATextLayer ：可以绘制文本。 CAGradientLayer： 用来绘制渐变。 脏矩形：在使用Core Graphics绘制图形时，每次变化可能不需要重绘整个layer的区域，那么可以指定只重绘部分的Rect。（以UIView为例） [self setNeedsDisplayInRect:[self brushRectForPoint:point]]：设置需要更新的区域。 在 drawRect 中完成重绘。可以使用 CGRectIntersectsRect(rect, brushRect) 精确判断区域。 异步绘制： CATiledLayer：可以将图层再次分割成独立更新的小块（类似于脏矩形自动更新的概念）， CATiledLayer 还有一个有趣的特性：在多个线程中为每个小块同时调用 -drawLayer:inContext: 方法。这就避免了阻塞用户交互而且能够利用多核心新片来更快地绘制。只有一个小块的 CATiledLayer 是实现异步更新图片视图的简单方法。 CALayer的drawsAsynchronously属性： 作用：它对传入 -drawLayer:inContext: 的CGContext进行改动，允许CGContext延缓绘制命令的执行以至于不阻塞用户交互。 它与 CATiledLayer 使用的异步绘制并不相同。它自己的 -drawLayer:inContext: 方法只会在主线程调用，但是CGContext并不等待每个绘制命令的结束。相反地，它会将命令加入队列，当方法返回时，在后台线程逐个执行真正的绘制。 使用场景：这个特性在需要频繁重绘的视图上效果最好（比如我们的绘图应用，或者诸如 UITableViewCell 之类的），对那些只绘制一次或很少重绘的图层内容来说没什么太大的帮助。 异步线程执行绘制：由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：需要注意的是，由于要异步绘制，所以必须实现的是 displayLayer： 方法. - (void)displayLayer:(CALayer*)layer{ dispatch_async(backgroundQueue, ^{ CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^{ layer.contents = img; }); }); } 参考文章： CAShapeLayer与贝塞尔曲线参考文章：http://www.jianshu.com/p/c5cbb5e05075 Mask动画参考文章：http://www.jianshu.com/p/3c925a1609f8 app性能问题定位与解决 CATransform3D vs. CGAffineTransform ： http://stackoverflow.com/questions/567829/catransform3d-vs-cgaffinetransform ，前者用于2D，后者用于3D。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[KSCrash简介【作者版】]]></title>
      <url>%2F2017%2F02%2F08%2FKSCrash%E7%AE%80%E4%BB%8B%E3%80%90%E4%BD%9C%E8%80%85%E7%89%88%E3%80%91%2F</url>
      <content type="text"><![CDATA[KSCrash简介【作者版】KSCrashKSCrash功能简介：以下是KSCrash的一些主要特点：崩溃记录相关：跟踪未捕获的C ++异常的真正原因。处理只能在Mach级被捕获的错误，如堆栈溢出。处理在KSCrash本身（或在用户崩溃处理程序回调）的崩溃。崩溃上报相关：生成完整的苹果格式的报告，但有很多额外信息无法上报。记录大量额外的信息，使用JSON格式上报。它的可插拔的服务器报告架构可以很容易地适应任何API服务。提供用户可操作接口，用于提供额外的数据上报（在崩溃发生之前和崩溃中执行）。额外功能：支持32位和64位模式。记录僵尸（释放的）对象，并在需要的时候访问尝试它。恢复在僵尸对象或内存操作中被释放的NSException消息。On-device symbolication 在某种情况下支持离线re-symbolication（必要的IOS版本有许多功能已被删节）。在寄存器和堆栈上的自省对象（C String和Objective-C Object，包括变量）。提取额外的对象信息给exception参考（such as "unrecognized selector sent to instance 0xa26d9a0"等）转储堆栈内容。诊断崩溃原因（Crash Doctor）。KSCrash可以处理以下类型的崩溃：Mach kernel exceptionsFatal signalsC++ exceptionsObjective-C exceptionsMain thread deadlock (实验性质)Custom crashes (e.g. from scripting languages)KSCrash支持发送以下服务器的报告：HockeyQuincyKitVictoryEmail报告格式示例：下面是它可以生成报告的一些例子。新特性简介：C ++异常处理一般来说，如果您的应用程序终止由于未捕获的C ++异常，你得到的是这样的：normalThread&nbsp;&nbsp;0&nbsp;&nbsp;name:&nbsp;&nbsp; Dispatch&nbsp;&nbsp;queue:&nbsp;&nbsp;com.apple.main-thread Thread&nbsp;&nbsp;0&nbsp;&nbsp;Crashed: 0&nbsp;&nbsp;&nbsp;&nbsp;libsystem_kernel.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x9750ea6a&nbsp;&nbsp;0x974fa000&nbsp;&nbsp;+&nbsp;&nbsp;84586&nbsp;&nbsp;(__pthread_kill&nbsp;&nbsp;+&nbsp;&nbsp;10) 1&nbsp;&nbsp;&nbsp;&nbsp;libsystem_sim_c.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04d56578&nbsp;&nbsp;0x4d0f000&nbsp;&nbsp;+&nbsp;&nbsp;292216&nbsp;&nbsp;(abort&nbsp;&nbsp;+&nbsp;&nbsp;137) 2&nbsp;&nbsp;&nbsp;&nbsp;libc++abi.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04ed6f78&nbsp;&nbsp;0x4ed4000&nbsp;&nbsp;+&nbsp;&nbsp;12152&nbsp;&nbsp;(abort_message&nbsp;&nbsp;+&nbsp;&nbsp;102) 3&nbsp;&nbsp;&nbsp;&nbsp;libc++abi.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04ed4a20&nbsp;&nbsp;0x4ed4000&nbsp;&nbsp;+&nbsp;&nbsp;2592&nbsp;&nbsp;(_ZL17default_terminatev&nbsp;&nbsp;+&nbsp;&nbsp;29) 4&nbsp;&nbsp;&nbsp;&nbsp;libobjc.A.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x013110d0&nbsp;&nbsp;0x130b000&nbsp;&nbsp;+&nbsp;&nbsp;24784&nbsp;&nbsp;(_ZL15_objc_terminatev&nbsp;&nbsp;+&nbsp;&nbsp;109) 5&nbsp;&nbsp;&nbsp;&nbsp;libc++abi.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04ed4a60&nbsp;&nbsp;0x4ed4000&nbsp;&nbsp;+&nbsp;&nbsp;2656&nbsp;&nbsp;(_ZL19safe_handler_callerPFvvE&nbsp;&nbsp;+&nbsp;&nbsp;8) 6&nbsp;&nbsp;&nbsp;&nbsp;libc++abi.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04ed4ac8&nbsp;&nbsp;0x4ed4000&nbsp;&nbsp;+&nbsp;&nbsp;2760&nbsp;&nbsp;(_ZSt9terminatev&nbsp;&nbsp;+&nbsp;&nbsp;18) 7&nbsp;&nbsp;&nbsp;&nbsp;libc++abi.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04ed5c48&nbsp;&nbsp;0x4ed4000&nbsp;&nbsp;+&nbsp;&nbsp;7240&nbsp;&nbsp;(__cxa_rethrow&nbsp;&nbsp;+&nbsp;&nbsp;77) 8&nbsp;&nbsp;&nbsp;&nbsp;libobjc.A.dylib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01310fb8&nbsp;&nbsp;0x130b000&nbsp;&nbsp;+&nbsp;&nbsp;24504&nbsp;&nbsp;(objc_exception_rethrow&nbsp;&nbsp;+&nbsp;&nbsp;42) 9&nbsp;&nbsp;&nbsp;&nbsp;CoreFoundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01f2af98&nbsp;&nbsp;0x1ef9000&nbsp;&nbsp;+&nbsp;&nbsp;204696&nbsp;&nbsp;(CFRunLoopRunSpecific&nbsp;&nbsp;+&nbsp;&nbsp;360) ...没办法追踪这个exception是什么或者它是从哪里抛出的。现在有了KSCrash，你将得到捕获的异常类型，描述，以及它抛出的位置：normalApplication&nbsp;&nbsp;Specific&nbsp;&nbsp;Information: ***&nbsp;&nbsp;Terminating&nbsp;&nbsp;app&nbsp;&nbsp;due&nbsp;&nbsp;to&nbsp;&nbsp;uncaught&nbsp;&nbsp;exception&nbsp;&nbsp;'MyException',&nbsp;&nbsp;reason:&nbsp;&nbsp;'Something&nbsp;&nbsp;bad&nbsp;&nbsp;happened...' Thread&nbsp;&nbsp;0&nbsp;&nbsp;name:&nbsp;&nbsp; Dispatch&nbsp;&nbsp;queue:&nbsp;&nbsp;com.apple.main-thread Thread&nbsp;&nbsp;0&nbsp;&nbsp;Crashed: 0&nbsp;&nbsp;&nbsp;&nbsp;Crash-Tester&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000ad80&nbsp;&nbsp;0x1000&nbsp;&nbsp;+&nbsp;&nbsp;40320&nbsp;&nbsp;(-[Crasher&nbsp;&nbsp;throwUncaughtCPPException]&nbsp;&nbsp;+&nbsp;&nbsp;0) 1&nbsp;&nbsp;&nbsp;&nbsp;Crash-Tester&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000842e&nbsp;&nbsp;0x1000&nbsp;&nbsp;+&nbsp;&nbsp;29742&nbsp;&nbsp;(__32-[AppDelegate(UI)&nbsp;&nbsp;crashCommands]_block_invoke343&nbsp;&nbsp;+&nbsp;&nbsp;78) 2&nbsp;&nbsp;&nbsp;&nbsp;Crash-Tester&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00009523&nbsp;&nbsp;0x1000&nbsp;&nbsp;+&nbsp;&nbsp;34083&nbsp;&nbsp;(-[CommandEntry&nbsp;&nbsp;executeWithViewController:]&nbsp;&nbsp;+&nbsp;&nbsp;67) 3&nbsp;&nbsp;&nbsp;&nbsp;Crash-Tester&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00009c0a&nbsp;&nbsp;0x1000&nbsp;&nbsp;+&nbsp;&nbsp;35850&nbsp;&nbsp;(-[CommandTVC&nbsp;&nbsp;tableView:didSelectRowAtIndexPath:]&nbsp;&nbsp;+&nbsp;&nbsp;154) 4&nbsp;&nbsp;&nbsp;&nbsp;UIKit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0016f285&nbsp;&nbsp;0xb4000&nbsp;&nbsp;+&nbsp;&nbsp;766597&nbsp;&nbsp;(-[UITableView&nbsp;&nbsp;_selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:]&nbsp;&nbsp;+&nbsp;&nbsp;1194) 5&nbsp;&nbsp;&nbsp;&nbsp;UIKit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0016f4ed&nbsp;&nbsp;0xb4000&nbsp;&nbsp;+&nbsp;&nbsp;767213&nbsp;&nbsp;(-[UITableView&nbsp;&nbsp;_userSelectRowAtPendingSelectionIndexPath:]&nbsp;&nbsp;+&nbsp;&nbsp;201) 6&nbsp;&nbsp;&nbsp;&nbsp;Foundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00b795b3&nbsp;&nbsp;0xb6e000&nbsp;&nbsp;+&nbsp;&nbsp;46515&nbsp;&nbsp;(__NSFireDelayedPerform&nbsp;&nbsp;+&nbsp;&nbsp;380) 7&nbsp;&nbsp;&nbsp;&nbsp;CoreFoundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01f45376&nbsp;&nbsp;0x1efa000&nbsp;&nbsp;+&nbsp;&nbsp;308086&nbsp;&nbsp;(__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__&nbsp;&nbsp;+&nbsp;&nbsp;22) 8&nbsp;&nbsp;&nbsp;&nbsp;CoreFoundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01f44e06&nbsp;&nbsp;0x1efa000&nbsp;&nbsp;+&nbsp;&nbsp;306694&nbsp;&nbsp;(__CFRunLoopDoTimer&nbsp;&nbsp;+&nbsp;&nbsp;534) 9&nbsp;&nbsp;&nbsp;&nbsp;CoreFoundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01f2ca82&nbsp;&nbsp;0x1efa000&nbsp;&nbsp;+&nbsp;&nbsp;207490&nbsp;&nbsp;(__CFRunLoopRun&nbsp;&nbsp;+&nbsp;&nbsp;1810) 10&nbsp;&nbsp; CoreFoundation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01f2bf44&nbsp;&nbsp;0x1efa000&nbsp;&nbsp;+&nbsp;&nbsp;204612&nbsp;&nbsp;(CFRunLoopRunSpecific&nbsp;&nbsp;+&nbsp;&nbsp;276) ...方便的C ++开发帮手如果您打开跟踪打印：[KSCrash sharedInstance ] .printTraceToStdout = YES ;它会打印正确的堆栈跟踪到标准输出，只要你的应用程序抛出一个未捕获C ++异常！否则，调试器只会导致你在异常被重新抛出。自定义崩溃和堆栈跟踪现在，您可以自己定制的崩溃和堆栈跟踪（例如对于脚本语言的崩溃）：- (void) reportUserException:(NSString*) name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reason:(NSString*) reason &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lineOfCode:(NSString*) lineOfCode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stackTrace:(NSArray*) stackTrace &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terminateProgram:(BOOL) terminateProgram; 见KSCrash.h了解详情。不稳定的特点以下功能应被视为“不稳定”，默认情况下被禁用：死锁检测如何导入KSCrash打开ios.workspace。选择KSCrash Scheme。Build或者Archiver项目。然后，你像使用任何其他框架一样使用它。如何使用KSCrash将该框架添加到项目中（或添加KSCrash项目作为依赖）下面的系统框架和库添加到您的项目：libc++.dyliblibz.dylibMessageUI.framework&nbsp;&nbsp;【iOS only】SystemConfiguration.frameworkFoundation.frameworkCoreGraphics.frameworkUIKit.framework【iOS only】添加 "-ObjC" 标示到&nbsp;&nbsp; Build Setting - Other Linker Flags 中.【加载分类数据】【可选】如果希望自己定制化KSCrash内容，那么可以将以下内容添加到你的[application：didFinishLaunchingWithOptions：] 方法中：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KSCrash *ksCrash = [KSCrash sharedInstance];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ksCrash.catchZombies = YES;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ksCrash.introspectMemory = YES;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ksCrash install];&nbsp;&nbsp;【可选】如果希望使用KSCrash的上报服务器，那么可以将以下内容添加到你的[application：didFinishLaunchingWithOptions：] 方法中：【如果希望定制化KSCrash的属性，那么应该通过修改源码实现】#import &lt;KSCrash/KSCrash.h&gt;// Include to use the standard reporter.#import &lt;KSCrash/KSCrashInstallationStandard.h&gt;// Include to use Quincy or Hockey.#import &lt;KSCrash/KSCrashInstallationQuincyHockey.h&gt;// Include to use the email reporter.#import &lt;KSCrash/KSCrashInstallationEmail.h&gt;// Include to use Victory.#import &lt;KSCrash/KSCrashInstallationVictory.h&gt;- (BOOL)application:(UIApplication*) application didFinishLaunchingWithOptions:(NSDictionary*) launchOptions{KSCrashInstallationStandard* installation = [KSCrashInstallationStandard sharedInstance];installation.url = [NSURL URLWithString:@"http://put.your.url.here"];// OR:KSCrashInstallationQuincy* installation = [KSCrashInstallationQuincy sharedInstance];installation.url = [NSURL URLWithString:@"http://put.your.url.here"];// OR:KSCrashInstallationHockey* installation = [KSCrashInstallationHockey sharedInstance];installation.appIdentifier = @"PUT_YOUR_HOCKEY_APP_ID_HERE";// OR:KSCrashInstallationEmail* installation = [KSCrashInstallationEmail sharedInstance];installation.recipients = @[@"some@email.address"];// Optional (Email): Send Apple-style reports instead of JSON[installation setReportStyle:KSCrashEmailReportStyleApple useDefaultFilenameFormat:YES];// Optional: Add an alert confirmation (recommended for email installation)[installation addConditionalAlertWithTitle:@"Crash Detected"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message:@"The app crashed last time it was launched. Send a crash report?" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yesAnswer:@"Sure!" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noAnswer:@"No thanks"]; // OR:KSCrashInstallationVictory* installation = [KSCrashInstallationVictory sharedInstance];installation.url = [NSURL URLWithString:@"https://put.your.url.here/api/v1/crash/&lt;application key&gt;"];[installation install];&nbsp;&nbsp;&nbsp;&nbsp; … }以上操作，将安装崩溃监视系统（拦截崩溃并存储报告到磁盘）。请注意，有可能要为具体的设备设置其他属性。【可选】如果你使用KSCrashInstallation安装KSCrash，一旦你准备好发送任务，那么可以调用以下方法发送崩溃数据：[installation sendAllReportsWithCompletion:^(NSArray *filteredReports, BOOL completed, NSError *error){&nbsp;&nbsp;// Stuff to do when report sending is complete}];推荐阅读如果可能的话，你应该阅读下面的头文件，充分了解哪些功能KSCrash了，以及如何使用它们：KSCrash.hKSCrashInstallation.hKSCrashInstallation(SPECIFIC TYPE).hArchitecture.md高级用法启用On-Device symbolicationOn-device symbolication需要基本符号存在于最终程序中。为了实现这一目标，我们需要设置 Build Setting - Strip Style 为 Debugging Symbol。如果这样做将会使你的最终二进制文件大小增加约5％，，但你将获得On-device symbolication的能力。启用高级功能：KSCrash拥有先进的功能，对于研究用户上报的崩溃报告时会非常有用。一些功能涉及到取舍，所以大部分都是默认禁用。自定义用户数据（userInfo in KSCrash.h）您可以通过操作KSCrash的 userInfo 属性&nbsp;&nbsp;，设置自定义的用户数据到下一个崩溃报告中。僵尸跟踪（zombieCacheSize in KSCrash.h）KSCrash具有检测僵尸实例（指向已释放的对象的野指针）的能力。它通过记录被释放的任何对象的 Address 和 Class 做到这一点。它在高速缓存中存储这些值，key是被释放对象的Address，value是被释放对象的Class。同时这个高速缓存的大小可以由你设置，但是缓存越小，就意味着越有可能发生散列碰撞，这将导致你失去先前已存储的释放对象的内容。当僵尸跟踪启用时，KSCrash还将记录最后一个NSException的内容并放到崩溃报告中。某些种类的内存损坏或堆栈损的坏崩溃会导致NSException被提前释放，这个功能可以提供关于元凶的真实信息，所以这个功能有时可能很方便。权衡：跟踪僵尸会在对象dealloc时增加非常轻微的开销，以及有一些内存占用。死锁检测（deadlockWatchdogInterval in KSCrash.h）警告警告警告警告警告警告警告此功能是不稳定的！它可能会错误判定并且主动使您的应用程序崩溃！如果你的主线程死锁，您的用户界面会变得反应迟钝，用户必须手动关闭应用程序（对此不会有崩溃报告）。随着死锁检测启用，为看门狗定时器设置一个时间阈值，如果有任何函数在主线程上的持续时间超过看门狗定时器的阈值，KSCrash将主动关闭应用程序，并且为主线程生成一个堆栈跟踪。这是美好的，但你必须小心：特别是应用程序初始化一般发生在主线程，如果你的初始化代码比看门狗定时器需要更长的时间，你的应用程序将被强制在启动时关机！如果启用此功能，您必须确保您正常运行的代码，无持有主线程比看门狗的阈值长！同时，你要定时器设置为一个足够低的值，赶在用户没有变得不耐烦之前触发看门狗触发手动关闭应用程序！权衡：死锁检测，但你一定要多多小心什么主线程上运行！内存内省（introspectMemory in KSCrash.h）当一个应用程序崩溃，通常在堆栈、寄存器甚至异常消息中会有一些对象和字符串的引用。启用内存内省后，KSCrash将会去尝试读取这些内存地址上的内容【Type、Value、ivars、Address、last_dealloc_obj等信息】，并将其记录到报告中。我们可以将不需要内省的类设置到KSCrash.doNotIntrospectClasses&nbsp;&nbsp;属性【列表】中。记录后，这些类的对象将只记录class name。自定义崩溃处理代码（onCrash in KSCrash.h）如果你想要在崩溃发生后做一些额外的处理（也许是为了增加更多的上下文数据报告），你可以设置这个属性，它是一个函数指针【非block】。但是，你必须确保你只使用异步安全的代码，并且确保不在这一段代码中调用OC代码【C和C++还是可以的】！虽然在很多情况下，你可以不必这样做，但在某些类别的崩溃中，编写不符合上述规定的程序代码会导致崩溃处理block崩溃！请注意，如果发生这种情况，KSCrash会检测到它，继续写一个完整的报告，尽管自定义处理程序代码可能没有完全运行。权衡：自定义崩溃处理代码，但是你必须要小心的编写它！KSCrash日志重定向这会将所有的KSCrash的输出被打印到控制台，或者将其写入一个文件来代替。主要是用这个来调试KSCrash本身，而是它可能还有其他用途，所以我开放它的API。示例工作区包括一些示例应用程序，这表明普通KSCrash用法。请看看AppDelegate.m在每个应用程序的顶部是做什么的说明。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac开发指南]]></title>
      <url>%2F2017%2F02%2F08%2FMac%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Mac开发指南 MAC使用的是 garbage collection environments （自动垃圾回收机制），不同于iOS的引用计数机制。我们不需要关心内存的回收问题，开开心心的写代码即可。 Mac遵循的是多窗口开发原则，如果一个窗口发生了崩溃，那么其他窗口并不会受它影响。（这个对发现问题造成很大的困扰）Mac的页面跳转是基于窗口的【NSWindow】，窗口的管理是基于窗口管理器【NSWindowController】,Mac应用基本的跳转模式是：参考文章：http://www.jianshu.com/p/0288fc89aea1要点：【winVC showWindow:nil】 &amp;&amp; 【winVC close】其内部的 window 是惰性加载的，所以有时候断点看会是空数据。Mac的页面跳转也可以只是用VC present，但是这样的话，页面展示效果非常差，无法切换窗口。Mac的appdelegate 常用回调：applicationDidFinishLaunching：应用启动applicationWillTerminate：应用收到退出消息applicationShouldHandleReopen：hasVisibleWindows：应用图标收到鼠标点击事件applicationWillBecomeActive：应用展示到前端applicationShouldTerminateAfterLastWindowClosed：应用的最后一个窗口被关闭注意，在mac OS 上，runloop有另外两种不一样的模式，所以不能加入到 default mode 中去。APPKIT_EXTERN NSString *NSModalPanelRunLoopMode;APPKIT_EXTERN NSString *NSEventTrackingRunLoopMode; Mac视图开发指南：mac视图基于NSView开发修改背景色：http://www.jianshu.com/p/80dcee893b2d，NSView没有backgroundColor属性，我们需要直接修改CALayer属性。坐标系问题：http://blog.csdn.net/benbenxiongyuan/article/details/7755584NSView：坐标原点在左下角，Y向上为正，X向右为正。但提供了一个而可覆盖的方法，isFlipped 返回YES时可以使用UIView的坐标系计算方式。UIView：坐标系在左上角，Y轴向下为正，X向右为正。CALayer：默认使用依附平台的坐标系。NSView默认是没有layer的，需要单独调用 view.wantsLayer = YES, 使其拥有layer，才能为它填充颜色等属性。关于mac app文件拖放的问题：主要的相关协议：NSDraggingSource：以view中的物体为源文件，拖出到桌面的操作。NSDraggingDestination：将外界物体拖入界面的操作。NSPasteboardItemDataProvider：剪切板操作。NSWindow默认实现了NSDraggingDestination大部分方法，且默认实现是如果 window.delegate 【一般是windowController】能够响应此方法，那么就将转发给delegate执行。只要刚开始在windowController中调用window的 - (void)registerForDraggedTypes:(NSArray&lt;NSString *&gt; *)newTypes; ；例如：[self.window registerForDraggedTypes:@[NSColorPboardType, NSFilenamesPboardType]]; 即可实现这些文件的拖拽。然后在 windowController 中实现这些 NSDraggingDestination 的主要方法。参考作品：【同时实现了拖入和拖出操作】DragDropDemo-master.zip关于Mac打开文件选择器的方法：NSOpenPanel:注意，如果希望使用文件选择器，必须在 capabalitis 中打开 sandBox 功能。但开了沙盒之后， 就啥都干不了了。参考文章：http://www.cnblogs.com/onecodego/p/3685864.htmlMac调用Terminal的方法：示例代码：NSString* runSystemCommand(NSString *cmd,NSString* currentDir){ NSTask* task = [[NSTask alloc] init]; task.launchPath = @"/bin/sh"; task.arguments = [NSArray arrayWithObjects:@"-c", cmd, nil]; if( validateString(currentDir) ){ task.currentDirectoryPath = currentDir; } NSPipe *pipe = [NSPipe pipe]; [task setStandardOutput:pipe]; [task setStandardError:pipe]; [task launch]; [task waitUntilExit]; int status = [task terminationStatus]; if (status == 0) NSLog(@"%@ Task succeeded.",cmd); else NSLog(@"%@ Task failed.",cmd); NSFileHandle *file = [pipe fileHandleForReading]; NSData *data = [file readDataToEndOfFile]; NSString *string; string = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; return string;}注意事项：终端的输出字符串不能太多，否则启动的执行程序的挂掉。【且没有任何征兆】如果执行python的脚本，发生崩溃，那么崩溃信息也会打印的。]]></content>
    </entry>

    
  
  
</search>
