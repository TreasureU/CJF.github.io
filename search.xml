<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F02%2F02%2F%E5%9F%BA%E6%9C%ACCrash%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[基本Crash编程指南ios崩溃分类：【两大类】NSException:程序抛出的异常，没有被捕获造成的。分类：NSGenericException：一般性异常。比如迭代器错误。NSRangeException：范围异常，通常发生在数组越界上。NSInvalidArgumentException：无效参数错误，比如消息转发出错，把一个消息转发给一个无法处理这则消息的对象：unrecognized selector sent to instance 0x1756f5f0。NSInternalInconsistencyException：内部不一致异常。可能发生在Main.storyboard配置出错，以及UITableView的数据源和你插入或者删除的操作不一致等地方。NSFileHandleOperationException：文件操作相关的异常。NSObjectNotAvailableExceptionNSDestinationInvalidExceptionNSPortReceiveExceptionNSInconsistentArchiveExceptionNSFileHandleOperationException…...参考资料：https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Exceptions/Concepts/PredefinedExceptions.html#//apple_ref/doc/uid/20000057-BCIGHECASignal：各种其他类型的异常。分类：SEGV:无效内存地址，比如空指针，未初始化指针，栈溢出，zombie对象访问等SIGBUS：总线错误。与SIGSEGV不同的是，SIGSEGV访问的是无效地址（比如虚存映射不到物理内存），而SIGBUS访问的是有效地址，但总线访问异常（比如地址对齐问题）SIGABRT：收到Abort信号，可能自身调用abort()或者收到外部发送过来的信号SIGILL：尝试执行非法的指令，可能不被识别或者没有权限SIGFPE：Floating Point Error,数学计算相关问题,比如除零操作SIGPIPE：管道另一端没有进程接手数据参考资料：signal函数：http://en.cppreference.com/w/c/program/signal signal handler详解：www.cnblogs.com/clover-toeic/p/4126594.html在【Linux】上若信号与硬件故障(如SIGBUS/SIGFPE/SIGILL/SIGSEGV)或定时器超时相关，该信号会发往引起该事件的线程。其它信号除非显式指定目标线程，否则通常发往主线程(哪怕信号处理函数由其他线程注册)，仅当主线程屏蔽该信号时才发往某个具有处理能力的线程。【UNIX -&gt; BSD\Linux\FreeBSD -&gt; Mac OS】区别对比：信号由操作系统发出，更为底层，与程序的执行是异步的，由特殊的处理函数进行异步处理（signal / signaction），与程序语言之间几乎没有集成，处理难度更大。（编程语言）异常则由程序语言和运行时提供，是一种可控的、同步激发处理、被语言和运行时支持的、可进行结构化处理的流程控制机制（与 return 和 if else for while 等没有本质区别）。总的来说，后者处理过程由于是语言直接支持的，难度较小，资源管理较容易，是一种比较「高级」的机制。后者是可以基于前者实现（也可以完全无关）。除非环境明确要求，一般的程序流程控制只涉及后者；如果环境支持，可能会将 OS 发出的信号包装成对应的异常交给应用处理。NSException与NSError内容：基础知识：ARC在默认情况下NSException不是线程安全的，具体来说就是如果抛出异常，那么本应在作用域尾释放的对象现在却不会自动释放了。如果想生成异常安全代码，那么需要添加额外的编译标志： -fobjc-arc-exceptions，但是一旦添加，在未抛出异常时也会执行这段代码，使程序显得臃肿，效率下降。对此IOS的异常使用策略是：只在极其极端的情况下才抛出异常，异常一旦抛出就无需考虑恢复问题，而且程序此时应该退出。（俗称crash）对于出现不那么严重的错误，我们通常可以返回 nil，或者 通过NSError**返回NSError对象来描述异常。 前者通常用于带有返回值的函数调用中。后者通常用于 delegate回调 以及普通函数调用中。当文件处于 objective-C++模式时，编译器会自动把 -fobjc-arc-exceptions 打开。NSError对象探究：（可以参考P87）其有三大主要参数：Error domain (错误范围，字符串)、Error code（错误类型，整数型）、User Info(用户信息，字典)。具体内部用法和外部用法可以参考P87try-catch-finally的执行顺序探究：（尽量不要使用，因为NSException 存在资源管理问题或者效率问题）使用 try-catch-finally来捕获异常。在三段式的结构中，如果发生什么，finally中的语句都将被执行。（即使是在 catch中再次抛出异常，需要打断当前函数执行，进入上一层异常处理时，也是需要先执行finally再执行上层语句的）如果异常不能被当前的函数捕获，那么当前函数的执行将立即被打断，并将异常向上一级传递处理。具体可以参考文中代码实验。参考文章：http://www.cocoachina.com/ios/20141229/10787.html附加：使用assert语句判断正确：在assert（ 表达式 ），当表达式结果为NO时，abort。单个crash文件解析方案：（所需文件： xxx.app xxx.app.dsym xxx.crash ）export DEVELOPER_DIR="/Applications/XCode.app/Contents/Developer"/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash Jdipad.crash Jdipad.app.dSYM &gt;crash.txt单条crash语句解析方案：atos的语法： atos -arch &lt;体系架构&gt; -o &lt;符号表文件&gt; -l &lt;0x程序基地址&gt; &lt;0x语句地址&gt; =&gt; 选取方案atos -arch &lt;体系架构&gt; -o &lt;符号表文件&gt; &lt;0x偏移地址&gt;地址： 获取到该crash语句的 基地址（即Jdipad程序的object_addr） 和 语句符号地址 （即Jdipad程序的symbol_addr）。注意需要转换到16进制地址，且例如 0x12412314124,注意 前缀是必须的。一个符号表文件的程序开始位置不一定是0，每个符号表可能是不同的，一般是0x1000或者0x4000，体系架构：获取发生该崩溃的机器的体系结构（armv7\armv7s\arm64）。注意，这个体系结构是设备向下兼容体系，即如果一台armv7s的设备，但包没有armv7s的体系结构只有armv7和arm64的体系结构，那么该设备将运行在 armv7 的体系结构代码上。符号表文件：将 dSYM 文件 或者是 .app 文件放在同一目录下： 使用 dSYM文件是一定可以解析成功的，里面包含所有的符号表信息：使用语句 atos -arch &lt;armxxx&gt; -o Jdipad.app.dSYM/Contents/Resources/DWARF/Jdipad -l &lt;baseaddr&gt; &lt;symboladdr&gt;使用 .app文件解析也是可以的，但是要求.app在编译时将 strip style 选为 all symbols，并且 strip debug symbols during copy 选为 YES，此时.app内的二进制文件是可以接受解析的，否则是无效的。具体使用语句：atos -arch &lt;armxxx&gt; -o Jdipad.app/Jdipad -l &lt;0x baseaddr&gt; &lt;0x symboladdr&gt;如果找不到symbolicatecrash，可以使用 find /Applications/Xcode.app -name symbolicatecrash -type f 来查找。参考文章：http://blog.csdn.net/mkhgg/article/details/17247673KSCrash上报中的字段： baseaddr + symboladdr 能解析出的是函数调用者的起始行代码baseaddr + instructionaddr 能解析出的是 函数具体行的代码atos可以一次性解析多个数据：【这样可以显著提升速度】atos -o /BuildProducts/Release/Sketch.app/Contents/MacOS/Sketch -arch x86_64 -l 0x10acde000 0x10acea1d3 0x10ace4bea 0x10ace4b7a-[SKTGraphicView drawRect:] (in Sketch) (SKTGraphicView.m:445)-[SKTGraphic drawHandlesInView:] (in Sketch) (NSGeometry.h:110)-[SKTGraphic drawHandleInView:atPoint:] (in Sketch) (SKTGraphic.m:490)在符号表中，同一行代码调用在不同的arch中都是在同一个偏移位置的，因此必须在 atos 中指明 -arch 才能正确的解析数据。release版本crash调试方案：使用数据线连接上设备选中相应的设备，然后点击下方的箭头条以此可以调出设备的控制台其上会输出设备的控制台输出，此时，app如果有nslog，会选择输出到此处的控制台。基础crash上报方案：Apple Developer文章：https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012-BAJGFBFB基础crash捕捉机制： 使用try-carch机制捕获crash：http://www.cocoachina.com/ios/20141229/10787.html使用信号量和异常回调函数捕捉crash：http://www.xuebuyuan.com/1593344.html方案评价： 该方案针对 NSException引起的crash，可以完美的捕捉到，并且根据崩溃的线程打印出crash线程的stack信息。但是针对 signal引起的crash，将统一回调到主线程处理，打印主线程的调用栈信息。此时的信息是无效的。具体实现： 如果是NSException的异常，可以获取到以下完整信息： [exception name]: 独一无二的exception编号[exception reason]: 具体崩溃的原因[exception callStackSymbols]: 是一个数组，返回了发生崩溃所在的线程的调用栈信息（注意，仅针对发生崩溃的线程）。我们使用 【arr description】即可转化为 string并上报。如果是signal异常： 可以使用 backtrack（xx,xx） 和 backtrace_symbols( xx,xx )：获取到当前线程的调用栈。旧版本crash修复操作：参考文章：http://www.cocoawithlove.com/2010/05/handling-unhandled-exceptions-and.html续命方法：收集到数据后，将exception push到主线程2.重启主线程的runloop代价：这将导致异常线程使用的堆栈内存被永久的泄露，且崩溃函数永远无法返回。同时只能应对较为简单的崩溃。缺陷：有可能会失败，只能应对简单的crash。Mac机上获取Symbol：文件主路径：~/Library/Developer/Xcode/iOS DeviceSupport，该目录以系统作为划分依据。具体子目录：Symbols/System/Library/Frameworks：公有框架，每个框架文件里的同名文件，就是符号表文件。比如 xxx.framework/xxx需要注意的是，框架可能还会有自己引用的framework和dylib，可以考虑递归获取。Symbols/System/Library/PrivateFrameworks：公有框架，每个框架文件里的同名文件，就是符号表文件。比如 xxx.framework/xxx需要注意的是，框架可能还会有自己引用的framework和dylib，可以考虑递归获取。Symbol/usr/lib:下面有很多 dylib框架Symbol/usr/lib/system:下面有很多 dylib框架脚本文件：search_bin.sh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>%2F2016%2F12%2F29%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[以上是文章摘要以下是余下全文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F28%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
